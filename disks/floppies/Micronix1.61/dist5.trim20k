heap, followed by the sum of all the sizes.

.ti -5
-t	List type information for this file.  For each object file
the data file is: the size of an integer on the target machine, the
byte order it observes, the most restrictive storage bound it
enforces, and the maximum number of characters it permits in an external
name.  If the file is  library, the type of library is output and
the information above is output for each module in the library.
.bp
.ti -5
-u	List all undefined symbols in each file.  If -d is also 
specified, each undefined symbol is listed with the code "U".  The
value of each symbol, if non-zero, is the space to be reserved for it
at load time if it is not explicitly defined.

.ti -5
-v	Sort by value; implies the -d flag above.  Symbols of
equal value are sorted alphabetically.

.in -5
If no flags are given, the default is -[d u]; that is, all symbols
are listed, sorted in alphabetical order on symbol name.  If more
than one of the flags -[d s t y] is selected, then type information
is output er-user may change the owner of a file.

There is usually a name for each user I.D. number.
These names are kept in the system-wide file "/etc/passwd."

In order to discover who owns a file, type:
.sp
.ti +5
.bd
owner filename
.sp 
The program will look up the owner of the file
and attempt to express it as a user name.
If this is not possible, it will list the owner as a
numerical user I.D.
.sp 2
To change the owner of a file, type
.sp
.ti +5
.bd
owner -newowner filename
.sp
.bd
newowner 
may be a user name or a user I.D. number (names are recommended).

The 
.bd
owner 
program works equally well with list of files:
.sp
.ti +5
.bd
owner file1 file2 file3 file4 file5

reports on the ownership of each of the named files.
.bp
.in -5
.bd
EXAMPLES
.sp
.in +5
.ti +5
.bd
owner -root a.out	

makes file "a.out" belong to user "root".
.sp 2
.ti +5
.bd
owner a.out

reports who owns the file "a.out".
.sp 2
.in -5
.bd
FILES
.in +5
.br
/etc/passwd - user I.D. <-> name relationships

ace reserved for the
runtime stack plus first, followed by segment sizes, followed by the symbol list
specified with -d or -u.

<files> specifies zero or more files, which must be in relocatable
format, or standard library format, or in UNIX/V6 library format, or
UNIX/V7 library format.  If more than one file, or a library, is
specified, the name of ech separate file or module precedes any
information output for it, each name followed by a colon and a 
newline; if -s is given, a line of totals is also output.  If no
<files> are specified, or if "-" is encountered on the command
line, xeq is used.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
.bd
Obj
returns success if no diagnostics are produced, that is, if all
reads are successful and all file formats are valid.
.sp 2
.in -5
.bd
EXAMPLE
.in +5
.br
To obtain a list of all symbols in a module:
.sp
.in +5
.bd 7
% obj alloc.o
.br
0x00000074T_alloc
.br
0x00000000U_exit
.br
0x000001feT_free
.br
0x000000beT_nalloc
.br
0x00000000U_sbreak        
.br
0x00000000U_write         
.in 
.in 5
.sp 2
.bd
SEE ALSO
.br
.in .in 10
.rm 79
.he "          ptc (1)                        4/6/83                         ptc (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
ptc
- Pascal to C translator
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
ptc -[flags] <file>
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
Ptc
is a program that accepts as input lines of Pascal text and produces
as output a corresponding C program which is acceptable to the
Whitesmiths, Ltd. C compiler.  If <file> is present, it is taken as
the Pascal program to translate; otherwise input is taken from STDIN.     

The flags are:
.sp 
.in +5
.ta 5
.ti -5
-c	Pass comments through to the C program.

.ti -5
-f	Set the precision for reals to single precision (float).
Default is double.

.ti -5
-k	Permit pointer types to be defined using type identifiers from
outer blocks.  Default is ISO standard, i.e., the type pointed to must
be defined in the same type declaration as the pointer type definition.

.ti -5
-m#	Make # the number of bits in MAXINT exclu+5
lib (1), link (1), lord (1), cc (1), as (1), cp1 (1), cp2 (1), cpp (1) 

NOTE: This program and documentation are products of Whitesmiths, Ltd.,
and are sold separately.
unt", we apologize.  But if we asked you to dismount a device,
you'd just have silly images of spurs jangling while you drawl
"Whoa, there, old floppy."



.ti -5
.bd
SEE ALSO
.br
.bd
umount (1)
- to reverse the effects of 
.bd
mount.
.br
.bd
fsck (1)
- to repair file systems.
.br
.bd
mkdir (1)
- to create a new directory.
.br
.bd
mkfs (.in 10
.rm 79
.he "          owner (1)                      4/6/83                       owner (1)
.fo "                                           -#-"
.bd          
NAME
.in +5
.br
.bd
owner 
- file ownership
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
owner [-user] file ...
.sp 2
.in -5
.bd
DESCRIPTION   
.in +5
.br
Every Micronix file has associated with it a user I.D. number -
the "owner" of the file.

The 
.bd
owner 
utility program allows you to examine or change
this file owner number.
.bd 
NOTE:
Only the supding the sign bit,
e.g., MAXINT becomes 32767 for -m15, 1 for -m, etc.  Default for
MAXINT is 32766 [sic].  Acceptable values for # are in the range
[0, 32).

.ti -5
-o*	Write the C program to the file * and diagnostics to STDOUT.
Default is STDOUT for the C program and STDERR for diagnostics.

.ti -5
-r	Turn off runtime array bounds checks.

.ti -5
-s#	Make # the number of bits in the maximum allowable set size,
i.e., the size of all sets whose base type is integer becomes the
specified power of two.  Acceptable values are in the range [0, 32).
Default is 8 (256 elements).

.in -5
The CP/M operating system implementation on the Intel 8080 and Zilog
Z80 restricts the acceptable value for # to the range [0, 16]; for
maximum portability, this restriction should be honored.

Identifiers are mapped to uppercase to keep from conflicting with those
declared as reserved words in C.  Moreover, structure declarations may
be produced that contain conflicting field declarations; and
declarations are present for library through
a dump with the
.bd
mount/dir, ncheck,
or
.bd
ls -R
commands.
.sp
.bd
Td 
is a hybrid, in that some options must be entered on the command line
while others are handled interactively. 
.sp
.bd
Command Line Options:
.sp 2
.in +5
.ta 5
.ti -5
-a	All.  Dump all files.  Without this flag, only files under 1000 
blocks long are dumped.
.sp
.ti -5
-dN	Day. Dump only files newer than N days old.
Avoid using this flag along with the incremental option,
because the results depend on when the last incremental dump was performed,
which gets confusing.  Use the 
.bd
d
and
.bd
h
options only when you mean "Copy all of the files changed since this many
days/hours ago, regardless of whether they were dumped before or since then."
.sp
.ti -5
-hN	Hour.  Dump only files newer than N hours old. Note: The -d 
and -h options are additive.
.bp
.ti -5
-i	Incremental.  This flag, when used without the "u" option (see below),
copies the files that have been changed since the last incremental dump WITHOUT
updating the dump tabfunctions that may not be needed.
All of these pecadillos are forgiven by the use of appropriate C
compiler options.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
.bd
Ptc
returns success if it produces no diagnostics.
.sp 2
.in -5
.bd
SEE ALSO
.in +5
.br
cc (1), as (1), cp1 (1), cp2 (1), cpp (1)


NOTE: This program and documentation are products of Whitesmiths, Ltd.,
ymbols
are listed, sorted in alphabetical order on symbol name.  If more
than one of the flags -[d s t y] is selected, then type information
is output .rm 79
.he "          td (1)                         4/6/83                          td (1)
.fo "                                           -#-"
.in 10
.bd     
NAME
.in +5
.br
.bd
td 
- tree dump (file backup)
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
td  [-a] [-dN] [-hN] [-i] [-u] 
.sp 2
.in -5
.bd
DESCRIPTION   
.in +5
.br
.bd
Td 
is your primary tool for routine backing up of files.  You can select 
the whole file system (not the normal procedure) or certain parts of it.
You can also do
.bd
incremental
dumps, le.  Therefore you could perform another incremental dump 
later and even if the files remain unchanged in the meantime, they'll still be
included in the dump.
.sp
NOTE: If you want this incremental-without-update to take effect, respond
.bd
F
(for full) at the interactive "full or incremental" prompt.
.sp 
.ti -5
-u	Update.  Update the central dump table at the conclusion 
of a successful dump.  Be aware that using
.bd
-iu
has the same effect as using neither option, and responding
.bd
I  
(for incremental) at the "full or incremental" prompt.
.sp 2
.in -5
.bd
Interactive Options
.in +5
.sp 2
.ti -5
Source Directory:  Respond the pathname of the directory
you want the dump to start at.  The dump will follow downward through
all of the subdirectories until all appropriate files have been copied.

.ti -5
Destination Device:  Enter the pathname (/dev/...) of the floppy or hard disk 
to which you are dumping.  For example, enter
.bd
/dev/fla
for an 8" floppy.

.ti -5
"Do you want a full or an incremental dump (Fwhich means copy only those files that have been changed since the last
.bd
td.  Incremental dumps are standard procedure in proper system management.
Micronix maintains a "dump table" that keeps track of what was dumped when.
.sp
Files dumped with 
.bd
td
are usually placed on floppy diskettes, 
but you can dump to hard disks just as well.
.sp
It doesn't matter if your dump won't all fit on one diskette;
.bd
td 
allows you to change diskettes on the fly.
Each disk is filled to capacity, then the program asks
for operator service.
In this sense it does need a bit of babysitting.
.sp 
Before beginning a major dump,
you should have a stack of formatted
diskettes (see program
.bd
fdj
).
These diskettes must be pre-formatted
but they need not contain file systems.
.bd
Td 
will notice that a diskette has no file system
and ask you if it should make one.
It will then call the 
.bd
mkfs 
program for you.

Unlike some other back-up systems, this program's back-ups are in 
file system
form, meaning it is easy to look /I)?"  Respond accordingly and
press RETURN.
If the directory you specified as the Source above isn't in the dump table
(having never been dumped previously), td defaults to a full dump.

.ti -5
"Insert new media and press RETURN to continue or type the name of a new
device."  Insert a formatted diskette into the drive
you designated as the Destination Device.  You can use diskettes that
already have some files on them, assuming they are in Micronix format.

Note that if you are dumping a file that has the same pathname as one on the
diskette, the dumped one replaces the existing one.  You can use this fact
to your advantage if you employ one diskette over and over as the recipient
of regular incremental dumps.  It will then always contain the latest'n'greatest
versions of the files in the source directory.  The danger inherent in this
approach is that if anything damages that diskette, you won't have 
yesterday's or the day before's to restore from.
.bp
The "type the name of a new device" option allows you t.in 10
.rm 79
.he "          tee (1)                        4/6/83                         tee (1)
.fo "                                           -#-"
.bd       
NAME
.in +5
.br
.bd
tee 
- a pipe fitting
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
tee [-a] [-i] [file ... ]
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
Tee 
reads the standard input and writes it unchanged to the
standard output, making copies in each of the named files.

Options
.sp
.in +5
.ta 5
.ti -5
.bd
-a	Append.  
Data is appended to the end of each named file, rather than being 
over-written.
.sp
.ti -5
.bd
-i	Ignore.	 
Interrupt signals are ignored.
.sp 2
.in
.in 5
.bd
EXAMPLE
.sp
.in +5
.ti +10
.bd
edit | tee record

will keep a record of the editor's responses to commands.
 dumped with 
.bd
td
are usually placed on floppy diskettes, 
but you can dump to hard disks just as well.
.sp
It doesn't matter if your dump won't all fit on one diskette;
.bd
td 
allows you to change diskettes on the fly.
Each disk is filled to capacity, then the program aso switch destination 
devices without getting out of the td program.  Thus you could fill up
a floppy on /dev/fla and then move on to /dev/flb without getting up to
swap diskettes.
.sp2
.in -5
.bd
EXAMPLES
.in +5
.sp
The normal case: incremental backup with update of dump table.
Dumping directory
.bd
/a/jane
to 5 1/4" floppy drive A - 
.br
.sp
.nf
.bd 4
             td
             Source directory: /a/jane
             Destination device: /dev/mfa
             ...full or incremental (F/I)? I
.fi
.sp
Incremental backup of
.bd
/b/joe/ws
WITHOUT update of dump table
on 8" floppy drive A - 
.br
.sp
.nf
.bd 4
             td -i 
             Source directory: /b/joe/ws
             Destination device: /dev/fla
             ...full or incremental (F/I)? F
.fi
.sp
Backup of all the files created or modified within the past 8 hours
on hard disk m16b - 
.br
.sp
.nf
.bd 4
             td -h8
             Source directory: /
             Destination device: /dev/m16b
             ...full or incremental (F/I)? F
.sp 2
..in 10
.rm 79
.he "          umount (1)                     4/6/83                      umount (1)
.fo "                                           -#-"
.bd           
NAME
.in +5
.br
.bd
umount 
- dismount a file system
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
umount special
.sp 2
.in -5
.bd
DESCRIPTION   
.in +5
.br
The named special file is dismounted.

The special file must have been previously mounted
with the 
.bd
mount 
command.

It is not permitted to dismount a file system with files still open.
Diagnostic: "Device busy".

Sometimes it is necessary to use the "change directory" command 
before dismounting a device. As an example:
.sp
.ti +5
.bd
cd /; umount /dev/dja 
.sp 2
.in -5
.bd
EXAMPLE
.in +5
.ti +5
.bd
umount /dev/dja

to dismount a floppy.
.sp 2
.in -5
.bd
SEE ALSO
.in +5
.br
mount(1) - to mount file systems








ks just as well.
.sp
It doesn't matter if your dump won't all fit on one diskette;
.bd
td 
allows you to change diskettes on the fly.
Each disk is filled to capacity, then the program asfi 
.in -5
.bd
TO EXAMINE THE CONTENTS of a 5 1/4" backup diskette:
Insert the diskette into the drive, and type
.br
.sp
.nf
.bd 3 
             mount /dev/mfa /f
             cd /f
             dir
             (more cd's and dir's, if desired)
.bd 2
             cd /
             umount /dev/mfa
.bp
.fi
.bd 
TO RESTORE A SINGLE FILE (e.g. /usr/bin/adventure) from an 8" backup diskette:
Insert the diskette, and type
.br
.sp
.nf
.bd 3
             mount /dev/fla /f
             cp /f/usr/bin/adventure /usr/bin/adventure
             umount /dev/fla
.sp2
.fi
.bd
TO RESTORE AN ENTIRE DIRECTORY (say b/bill) from a 5 1/4" backup diskette:
Insert the diskette, and type
.br
.sp
.nf
.bd 3
             mount /dev/mfa /f 
             cptree /f/b/bill /b/bill
             umount /dev/fla
 

.sp 2
.in -5
.bd
FILES
.in +5
.br
/etc/dtab - the central dump table
.sp 2
.in -5
.bd
SEE ALSO
.in +5
.br
cp (1), cptree (1), fdj (1), mount (1), ncheck (1), mkfs (1)

me padded with trailing NULLs.  Meaningful flag values are o fo.in 10
.rm 79
.he "          du (1)                         4/6/83                          du (1)
.fo "                                           -#-"
.bd
NAME   
.in +5
.br
.bd
du 
- occupied disk space, in blocks (512 bytes per block)
.sp 2
.in -5
.bd
SYNTAX
.br
.in +5
du [-a] [-s] [name ...]
.sp 2
.in -5
.bd
DESCRIPTION
.in +5 
.br
.bd
Du 
is a very useful memory management tool that reports how much disk space
is currently being held by the various files in the system.  The flags
determine the level of detail given in the reports.  (
.bd
-a = all files; -s = grand total; neither = directories
)
Du
is complementary to the
.bd
df
function, which reports free disk space available per device.

There are several combinations of flags (a, s, or neither) and arguments (file
or directory names), each of which produces a slightly different breadth of
coverage and level of detail.  The examples in the following section address the
practical uses of 
.bd
du.

First, if you specify a particular filename, the file mu.in 10
.rm 79
.he "          file (1)                       4/6/83                        file (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
file
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
file file1 ...
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
File 
attempts to guess the type of each named file.
Currently, the following types of files are recognized:

.in +5
A-natural source file

Block special file

C source file

CP/M text file

Character special file

Data

Directory

Empty

Executable

Pascal source file

Ratfor source file

Relocatable module

Software Tools archive

Text file

Text processor input

Whitesmiths library

.in -5


 disk space available per device.

There are several combinations of flags (a, s, or neither) and arguments (file
or directory names), each of which produces a slightly different breadth of
coverage and level of detail.  The examples in the following section address the
practical uses of 
.bd
du.

First, if you specify a particular filename, the file must be in your current 
directory and you have to use one or the other flag (it makes no difference which  
one you choose in this case).  Obviously, du will report only the size of this
one file, in the format
.br
.sp
.bd
        #####   filename

Next, if you specify a directory name, it too must be contained in the current
directory, or else you can give the path leading to it from the root directory
(e.g. du -a /usr/bin).  Du will begin at this directory and proceed down the
tree through all the files and subdirectories contained within it.

If you don't give a file name or a directory, du assumes that you mean the current
directory.
.sp 
Options:

.ta 5
.in +5
.ti -5
-a	All.  This flag gives you the most detail, with a block count for each file.
There will also be subtotals for directories embedded in the list, so don't
be surprised if the bottom line doesn't look like the sum of all the numbers
above it.

.ti -5
-s	Summary.  Only a grand total is displayed.

.ti-5
Using neither flag produces an intermedi.in 10
.rm 79
.he "          chmod (1)                      4/6/83                       chmod (1)
.fo "                                           -#-"
.bd                            
NAME
.in +5
.br
.bd
chmod 
- change mode of files (accessibility for reading, writing, & execution; set
user/group number bit; set write lock bit)
.sp 2
.in -5
.bd
SYNTAX   
.in +5
.br
chmod mode file(s) 
.sp 2
.in -5
.bd
BRIEF DESCRIPTION
.in +5
.br
chmod performs three general functions as noted above: (A) setting up access 
restrictions to files, (B) setting/resetting the user and group number bits,
which is typically used to get around access restrictions under special 
circumstances, and (C) setting/resetting the write lock bit, which prevents two
processes from writing to the file simultaneously.
The format
of access mode commands is:
.nf
.bd
.sp
	chmod [u g o a] [= - +] [r w x] filename(s)
.fi
.sp
The format of user/group bit commands is:
.sp
.nf 
.bd
	chmod [u g] [+ -] s filename(s)
.fi
.sp
Finally, the format of write late level of detail, where only
directory subtotals and a grand total are displayed.
.sp 2
.in
.in 5
.bd
EXAMPLES
.in +5
.br
To find out just how much space your whole system is using,
simply enter:
.sp
.ti +5
.bd
du -s /

To find out which directory has that enormous file in it:
.sp
.ti +5
.bd
du /
(to begin at the root directory, in this case)

To get the name of the offending file itself:
.sp
.ti +5
.bd
du -a directoryname

To get an overview of the top layer of directories in the file system:
.sp
.ti +5
.bd
du -s /*
.sp 2
.in -5
.bd
NOTES
.br
.in +5
If there are several links to the same file, the space used by that file is
counted only once.  Space used by directories themselves and by pointer blocks
is not counted, as these are considered overhead and in any event do not amount
to more than a few percent.  Du doesn't give special consideration to files
with large vacant areas within them; the empty space is counted as if it were filled.
.sp2
.in -5
.bd
SEE ALSO
.br
.in +5
df (1),
ls (1)


or incrementalock commands is
.sp 
.nf
.bd
        chmod [+ -] l filename(s)
.fi
.sp
You should also refer to the entry on the ls program in this section of the
manual, as it closely relates to the following explanation.  Use the "-l" flag
with the ls program to monitor the effects of chmod operations.
.sp 3
.bd
.ti -5
EXPLANATION A.  File Access
.sp
Read, write, and execute access are controlled through the "mode" argument, 
which may be an octal number (e.g. 677) or a combination of symbols as described
below.  Before proceeding, you should have a basic understanding of the Micronix file
protection system.

The file protection system allows or denies access to files according to
two criteria, namely, WHO wants to get into the file and HOW he wants to 
use it.  There are three categories of users and three types of access, so there
are nine bits altogether which define the accessibility of the file.  WHO is
represented in chmod commands by these symbols:
.br
.sp
.in +9
.ti -4
a - for "all", in other words, the restrictionally revoked.

Multiple chmod operations for the same file may be strung together in one
command, using commas but no spaces.  Say you have a new (unrestricted) file
that you want to set up so that you have full priveleges, the group has read
only priveleges, and others cannot access it at all.  This could be your
command:
.br
.bd
chmod g=r,o-rwx filename
.sp 3
.in -5
.bd
EXPLANATION B.  Set User/Group Number Bit(s)
.in +5
.sp
As noted above, when you try to open a file (either directly or through a program 
you are executing) your user and group numbers are checked to see whether
access is permitted.  Now, suppose you execute a program owned by someone else,
but to which you have been granted execute priveleges.  However, within that program
is a command to read a file to which only the programmer has access.  You will
not be granted access, and a "permission denied" message is passed back to your unhappy 
process.

The chmod function being described here can often overcome this sort of problem
by replacing s that you 
specify will apply to everyone in the system.  As you will see, "a" is not one
of the user categories mentioned above, but rather the sum of all three.
.sp   
.ti -4
u - for "user", in effect the owner or creator of the file.
The owner of a file may be changed by way of the "owner"
program.  Note that only the superuser (login "root") may use
the "owner" program.
.sp
.ti -4
g - for "group", which comprises users with the same group
code as the owner.  (See "group" in the Files section
of this manual). 
.sp     
.ti -4
o - for "others", who is anyone else in the system not covered 
by u and g.  
.sp
.in -9
Now, as to HOW these various parties may wish to use the file in question,
there are these three categories:
.sp
.in +9
.sp    
.ti -4
r - to read the file;
.sp 
.ti -4
w - to write to the file;
.sp
.ti -4
x - to execute the file, in the case of a program or control string; or search,
in the case of a directory.
.sp
.in -9
There is a final set of symbols to consider, the operands +, -, and =.
"+"your user and/or group number with the numbers of the owner of the
program.  See the example that follows for further information.
.sp 2
.in -5
.bd
EXAMPLE B.  Set User/Group Number Bit(s) 
.in +5

Programmer Mary has written a program EXTRACT that reads year-to-date information
from her company's payroll file (PAYROLL).  It is decided that each system user 
should be allowed to look at his own payroll record.  So Mary modifies the
program accordingly, and enters
.bd
chmod go+x EXTRACT 
to open up the previously
restricted execute privelege to other users.

However, when John tries to run the program, all he gets is the message
"PAYROLL: Permission denied."  What has happened is that user John has tried
to open the payroll file, which Mary owns and to which he has no access priveleges.
The solution in this situation is to invoke chmod so that when EXTRACT goes
to read PAYROLL, PAYROLL will think EXTRACT's owner (Mary) is running the
program, regardless of who is actually running it.

The command in this case  will add a privelege that had earlier been restricted.  "-" accomplishes
the reverse.  "=" enables only those HOW's listed after it, and disables
those not listed.  The general form that chmod expressions take is:
.sp
.bd       
	chmod WHO operand HOW filename(s)

When performing chmod, keep in mind that files are created without restrictions
of any sort.
.sp
.in -5
.bd
EXAMPLES A.  File Access
.sp
.in +5
To set up a new file so that only the owner has access (of all 3 types):
.br
.bd 
chmod go-rwx filename

To restore full priveleges to everyone in the system for a file that had 
previously been restricted:
.br
.bd
chmod a+rwx filename

To understand the difference between the + and = operands, consider the
following.  If the group now has read and execute priveleges only, and you
want to give them write ability as well:
.br
.bd
chmod g+w filename
will work, as will
.br
.bd
chmod g=rwx filename.
However, if you had entered 
.bd
chmod g=w filename, 
the read and execute priveleges would have been unintention(which must be entered by Mary) is:
.br
.bd
chmod u+s EXTRACT

The letter u means that Mary's user number will be attached to any file openings
requested by EXTRACT.  If the file PAYROLL was owned by someone other than Mary
but to which she had group priveleges, the letter g would be used in place of or
in addition to the u in the command above.

To reset the user/group number flags, repeat the command you used to set them, but
with a minus sign in place of the plus sign.
.sp 2
.in -5
.bd
EXPLANATION C. Set Write Lock Bit
.sp
.in +5
This function is quite simple and straightforward.  Without the write lock bit
set, Micronix allows anyone with write access to a file to update it whenever
they please.  However, some files can become corrupted if write accesses become
interleaved.  As an example, a data base system written for a single user (such 
as Personal Pearl) should have its critical data files write-locked.  This is
accomplished by setting the write lock bit.  Enter:
.br
.sp
.bd
	chmod +l database

This th your terminal as the standard input.
Alternatively, you can broadcast the contents of a particular file
by entering

.bd
	wall < filename

Its normal use is to inform users of immediate system status.
.ul2
Only the super-user may use 
.bd
wall.
.sp 2
.in -5
.bd
EXAMPLE
.in +5
.bd3
	wall
	System going down in 3 minutes -- Please prepare 
	^D

After which, each user would see:

.ti +10
.bd
Broadcast message ...

followed by what appears above.
.sp2
.bd
.ti-5
SEE ALSO
.br
su (1) for entering superuser mode.
ck commands is
.sp 
.nf
.bd
        chmod [+ -] l filename(s)
.fi
.sp
You should also refer to the entry on the ls program in this section of the
manual, as it closely relates to the following explanation.  Use the "-l" flag
with the ls program to monitor the effects of chmod operations.
.sp 3
.bd
.ti -5
EXPLANATION A.  File Access
.sp
Read, write, and execute access are controlled through the "mode" argument, 
which may be an octal number (e.g. 677) or a combination of symbols as described
below.  Before sets the lock flag on the database. (Since the lock
flag applies equally to user, group, and others, the
WHO part of the operand may be left out here.)
Using a minus sign in place of the plus in the above command will reset the bit,
thus removing the lock.
.sp3
.in -5
.bd
SEE ALSO
.in +5
group(5) ls(1) owner(1)
r with read-only text section:
.sp
.ti +5
.bd
% link -1c.11 -rt -dr13 /lib/Crts.o echo.o; taout
.bp
And to load the 8080 version of echo under CP/M:
.sp
.nf
.bd
A:link -hrt -tb0x0100 a:chdr.o echo.o .in 10
.rm 79
.he "          tty (1)                        4/6/83                         tty (1)
.fo "                                           -#-"
.bd                                    
NAME
.in +5
.br
.bd
tty
- get terminal name
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
tty
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
Tty 
is a simple program that attempts to look
up the full path name and number of the current "tty" device 
(teletypewriter or terminal).
Normally, this is the name of the Micronix (terminal) .in 10
.rm 79
.he "          cu (1)                         4/6/83                          cu (1)
.fo "                                           -#-"
.bd           
NAME
.in +5
.bd
cu 
- call up
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
cu device [-s speed]
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
Cu 
may be used to connect to other machines through your
Micronix machine.

When the 
.bd
cu 
command is given, 
one process is set up to handle sending characters to the remote
system,
one is set up to receive them.
Much of this is not obvious to the user.

When 
.bd
cu 
is ready it prints a "~".
Thereafter, whatever you type will be immediately sent
to the remote port, and whatever is received from it is
sent to your terminal.
So, typically, you press a single key on your terminal,
Micronix takes it and re-transmits it to the remote machine,
which will usually send it back, at which point
Micronix receives it and sends it to your terminal
and you see the character on your screen!

There is definitely an upper limitport you
logged in on.

To ascertain your device number, enter the 
.bd
tty
command.
A typical response is
.sp
.ti +5
/dev/ttyB
.sp
meaning that you are on "ttyB".

If no associated file name can be found, the message "not a tty"
is printed instead.
.sp 2
.in -5
.bd
FILES
.in +5
.br
/dev - Directory in which to search for file names.
mod [u g o a] [= - +] [r w x] filename(s)
.fi
.sp
The format of user/group bit commands is:
.sp
.nf 
.bd
	chmod [u g] [+ -] s filename(s)
.fi
.sp
Finally, the format of write l.in 10
.rm 79
.he "          wall (1)                       4/6/83                        wall (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
wall 
- write to all users
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
wall
.sp 2
.in -5
.bd
DESCRIPTION
.br
.in +5
.bd
Wall 
reads the standard input up to an end of file,
then sends this to the terminal of each currently logged in user.
You can enter

.bd4
	wall [return]
	message...
	more message...
	^D [control-D]

to broadcast a message wi to the baud rate
you can use for the remote port -
1200 baud is the highest recommended.
If the remote machine is another Micronix machine,
additional commands apply.
You may copy a file from local to remote machine via:
.sp
.nf
.bd
	~%put file
.sp
.fi
Or from remote to local via:
.sp
.nf
.bd
	~%take file
.sp
.fi
Note only text files may be copied reliably.
This need not be a drawback, however, because
any file can be converted into a text file, transferred,
and then converted back again.

Both the sending and receiving processes recognize
.sp
.nf
.bd
	~>file

	~>
.sp
.fi
as starting and ending delimiters for file diversion,
so that in order to copy a file from a foreign system
to the local one, all you have to do is get the foreign system
to generate:
.sp
.nf
.bd
	~>filename
	Text of file ...
	more file ...
	~>
.sp
.fi
That is, a beginning marker, the text of the file, and then an ending
marker.

To get out of 
.bd
cu 
type:
.sp
.nf
.bd
	~.
.fi
.sp 2
.in -5
.bd
EXAMPLE
.in +5
.br
To set up communication ove.in 15
.rm 79
.he "          pilot (1)                      4/6/83                       pilot (1)
.fo "                                           -#-"
.bd
.ti -5
.bd
NAME
.br
.bd
pilot
- an author language
.sp 2
.ti -5
.bd
DESCRIPTION
.br
This program gets its name from and is loosely based upon
that set of programs written for the CP/M system under the generic name
PILOT, itself based upon some complex IBM software.

The present incarnation has adopted many of the ideas,
but is not totally faithful to the original PILOT standard.

Pilot is an author language in the sense that it should
be possible for "authors," i.e. non-programmers, to
successfully and fairly rapidly get something working in the pilot 
language.

Pilot is a non-structured language,
but structured language enthusiasts may be assured that
"rp" (a rational pilot) is available as a preprocessor.
(See rp (1)).

In order to run something in pilot, one issues the command:
.sp
.bd
.ti +10
pilot filename
.sp
where the given filename refers to a "pir a modem, get your hardware set up
and then type:
.sp
.ti +8
.bd
cu /dev/ttyC -s 300

In this example the modem would be plugged into Micronix
port C (the third one).

Typically, one must reverse the transmit and receive lines
in the cable running from the computer to the modem.
One reverses the wires running to pins 2 and 3 of the connector
at one end or the other.
rogram.
.sp
.ti -4
g - for "group", which comprises users with the same group
code as the owner.  (See "group" in the Files section
of this ma.in 10
.rm 79
.he "          su (1)                         4/6/83                          su (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
su 
- set user identification
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
su [name]
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
Su 
allows you to change your effective user ID in 
midstream, so to speak.

The most common use of this program is to temporarily
become a super-user
in order to install a program,
change a system-wide file,
kill offlot script".
Pilot will simply read the script and do whatever is requested.

To write a "pilot script" one needs only a way to get text
into a file.
Most text editors will suffice.


.bd
.ce
Pilot Operation

In general, pilot reads its input file, one line at a time,
performing the described actions before proceeding.
The general layout of a pilot command is:

.ti +5
.bd
*label command conditional : word1 word2 word3 ...

.bd
*label 
is a tag by which one may refer to this line elsewhere in the script.
It is optional, and in practice, most commands will not have labels.
A label may appear on a line by itself.

.bd
command
is a single letter command, discussed in detail
below.
.bp
.bd
conditional
is either the letter Y or N.
A conditional specifier is optional.
If one appears, the command will only do something
if the Y or N matches the current state of pilot's condition flag.

.bd
words 
are optional and specific to individual commands.


.bd
.ce
Instruction Summary

.nf
.in +20
A - accept
C - call
D - defin an errant process
or other administrative task.

If no name is given, "root" is the default.  This puts you in super-user mode.
If "root" has a password, non super-users will receive a password prompt.

Another use for
.bd
su
is to grab
someone else's terminal without the delays of logging them out,
logging yourself in, and so on.  Any time enter su with a password-protected
name, you will receive a password prompt.
.sp
.in -5
.bd
EXAMPLE
.in +5
.br
su - to enter super-user mode.  

.ti-5
NOTE: Since the super-user has powers that are beyond the reach of normal users,
"root" should definitely be password-protected.  Use super-user with
caution and only when necessary.  System defenses that prevent you from
making catastrophic mistakes are suppressed in super-user mode.

.in -5
.bd
SEE ALSO
.br
.in +5
passwd (1)
.fi
Note only text files may be copied reliably.
This need not be a drawback, however, because
any file can be converted into a text file, transferred,
and then converted back again.

Both the sendinge
E - exit
J - jump 
M - match
N - new file
R - return
S - save
T - type
U - unix
W - wait
.fi
.in -20
.sp 2
.bd
.ce
Instruction Descriptions

.ti -5
.bd
A - accept - a: [variable]
.br
One line of input is accepted from the standard input.
If a variable name is given,
a copy of the accepted data will be stored in the variable.
.sp
Examples
.in +10
.nf
a:
a: $save
.sp 2
.fi
.in -10
.ti -5
.bd
C - call - c: *label
.br
Jump to the given label, but remember where you were.
If a return instruction (r:)
is encountered in the program flow after
the label, pilot will jump
back
to the instruction following
the call.
.sp
Example
.in +10
.nf
c: *output
e:
*output
t: Hello world!
r:

1) Call instruction jump down to "*output".

2) Type instruction - type "Hello world!"
.bp
3) Return - go back to just after the last call

4) exit - all done!
.fi
.in -10
.sp 2
.ti -5
.bd
D - define - d: $move data
.br
The string "data"
is evaluated if necessary and then
a copy of the resulting string
of characters is stored in the 
string -5
.bd
N - new file - n: filename
.br
Fairly straightforward:
Pilot has been marching along executing instructions
in its pilot script file.
When it encounters the line
.sp
.nf
.bd
	n: newfile
.sp
.fi
pilot will have done with the current file and start executing instructions
with the first line in the file
named "newfile".
(There must, of course exist such a file, and it must be readable.)
Pilot stops if it can't read the given file.
.sp 2
.ti -5
.bd
R - return - r:
.br
Discussed in C - call (above).
A return instruction causes a jump to the line following the 
most recently executed call
instruction.
If there are no calls for which there have been no returns,
pilot stops.
It returns out of pilot to the calling program, as it were.
Anything to the right of the colon is ignored.
.sp
Example
.in +10
.nf
r:
.fi
.in -10
.sp 2
.ti -5
.bd
S - save - s: $variable
.br
The current value of the input
terminal input register
is saved in the string variable whose name is given.
If no name is given,
no action is taken.
.variable "name".
Note that "$" denotes string variables.
.sp
Example
.in +10
.nf
d: $x The cheese
t: $x

1) Definition $x is set to "The cheese"

2) Type - "The cheese" will be typed.
.sp 2
.fi
.in -10
.ti -5
.bd
E - exit - e:
.br
This is a simple instruction.
Pilot quits when it encounters
an exit instruction.
Anything to the right of the colon is ignored.
.sp
Example
.nf
.in +10
e:

Stop the whole works right now.
.in -10
.fi
.sp 2
.ti -5
.bd
J - jump - j: *label
.br
Go to some other part of the current
pilot
script file and
continue executing instructions
from that point on.
If no label name is given,
pilot prints "Missing label"
and stops.
If there is no such label to be found
in the current
pilot script file,
"name: Label not found" is printed and pilot stops.
.sp
Example
.in +10
.nf
*top
t:Hello
j:*top
.sp
.fi
.in -10
This would print "Hello"
over and over again forever.

A more useful example:
.sp
.in +10
.nf
a:
m:yes
jn: *default
t: you typed yes
e:
* default
t: you didn't type yes
e:

1) Accept a linsp
Example
.in +10
.nf
s: $phial
.sp
.in -10
.fi
The most recently accepted input
is saved in "phial".
.sp 2
.ti -5
.bd
T - type - t: text
.br
A simple command, really.
That which follows the colon is simply sent verbatim
to the standard output, (usually the terminal).
If the last character of the line is a left slant (\),
then no "newline" character is sent at the end of the line.

Example
.nf
.in +10
t: A) First selection
t: B) Second selection
t:
t: Your choice ==>\
a:
.sp
.fi
.in -10
The four lines above are typed.


.ti -5
.bd
U - unix - u: command
.br
The command to the right of the colon
is executed just as if it had been
typed as a command to the shell.
This command gives you access to the rest of the system.
This instruction can take much longer than any of the others
just to get set up.
If the sub-process created by a U instruction is interrupted
or otherwise abnormally terminated, pilot will stop.
.bp
Example
.nf
.in +10
u: ls
u: cat $file | form | lpr &
u: pilot zzz
.in -10
.fi

Each command is exe from the controlling terminal

2) Match it against "Yes"

3) Jump to *default if the previous match failed.

4) type - "you typed yes" otherwise
.sp 2
.fi
.in -10
.ti -5
.bd
M - match - m: pattern,pattern,pattern, ...
.br
Compare the most recent input against the given list of patterns
and set pilot's condition flag based on the outcome.
The following instructions may base their behavior on the outcome
of these pattern comparisons.
Two results are possible:

1) The input matched one of the patterns (success).
.sp
2) The input matched none of them (failure).
.sp
Comparison of each pattern is by a marching window scan.
.sp
Case is ignored, that is, a capital Q is considered to be the same
as a lower case q.
.sp 
Example
.in +10
.nf
m:a
m:one,two,three
.fi
.in -10

The first will succeed whenever the most recent terminal input
contained the letter "a" anywhere.

The second will succeed if the most recent input contained
any of the three given character sequences which form the words
one, two, three.
.sp 2
.ti ecuted.
Note that it is possible for pilot
to continue before the command
finishes (ex. 2) or for there to
coexist several layers of pilot programs (ex. 3).


.ti -5
.bd
W - wait - w: [$variable] [number]
.br
Wait is just like "accept" above only it "times out"
after a certain period.
The default period is six seconds.
One can select a different period by placing a numeric value to
the right of the colon as one of the arguments.
If the specified time interval expires before
the RETURN key has been pressed, then the data returned
is the single word "TIMEOUT"
which can later be tested.

Example
.in +10
.nf
w:
w: $data
w: 9
w: $fast 2

1) Accept data for a six second period.

2) Accept data; wait for six seconds; store it in "data"

3) Accept data; wait for nine seconds.

4) Accept data; wait for two seconds; store it in "fast"
.sp 2
.fi
.in 
.in 10
.ti -5
SEE ALSO
.br
rp - rational pilot
rom the shell,
the command line must be in quotation marks or else
the shell will interpret the pipe incorrectly; i.e:
enterierwise the second statement is executed.
For example

.nf
	t: Give me your answer true.
	a:
	if (m: y)
		{
		t: Oh, Joy!
		t: ...
		}
	else if (m: n)
		t: Oh, Woe!
	else
		t: Eh?

.fi
An 
.bd
else 
goes with the last un-elsed 
.bd
if.
.sp
.in -5
.bd
while (condition) statement;
.sp
.in +5
The statement is executed repeatedly as long as the condition remains
true (possibly zero times as the condition is always tested before
the statement is executed.)
The condition may not be left out.
For an infinite loop, see
.bd
repeat
below.
.br
.sp
.in -5
.bd
for (statement; condition; statement) statement;
.sp
.in +5
First, the first statement is executed.
Then repeatedly the condition is tested, and if true,
the last statement is executed, then the second.
If the condition is false, the loop is broken and
control proceeds to the next statement following the 
.bd
for.
More clearly: the first statement is the initializer of the loop,
the second is the incrementation, and the last is the body of the loop.
.br
.sp
.in -5
.b.in 10
.rm 79
.he "          rp (1)                         4/6/83                          rp (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
rp
- rational pilot to pilot translator


.in -5
.bd
SYNTAX         
.br
.in +5
.bd
rp
<rational_pilot_file >pilot_file
.sp 2
.in -5
.bd
DESCRIPTION   
.in +5
.br
.fi
The 
.bd
rp 
preprocessor for pilot enables you to write programs in
the free-form structured language "rational pilot", then
automatically translate them into standard pilot
for interpretation by the "pilot" command.
This implementation incorporates
.bd
include
and
.bd
macro
capabilities.
.bd
Rp
reads from the standard input and writes to the standard
output.
.sp
Lines of the form:
.sp
.in +8
.bd
include file
.sp
.in -8
are replaced by the contents of the named file.
.bd
Includes 
may be nested.
.sp
Macro definitions such as:
.sp
.in +8
.bd
define(token, string)
.sp
.in +3
or
.sp
.in -3
.bd
define(token, ...$1...$2...$3...)
.br
.sp
.in -8
may appear.
The left parenthesis d
repeat
statement;
.sp
.in +5
The statement is executed repeatedly.
.br
.sp
.in -5
.bd
repeat
statement;
.bd
until
(condition);
.sp
.in +5
The statement is executed repeatedly until the condition is true.
The condition is always tested after the statement is executed, which
is to say, the statement will always be executed at least once.
.sp
.in -5
.bd
break;
.sp
.in +5
One level of 
.bd
while, 
.bd
for, 
or 
.bd
repeat, 
loop is broken out of.
.sp
.in -5
.bd
next;
.sp
.in +5
Transfers control to the looping mechanism of the innermost
.bd
while, 
.bd
for, 
or 
.bd
repeat, 
in which it occurs.
.sp 2
.in -5
.bd
ALSO READ
.br
.in +5
.fi
Kernighan, B.W. and P.J. Plauger,
.ul
Software Tools,
(Addison-Wesley, 1976).
le,
"name: Label not found" is printed and pilot stops.
.sp
Example
.in +10
.nf
*top
t:Hello
j:*top
.sp
.fi
.in -10
This would print "Hello"
over and over again forever.

A more useful example:
.sp
.in +10
.nf
a:
m:yes
jn: *default
t: you typed yes
e:
* default
t: you didn't type yes
e:

1) Accept a linmust follow the word define immediately.
In the first case, 
.bd
string 
is merely substituted for 
.bd
token
everywhere it appears.
In the second, occurrences of the form:
.sp
.ti +8
.bd
token(arga, argb, argc)
.sp
are replaced by the defining string, but with the values substituted for
the arguments.
The construction $n, where n is a decimal digit, signifies
the nth argument.  A given macro
may have at most nine arguments.
Macro definitions may be recursive.
.br
.sp
Any valid pilot statement is a valid 
.bd
rp 
statement.
A statement or group of statements may be enclosed in
curly brackets "{" and "}".
The result is treated as a single statement.
In addition to standard pilot, 
the following are understood:
.bp
.bd
if (condition) statement;
.sp
.in +5
The statement is executed if the condition is true.
The condition may be either a match query or a
define query (see pilot (I)).
.sp
.in  -5
.bd
if (condition) statement; else statement;
.sp
.in +5
If the condition is true, the first statement is executed,
oth.in 15
.rm 79
.he "          cal (1)                        4/6/83                         cal (1)
.fo "                                           -#-"
.ti -5
.bd
NAME
.br
.bd
cal
- print a calendar

.ti -5
.bd
SYNTAX
.br
.bd
cal [month] [year]

.ti  -5
.bd
DESCRIPTION
.br
The
.bd
cal
program is capable of printing full-year calendars
or single-month calendars for any year or any month
after year 0 (A.D).

.bd
Cal
with no arguments prints a full-year calendar for the current year.

.bd
Cal
with one numerical argument prints a calendar for that year.

Month names may be given a english names, abbreviations, or as numbers.
If a month name is given, a single-month calendar is printed.

If both arguments are numeric, the first is taken to be the month.

.ti -5
.bd
EXAMPLES
.br

.ti +5
.bd
cal 1932

Would print a full year calendar for the year 1932.

.ti +5
.bd
cal august 1955

To print a single month calendar for August, 1955.

.ti +5
.bd
cal

Would print this year's calendar.

.ti +5
.bd
cal november

For a sine eliminated entirely by placing the desired
bootstrap program on the "system tracks" of a floppy disk.
Then as long as that diskette is in drive A, Micronix will
boot automatically from the appropriate hard disk
every time the Decision's RESET button is hit. This
should save the operator about 5 seconds per day.
(CAUTION: if Micronix is already running, make
sure you type sync before hitting RESET.)

The loaders that can be placed on a floppy's system tracks
are stored as files on the Micronix CP/M diskette,
and are called hdload, m5load, m10load, and m16load,
corresponding to the similarly-named bootstrap programs.
See below for an installation example.
The djboot program has already been placed on the
system tracks of the Micronix stand-alone floppy,
so if you put this in drive A and hit RESET, it
will boot automatically.


.ti -6
.bd
EXAMPLES

.nf
				SCREEN
COMMENTS			DISPLAY


To boot the Micronix
  stand-alone floppy:

Make sure the diskette is
  write-enabled
Insert the diskette into
  drive A
Hit RESgle month calendar for November of this year.
e first case, 
.bd
string 
is merely substituted for 
.bd
token
everywhere it appears.
In the second, occurrences of the form:
.sp
.ti +8
.bd
token(arga, argb, argc)
.sp
are replaced by the defining string, but with the values substituted for
the arguments.
The construction $n, where n is a decimal digit, signifies
the nth argument.  A given macro
may have at most nine arguments.
Macro definitions may be recursive.
.br
.sp
Any valid pilot statement is a valid 
..in 16
.rm 79
.he "          boot (1)                       4/6/83                        boot (1)
.fo "                                          -#-"
.bd
.ti -6
NAME
.br
.bd
boot
- Micronix bootstrap procedures


.ti -6
.bd
SYNTAX
.br
djboot, hdboot, m5boot, m10boot, m16boot


.ti -6
.bd
DESCRIPTION
.br
The CP/M diskette that comes with Micronix includes the following
bootstrap programs:

.in +8
.ti -8
djboot	Boot from the DJDMA controller
with a 5 inch or an 8 inch drive.

.ti -8
hdboot	Boot from the HDCAET
Machine responds		FFFF
Machine types :, you type b	:b
Loader takes over		DJDMA loader ...


To boot Micronix from the m5:

Insert the Micronix CP/M
  diskette in drive A
Hit RESET
Machine responds		FFFF
Machine types :, you type b	:b
CP/M announces itself		Morrow Designs CP/M
Type m5boot			A> m5boot
Loader takes over		HDDMA loader ...


To prepare an auto-boot
  floppy for the m5:

Insert the Micronix CP/M
  diskette in drive A
Hit RESET
Machine responds		FFFF
Machine types :	 you type b	:b
CP/M announces itself		Morrow Designs CP/M
Type formatdj. Follow the	A> formatdj
  instructions to format a
  new diskette. 512 byte
  sectors are recommended.
Type sysgen m5load		A> sysgen m5load
Type an A			Destination drive? A
Insert the formatted		Insert a write
  diskette in drive A		 enabled diskette
  and hit RETURN.		 in drive A
The diskette is ready to use	Function complete...


To use the m5 auto-boot:

Insert the auto-boot
  diskette in drive A
Hit RESET
Machine responds		FFFF
Machine types :, you type b	:b
L controller
the 10, 20, or 26 megabyte drive

.ti -8
m5boot	Boot from the HDDMA controller
with the 5 megabyte drive

.ti -8
m10boot	Boot from the HDDMA controller
with the 10 megabyte drive

.ti -8
m16boot	Boot from the HDDMA controller
with the 16 megabyte drive
.in -8

These are CP/M programs, ie, they are stored on the CP/M
diskette as djboot.com, hdboot.com, etc, and are invoked
from CP/M by typing the name without the .com extension.

In each case, they assume that the target disk contains
a Micronix file system, and they search its root
directory for files that could be Micronix kernels.
If exactly one such file is found, it is loaded and
executed. If more than one kernel
is found, the names are listed and the operator is asked
choose one. This allows backup copies or alternate
versions to be kept.

CP/M's only role in this process is the invocation of
the bootstrap program. Once the bootstrap begins
executing, it is independent of CP/M, and CP/M itself
is overwritten as Micronix is loaded.

CP/M can boader takes over		HDDMA loader ...


.ti -6
.bd
BUGS

.fi
The bootstrap programs only search the first block
of the root directory, so you should limit your
root directory to 32 entries (which is a good idea
anyway, to speed up rooted file-name searches),
or else you should make sure that the Micronix
kernel occurs as one of the first 32 entries.
over and over again forever.

A more useful example:
.sp
.in +10
.nf
a:
m:yes
jn: *default
t: you typed yes
e:
* default
t: you didn't type yes
e:

1) Accept a lin.in 15
.rm 79
.he "          touch (1)                      4/6/83                       touch (1)
.fo "                                           -#-"
.bd
.ti -5
NAME
.br
touch - updtate the modification time for a file

.ti -5
.bd
SYNTAX
.br
touch file ...

.ti -5
.bd
DESCRIPTION
.br
Each of the named files has it's modification time
set to the current time.
This is done by reading a character from a file and
then writing it back.
No file's data is changed.

.ti -5
.bd
EXAMPLE
.br
touch file
from the HDCAtartup files.

.in -6

To post a message, just mail it to "msgs".
Messages are automatically removed after 2 weeks, unless
they are set to file mode 444, in which case they
will be permanent.
See chmod (1).


.bd
.ti -5
EXAMPLES
.br
To catch up on local events:

	msgs


To post a message:

	mail msgs

	There wil be a company party at 4 p.m. on April 6th.
	All are invited to attend.
	Guest speakers will include Horton Hornblower.

	.


To post a message from a file:

	mail msgs < file &


To view the complete list of message headings:

	msgs -h 1


To notify you if there are new messages,
add this line to your ".login" file in your home directory:

	msgs -fq

.bd
.ti -5
FILES
.br
/usr/spool/msgs
~/.msgs
	FFFF
Machine types :, you type b	:b
CP/M announces itself		Morrow Designs CP/M
Type m5boot			A> m5boot
Loader takes over		HDDMA loader ...


To prepare an auto-boot
  floppy for the m5:

Insert the Micronix CP/M
  diskette in drive A
Hit RESET
Machine responds		FFFF
Machine types :	 you type b	:b
CP/M announce.in 15
.rm 79
.he "          msgs (1)                       4/6/83                        msgs (1)
.fo "                                           -#-"
.bd
.ti -5
NAME
.br
.bd
msgs
- bulletin board and junk mail service


.ti -5
.bd
SYNTAX
.br
msgs -fhq [ [-] number ]


.ti -5
.bd
DESCRIPTION
.br
The msgs program provides a system wide bulletin board.
Any user may post messages on the board
and all users may view the messages on the board.
Using the msgs program is much like reading the classifed
section of a newspaper.

The last message read by each user is automatically remembered.
That is to say each user sees each message once
and the system holds your place.

When the command "msgs" is given
an interactive mode is entered.

You are shown the heading of the first message you haven't read yet.

You are advised of the number of lines remaining in the file.

You are asked if you'd like to see more.

This looks like:

	Message 23:
	From harold Mon 23 Aug 11:30:22
	New database program installed!!
	(17 more li.in 15
.rm 79
.he "         paste (1)                      4/6/83                        paste (1)
.fo "                                           -#-"
.ti -5
NAME
.br
.bd
paste
- print files side by side


.ti -5
SYNTAX
.br
.bd
paste [-t separator] file1 file2 ...


.ti -5
DESCRIPTION
.br
.bd
Paste
reads a line from each file in the order given
and pastes the lines together into single line,
which is written to the standard output.
A tab separator is used unless another character is specified.
A file name of - refers to the standard input.
No attempt is made to line up the columns vertically.

There is no limit on the input line length.


.ti -5
EXAMPLES
.br
Suppose that file1 contains
.nf
.in +5
Sally
Samantha
Holly
Agatha
.in -5
and file2 contains
.in +5
Mike
Mordred
Garth
.in -5
.fi

.bd
paste -t+ file1 file2

would result in the following output
.nf
.in +5
Sally+Mike
Samantha+Mordred
Holly+Garth
Agatha
.in -5
.fi


.nf
.bd
ls | paste - - -

.fi
would give a two-column listing of the current directory
(alnes) More? (Y/N/Q)


Possible responses:

.in +6
.ti -6
y	Yes, I'd like to see the rest of this message.

.ti -6
n	No, I'm not interested in this message, skip me
to the next message.

.ti -6
q	Quit.  Get out of the program right now.

.ti -6
(number) 
.br
Jump to the message whose number is given, or the next
highest numbered message.
	
.ti -6
-	Back up one message for a replay.



.ti -6
s filename
.br
Append this message to the end of the named file.
Create the file if it doesn't already exist.
If a minus (-) follows the 's', the previous
message will be saved.

.in -6

If you press the <RUB-OUT> or <DELETE> key
in the middle of the printing of a long message,
the remaining portion of the message will be skipped.


Command line flags:

.in +6
.ti -6
-f	Causes msgs not to say "No new messages".

.ti -6
-h	Headings only.
The heading of a message is arbitrarily the first two
non blank lines.

.ti -6
-q	Queries whether there are messages.
Prints "There are new messages" if there are.
This option is useful in sphabetized from left to right, not top to bottom).


.ti -5
BUGS AND CAVEATS
.br
No attempt is made to align the columns vertically,
except to put tabs between the columns.


.ti -5
SEE ALSO
.br
field (1)
out of the program right now.

.ti -6
(number) 
.br
Jump to the message whose number is given, or the next
highest numbered message.
	
.ti -6
-	Back up one message for a replay.



.ti -6
s filename
.br
Append this message to the end of the named file.
Create the file if it doesn't already exist.
If a minu.he "kill (1)                     3/18/82                     kill (1)"  
.fo "                               -#-"
.in 5
.rm 65
.bd
PROGRAM
.br
.in +5
.bd
kill
- send a signal to a process


.in -5
.bd
C          
.br
.in +5
.bd
kill [-sig] processid ...


.in -5
.bd
FUNCTION   
.br
.in +5
.bd
Kill 
sends the specified signal to each of the processes, given
by number (where
.bd
-sig
is the decimal signal number).
If no signal is specified, 
.bd
SIGKILL (signal number 9) is sent.


.in -5
.bd
ALSO READ
.br
. history:

.bd
	last

Print usage summary:

.bd
	last -s

Find out who has been using your tty:

.bd
	last ttyB

Find out how much time oscar has logged:

.bd
	last -s oscar

Probe the behaviour of a few selected users:

.bd
	last bill jean harold

Start record keeping afresh, discarding old records:

.bd
	type /dev/null > /usr/adm/wtmp

Disable record keeping and discard records:

.bd
	era /usr/adm/wtmp

Save old records and then start over:

.bd 2
	cp /usr/adm/wtmp /usr/adm/old
	type /dev/null > /usr/adm/wtmp

.ti -5
.bd
FILES
.br
/usr/adm/wtmp - the file containing the historical records.



ly removed after 2 weeks, unless
they are set to file mode 444, in which case they
will be permanent.
See chmod (1).


.bd
.ti -5
EXAMPLES
.br
To catch up on local events:

	msgs


To post a message:

	mail msgs

	There wil be a company party at 4 p.m. on April 6th.
	All are invited to attend.
	Guest speakers will include Horton Hornblower.

	.


To post a message from a file:

	mail msgs < file &


To view the completin +5
/include/signal.h
ard input.
No attempt is made to line up the columns vertically.

There is no limit on the input line length.


.ti -5
EXAMPLES
.br
Suppose that file1 contains
.nf
.in +5
Sally
Samantha
Holly
Agatha
.in -5
and file2 contains
.in +5
Mike
Mordred
Garth
.in -5
.fi

.bd
paste -t+ file1 file2

would result in the following output
.nf
.in +5
Sally+Mike
Samantha+Mordred
Holly+Garth
Agatha
.in -5
.fi


.nf
.bd
ls | paste - - -

.fi
would give a two-column listing of the current directory
(al.in 10
.rm 79
.he "          last (1)                       5/18/83                        last (1)
.fo "                                           -#-"
.bd 
NAME
.br
.in +5
.bd
last
- login accounting


.ti -5
.bd
SYNTAX       
.br
.bd
last [-s] [user ... ] [tty ... ]


.ti -5
.bd
DESCRIPTION   
.br
Last interprets the user login accounting file (/usr/adm/wtmp). It 
can be used to gain a perspective of the login
history of the system.

Last displays the starting and ending times
of each user session as wel.in 15
.rm 79
.he "          create (1)                     4/6/83                      create (1)
.fo "                                           -#-"
.bd
.ti -5
NAME
.br
.bd
create
- create a new file


.ti -5
.bd
SYNTAX       
.br
.bd
create file ...


.ti -5
.bd
DESCRIPTION 
.br
.bd
Create
simply creates empty files with the given names.
If a file with the same name already exists,
it is left unchanged. (Note that this is different
from the usual UNIX behavior, which is to believe
the user and destroy existing files when asked to do so.)
he display is given in reverse chronological order,
most recent first.

If the -s option is specified, only a summary is given.  The
summary shows total login time for users or ttys without
breaking it down into single sessions.

If a user name or list of user names is given,
then the display is restricted to only those users specified.

If a tty name or list of tty names is given,
then only login sessions on the specified ttys will be displayed.

If a mixed list is givenl as the duration of that session.
The display is given in reverse chronological order,
most recent first.

If the -s option is specified, only a summary is given.  The
summary shows total login time for users or ttys without
breaking it down into single sessions.

If a user name or list of user names is given,
then the display is restricted to only those users specified.

If a tty name or list of tty names is given,
then only login sessions on the specified ttys will be displayed.

If a mixed list is given then the display will include
sessions matching any of the criteria.

It's possible to enable or disable the historical record keeping
feature.
Record keeping is turned on or off based on the presence or
absence of the wtmp file (/usr/adm/wtmp).  See the examples below.

If a login session is abnormally terminated (say by a power failure),
last assumes that the session continued until the following boot
and reports it as ending at "boot" instead of at a specific time.


.ti -5
.bd
EXAMPLES
.br

Print login.in 10
.rm 79
.he "          dar (1)                        4/6/83                         dar (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
dar
- access MSDOS format floppy diskettes


.ti -5
.bd
SYNTAX          
.br
.bd
dar device [flags] [files]


.ti -5
.bd
DESCRIPTION
.br
.bd
Dar
provides a simple interface to MSDOS floppy diskettes.
It may be used for backing up files on diskettes, and recovering
them as necessary.
"Device" is
assumed to be
the name of a Micronix special file
(such as mfa)
corresponding to a floppy drive that contains a MSDOS diskette.
Note that mfa stands for mini floppy A.
.bd 
Dar
can copy files in either direction, and can also be used to read the directory
of a MSDOS floppy.  
When the -v flag is used, it reports the amount of space
still available on the diskette.

Names such as /dev/mfa may be abbreviated as mfa.  You can check the names of
the storage devices by entering 

.bd
        dir /dev (return)


Currently only single sided 5.25" IBM PCette into floppy drive A and
type:

.ce
.bd	
dar mfa -xv

To copy a file from a diskette, changing its name in the process:

.ce
.bd
dar mfa -p filename > newname


To copy only the ".doc" files over from a MSDOS mini-floppy:

.ce
.bd
dar mfa -xv "*.doc"


To copy a file from diskette into a file that is elsewhere than your
current directory: 

.ce
.bd
dar mfb -p "name" > /dir/...
(path from root to desired location; you could also specify a new name)


.in -5
The following discussion is intended primarily for users that are
having trouble getting 
.bd
dar
to do what they want it to.
.in -5

One aspect of dar command syntax somewhat complicates the issue of using it,
namely, the use of quotation marks.  An example should
help clear this up.  
Let's say your current Micronix directory contains two files,
.bd
a.com 
and
.bd
a.bak.
Your MSDOS floppy contains a file 
.bd
a.pil
that you wish to copy into your current directory.  Since this is the only file
on the floppy that begins with "a", you lazily enter 
.bd
 format diskettes are
recognized.

The flags are:

.ta 10
.in +10

.ti -10
.bd
-c	Create.  
Start a new dos diskette from scratch.
Remove all files, clean out the file allocation table.
This option must be used to copy fils to a freshly formatted diskette.
It may be used in conjunction with any of the other arguments,
and if so, it is performed first.

.ti -10
.bd
-d	Delete.  
Delete the named files from the floppy diskette.
If no file names are given, no action is taken.

.ti -10
.bd
-p	Print.
Each named file is sent to the standard output (most likely your terminal). 

.ti -10
.bd
-r	Replace.
Each named file is copied
.ul
to
the floppy.
If no file names are given, all the files in the current directory are copied.
If a file of the same name already exists on the floppy, it is
silently overwritten.

.ti -10
.bd
-t	Table.
Print a table of contents of the floppy diskette.
If any files are named, only those named and present are listed.
 
.ti -10
.bd
-x	Extract.
Each named file is copied 
.ul
from
the diskette
dar mfa -xv a*.
Next you are wondering what's wrong when you are faced with the message
"a.com not found on diskette / a.bak not found on diskette".  Of course
they weren't found.  
You didn't even want Micronix to be looking for them.

What has happened is this:  Your command interpreter (shell) thought you meant
to search the current directory for a match to the wildcard argument before 
going out to the floppy for the copy.  
It indeed found two matches
(a.com & a.bak), so Micronix went gleefully out to the floppy to copy them.
In vain, unfortunately.

The solution here is to use quotation marks around your filename(s).
Had you entered
.bd
dar mfa -xv "a*",
the shell would have left the command alone, and dar would have gone
directly out to the floppy to find anything that began with an "a".  
Success.

Now, just to set the record straight, there is a further complication that
may help you to understand how the shell operates.  Suppose the file on your
floppy is called 
.bd
b.pil
instead of
.bd
a.pil.
If y.ul
to
the current Micronix directory.
If no file names are given, 
.ul
the entire contents
of the diskette
is extracted.

.ti -10
.bd
-v	Verbose.
Be verbose about it.
Each operation is printed along with the affected file name.
Files deleted are preceded by a "d", 
those replaced are preceded by an "r",
those extracted are preceded by "x".
The percentage of the diskette that is occupied,
along with the number of bytes still available,
is reported when dar is finished.

.in -10
At most, one of the flags -
.bd
d, t, r, x 
- may be present.
If none are present, 
.bd
-t 
is assumed.
.bd
-v
may be used in combination with any of these as in "-xv".

The file list may contain wild card matching patterns
to be applied to the set of file names in the MSDOS
diskette's directory.  Refer to the section "Argument Expansion" in the
.bd
sh
program writeup in this manual.
.in -5
.sp2
.bd
EXAMPLES
.br
.in +5
You receive a MSDOS diskette and 
want to copy the files off.
To copy its entire contents to Micronix,
insert the diskou enter
.bd
dar mfa -xv b.* 
(no quotes), the file will in fact be copied, contrary to the previous discussion.
Furthermore, everything on the floppy diskette will be copied, much to your 
chagrin.  This is because your shell took b.* to your current Micronix directory,
looked to see if a file of that name was really there, and finding no such file,
it passed the command to Micronix as "
.bd
dar mfa -xv
".  As noted above in the description of the x flag, if there is no file specified,
the whole diskette gets copied.

In summary, you 
.ul
should
enclose the argument in quotes whenever you want to copy specific files from
the floppy to Micronix.  The only exception to this is a situation where you
have certain files already established on Micronix and you want to extract
only those floppy files that match the existing Micronix filenames.

.ti -5
SEE ALSO
.br
far - to access CP/M diskettes.


terminal input register
is saved in the string variable whose name is given.
If no name is given,
no action is taken.
..in 15
.rm 79
.he "          account (1)                    4/6/83                     account (1)
.fo "                                           -#-"
.bd
.ti -5
NAME
.br
.bd
account
- manage user accounts


.ti -5
.bd
SYNTAX       
.br
.bd
account


.ti -5
.bd
DESCRIPTION 
.br
.bd
Account is an interactive, menu-driven program for
listing, adding, deleting, and changing user accounts.
Changes can be made to the account name, password,
home directory, and shell.


.bd
.ti -5
SEE ALSO
.br
newuser (1), chsh (1), passwd (1), group (1), owner (1)
6 kinds of disks.

     5 inch:
	M5 
	M10	
	M16

     8 inch:
	M10	
	M20
	M26

The program only works properly on a freshly formatted 
or tested disk;
that is to say, the Micronix file system
is written over the the disk's bad sector map.
Invalid bad sector maps are flagged in error
and no list of block numbers is produced.
In particular, either a valid block
list or nothing is sent to the standard output,
so it is always meaningful to use 
the block list 
.bd
badspots .he "badspots (1)                 11/10/82                badspots (1)"
.fo "                                -#-"
.in 10
.rm 65
.bd
.ti -5
NAME
.br
.bd
badspots 
- bad sector report


.ti -5
.bd
SYNOPSIS
.br
badspots [-p] filesystem ...


.ti -5
.bd
DESCRIPTION
.br
.bd
Badspots
is a Micronix utility program which produces a display 
of bad blocks on a hard disk whose name is given.
The program knows how to read the bad map formats
of the two Morrow disk testing and formatting 
programs:

	FORMATMW

and

	FORMATHD


Badspots knows about exactly 6 kinds of disks.

     5 inch:
	M5 
	M10	
	M16

     8 inch:
	M10	
	M20
	M26

The program only works properly on a freshly formatted 
or tested disk;
that is to say, the Micronix file system
is written over the the disk's bad sector map.
Invalid bad sector maps are flagged in error
and no list of block numbers is produced.
In particular, either a valid block
list or nothing is sent to the standard output,
so it is always meaningful to use 
the block list 
.bd
badspots .in 15
.rm 79
.he "          tree (1)                       4/6/83                       tree (1)
.fo "                                           -#-"
.bd
.ti -5
NAME
.br
.bd
tree
- draw a picture of the file system


.ti -5
.bd
SYNTAX
.br
.bd
tree [starting_directory] [-a]


.ti -5
.bd
DESCRIPTION
.br
.bd
Tree
draws a picture of the file system tree structure
starting from the root directory.
Optionally, a different starting directory can
be specified.
Only directory names are listed, unless the -a option
is given, in which case all files are listed.

Directories on which the user does not have search permission
are shown as empty.

The picture is drawn on the standard output, so it normally
appears on your screen, but it can also be sent to a printer
(see below).


.bd
.ti -5
EXAMPLES
.br
To see the entire accessible file system:
        tree

To see Mary's directory hierarchy:
        tree /a/mary

To see all files in Mary's hierarchy and print the result:
        tree /a/mary -a | lpr


.bd
.ti -5
SEE ALS
produces.

If there are no bad sectors in the disk's bad sector
map, 
.bd
badspots 
produces no output.

.ti -3
.bd
The Default Display Mode:

By default each bad sector is displayed as
a Micronix block number.

The -p option causes the cylinder, head, and sector numbers
to be printed for each bad sector.


.ti -5
.bd
EXAMPLE

	fsck -b `badspots /dev/m16a` /dev/m16a

This is the way 
.bd
badspots 
is used in production at Morrow Designs.
The results of 
.bd
badspots are conveyed to 
.bd
fsck 
in this example.

To simply view a list of badspots:

	badspots hdb


The
.bd
badspots
program is clever enough to try adding "/dev/" to the filename used 
if it is unable to open the file named on the command line.
To see that same 
.bd
badspots
list expressed as cylinder, head, sector
triplets:

	badspots -p hdb


.ti -5
.bd
SEE ALSO
.in 10
fsck (1), hdca (4), hddma (4)
.br
ette.
If any files are named, only those named and present are listed.
 
.ti -10
.bd
-x	Extract.
Each named file is copied 
.ul
from
the diskette
O
.br
du (1), find (1)
e no bad sectors in the disk's bad sector
map, 
.bd
badspots 
produces no output.

.ti -3
.bd
The Default Display Mode:

By default each bad sector is displayed as
a Micronix block number.

The -p option causes the cylinder, head, and sector numbers
to be printed for each bad sector.


.ti -5
.bd
EXAMPLE

	fsck -b `badspots /dev/m16a` /dev/m16a

This is the way 
.bd
badspots 
is used in production at Morrow Designs.
The results of 
.bd
badspots are conveyed to 
.bd
fsck 
in this examp.in 15
.rm 79
.he "          recon (1)                      4/6/83                       recon (1)
.fo "                                           -#-"
.bd
.ti -5
NAME
.br
.bd
recon
- reconfigure Micronix terminals and printers


.ti -5
.bd
SYNTAX       
.br
.bd
recon [-t]


.ti -5
.bd
DESCRIPTION 
.br
.bd
Recon
is a menu-driven program that makes it easy to add
new login terminals and printers to Micronix.
In effect, it is a high-level editor for the
/etc/ttys file, a humanly-readable text file that specif)
.br
E) Morrow Micronix
.sp
.ti -10
8 inch formats
.br
F) CP/M standard single density (128 byte sectors)
.br
G) Morrow CP/M double density (1024 byte sectors)
.br
H) Morrow Micronix (512 byte sectors)
.sp
.ti -10
Do it yourself
.br
I) Other

.in -10
The first 
eight
menu selections automatically format diskettes without you having 
to  know  anything  except the correct drive  number.   The  last 
selection,  Do it yourself,  is for experts in diskette  formats.  
You must select every formatting variable controlled by the 
.bd
fdj
program.  Bad combinations of formatting variables won't work,
even though
.bd
fdj
won't complain.
.sp
The  difference between 5 1/4" North Star compatible 
and Micronix compatible is that Micronix uses all 40 tracks and
North Star  only uses 35 tracks.

Drives are numbered from 0-3 for both eight inch and 5 1/4".  If
you have only one drive, it is drive 0.  The second drive of 
either  type  is usually drive 1.   (The way drives are  selected 
depends on a setting within the driies
the I/O configuration to the system.
This file can be edited with recon or with any text editor.
When any change is made to /etc/ttys, the
.bd
update
daemon notices and sends
a reconfiguration signal to the
.bd
init
process, which impliments the changes.

If recon is run with the -t (test) argument,
it writes to the file /tmp/temp instead of
/etc/ttys, so that the potential changes can
be inspected.


.bd
.ti -5
SEE ALSO
.br
init (1), update (1), cables (4), ports (4), printers (4),
network (4), ttys (5)
.br
du (1), find (1)
e no bad sectors in the disk's bad sector
map, 
.bd
badspots 
produces no output.

.ti -3
.bd
The Default Display Mode:

By default each bad sector is displayed as
a Micronix block number.

The -p option causes the cylinder, head, and sector numbers
to be printed for each bad sector.


.ti -5
.bd
EXAMPLE

	fsck -b `badspots /dev/m16a` /dev/m16a

This is the way 
.bd
badspots 
is used in production at Morrow Designs.
The results of 
.bd
badspots are conveyed to 
.bd
fsck 
in this exampve.)

.bd
Fdj
may also be used non-interactively with the following options:

.in +10
.ta 10
.ti -10
-b         bytes per sector.       (128, 256, 512, 1024)

.ti -10
-i         inches.                 (5, 8)

.ti -10
-d         drive number.           (0, 1, 2, 3)

.ti -10
-s         sides.                  (1, 2)

.ti -10
-t         tracks.                 (35, 40, 77)
     


.in -10
These options may be combined to produce a variety of formats.  
However, absurd or impossible combinations will not work
correctly.  For example, if you use the 
.bd
-s2
(two sides) option with a single sided 8" diskette,
.bd
fdj
will only format one side and not say anything about it.

.in -5 
.bd
EXAMPLE
.in +5
.br
To format a 5 1/4" diskette for Micronix:
.sp
.ce
.bd
fdj -b512 -i5 -d0 -s2 -t40

This formats the diskette in drive 0 with 512 byte sectors,
on both sides with 40 tracks.  To format a single density 
"standard" IBM 3740 8" diskette, you would use
.sp
.ce
.bd
fdj -b128 -i8 -d0 

.br
Both of these examples are sel.he "fdj (1)                      9/13/83                      fdj (1)"   
.fo "                               -#-"
.in 5
.rm 65
.bd
PROGRAM
.in +5
.br
.bd
fdj 
- floppy diskette formatter for the DJ/DMA controller


.in -5 
.bd
USAGE        
.in +5
.br
.bd 2
fdj  [-bN] [-iN] [-dN] [-sN] [-tN]
.sp



.in -5 
.bd
FUNCTION   
.in +5
.br
.bd
Fdj 
formats write-enabled 5 1/4" and 8" floppy diskettes by providing 
special formatting programs to the DJ/DMA disk controller.  
.bd
Fdj 
has a menu of 
eight
standard  formats  when used interactively.   If invoked with  an 
arguments list,
.bd
fdj 
will work non-interactively and format diskettes according to the
options selected.

The
eight
standard formats in 
.bd
fdj's 
menu are
.sp
.in +10
.ti -10
5 inch soft sectored formats
.br
A) Morrow single sided (Micro Decision compatible)
.br
B) Morrow double sided (also Micro Decision compatible)
.sp
.ti -10
5 inch hard sectored formats
.br
C) Single sided (North Star compatible) 
.br
D) Double sided (North Star compatibleections in 
.bd
fdj
's interactive menu.

.in -5 
.bd
NOTES
.in +5
.br
The fdj program is capable of formatting soft-sectored 5 1/4"
diskettes when used with a DJ/DMA controller updated or manufactured
after  September  15,  1983.   The EPROM in the upper right  hand 
corner of the controller board, labeled "DJ/DMA" (location 
15, A) should have a revision number of 2.5 or greater.

.in -5 
.bd
SEE ALSO
.in +5
.br
Maintenance and Administration, section 8.1.
5
The following discussion is intended primarily .in 15
.rm 79
.he "          wc (1)                   4/6/83                          wc (1)
.fo "                                           -#-"
.bd
.ti -5
NAME
.br
.bd
wc
- word count


.ti -5
.bd
SYNTAX
.br
.bd
wc [-plwc] [-v] [files...]


.ti -5
.bd
DESCRIPTION
.br
.bd
Wc
reads each file in the order given
and counts the lines, words, and characters.
These totals are reported in that order,
unless a flag argument was used to request
a different display:

        -lwc  requests the standard display of
livolumes to be given.
The v flag is mainly here for backward compatability.

.ti -9
i	incremental - Normally, 
.bd
fp 
processes all the files it encounters.
With the i and r flags in effect, only files
which have been changed since the dumpdate are acted upon.
The i flag forces
.bd
fp
to make an entry with the current date in the file /etc/dtab.
(Dtab stands for dump table.)
If this file is lost, so is the memory of previous
dump dates.
One entry in the dtab file is produced for each
file named on the command line.
If no files are named on the command line,
the entry in "dtab" will be for the current directory.
If no dtab file exists, 
.bd
fp 
will attempt to create one.
This will work subject to the permissions of the /etc  
directory.
See the examples for an actual use of the i flag.

.ti -9
c	create -  This flag only works with the r flag.  Create 
means to erase any files that may already be on the volume.  
Obviously, you only want to use this with new volumes, or 
volumes you are recycling.

.ti -9
l	lanes, words, and characters.

        -plwc requests pages, lines, words, and characters.
(Pages = characters divided by 55.)

        -wp requests words and pages in that order, etc.

A "v" flag (for "verbose") causes each count to be labeled.

In any case, if more than one file name is given, the
counts are accompanied by the file name, and a total is given
at the end. If no file name is given, the standard input is used.


.bd
.ti -5
SEE ALSO
.br
lines (1), words (1), chars (1)
ided (North Star compatible.in 15
.rm 79
.he "          fp (1)                        11/9/83                       fp (1)
.fo "                                           -#-"
.bd
.ti -5
NAME
.br
.bd
fp 
- floppy backup service

.ti -5
.bd
SYNOPSIS
.br
.bd
fp [rxt][vfiqs] [device] [filenames ...]

.ti -5
.bd
DESCRIPTION

.bd
fp 
allows you to backup files on floppies under the Micronix system.

In this document the word "volume" will be used to refer to 
a single instance of storage medium, for example, diskette, tape reel, tape cassbel set - This flag causes 
.bd
fp
to ask for a name to label this set of volumes with.  The label
may be up to 250 characters long.

.ti -9
e	formatting program - If 
.bd
fp
encounters an unformatted disk during a backup operation, it will
automatically invoke the fdj program, which will query the 
operator for information and format the currently inserted diskette.
This may save you during a long backup.  If you want to change 
the name of the formatting program invoked, use the e option, 
followed by the name of the program to be used.

.ti -9
f	device file name - Specifying f allows the choice of a 
different device name.
The default device name is /dev/fp.
/dev/fp is normally linked to /dev/mfa which is 
the first 5 1/4 inch floppy drive
connected to a Morrow DJDMA running under Micronix.
If your system uses 8 inch drives, you should relink /dev/fp.
HINT - use the following commands for an 8" drive system:

               cd /dev; era fp
               ln fla fp

.ti -9
p	print - Operates similarly to exette, or removable hard disk.

The word "device" will refer to the disk or tape drive which
manipulates the volume.
For example floppy drive, tape drive, hard disk drive.

The word "set" will mean a series of volumes produced by a single 
.bd
fp 
run
that you get when you make a copy of a large file structure.
Theoretically, a set could run to 30 volumes or so in
an imaginable case with the current Micronix system.

.ti -5
.bd
FEATURES

* ability to split files across volumes for backup of large files.

* minimal seeking on the device to reduce running time.

* incremental dumps possible using the central "dtab" dump table.

.ti -5
.bd
FLAGS (choose exactly one)

r	write files to the device.

x	read files from the device.

t	display files on the device.

.ti -5
More flags (optional)

.in +9
.ti -9
v	verbose - The v flag causes a note to be printed as each file
is processed.  The v flag is always on (unless the s flag is used 
to suppress it).  
With the t flag, v causes extra detail about the files
on the fp tract, but the files are sent
to the standard output instead of a file.
This is theoretically useful to manually peruse
copied images of text files.

.ti -9
q	quick copy - Normally all files are checked 
for readability immediately after
being copied to a volume.
Specifying the q flag bypasses this safty feature.

.ti -9
s	silent operation - Normally, in the spirit of micros, fp announces each file
transaction.
Specifying the s flag suppresses much of this printing.
You are still notified of error conditions.
.in -9


.ti -5
.bd
GENERAL RULES

If the name of a directory is given to 
.bd
fp, 
it takes it 
to mean that dirctory and all its descendants.

If no file names are given, the implication is to do all files.
For the t flag, this means all the files stored on the
current volume.
For r, this means the current directory and all its descendents.
For the x flag, all files in the set of volumes are extracted.

If you name your files with absolute path names, that is, 
starting with the / of root, any file thatry 
in /etc/dtab, and requests a label for the volumes.

To produce an incremental (the next day for instance):

	cd / ; fp cril

Using another formatted diskette, this backs up only the files 
that have been modified since the last dump of the root.

To print a label for a volume:

	fp | lpr 


To produce a backup of your directory alone:

	cd ; fp cril


To completely restore your home directory from a dump,
install volume 1 of the set in the device and:

	cd ; fp x


To copy to an 8 inch floppy under Micronix:

	fp crf /dev/fla


To copy a single (possibly large) file:

	fp r filename


.ti -5
.bd
SEE ALSO

fdj(1), for details on the formatting program, and
dtab(5).

d
W - wait - w: [$variable] [number]
.br
Wait is just like "accept" above only it "times out"
after a certain period.
The default period is six seconds.
One can select a different period by placing a numeric value to
the right of the colon as one of the arguments.
If the specified time interval expires before
the RETURN key has been pressed, t you extract will be 
restored to its former position in the file system.
If you backup files starting in the current directory, or use 
filenames that don't begin with a /, you can restore files 
to any directory in the file system.

It's possible for a volume to be full yet contain few or no 
files.
If a read-back error occurs, the remaining space on the volume, 
after the block with the error,
will be effectively marked out.

Links are preserved across 
.bd
fp 
operations.
If you copy a file to which there are several links,
only one copy of the file's data will be made.

For each file on the volume the t flag, for 
.bd
table, 
prints the length
in bytes, 
the modification time of the file at the time it was copied,
the file's name the way it was when backed up, 
and possibly a notation concering which part of the file
represented.

       4872  Nov 14  7:30  myfile [part 2]

In the above example, this part of the file is 4872 bytes long,
the file had been last changed on Nov. 14th at 7:30 in the morning..he "chdir (2)		          3/19/82               chdir (2)"
.fo "				    -#-"
.rm 65
.in 5
.bd
NAME
.in +5
.br
.bd
chdir
- change working directory

.in -5
.bd
C
.in +5
.br
chdir(dirname)
.br
char *dirname;
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
The working directory of the current process is changed
to the given directory.
The user must have search (execute) permission on the directory.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
A 0 is returned on success, a -1 on failure.
.sp 2
.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(chdir = 12)
.br
.bd
sys; chdir; dirname
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
rive, tape drive, hard disk drive.

The word "set" will mean a series of volumes produced by a single 
.bd
fp 
run
that you get when you make a copy of a large file structure.
Theoretically, a set could run to 30 volumes or so in
an imaginable case with the current Micronix system.

.ti -5
.bd
FEATURES

* ability to split files across volumes for backup of large files.

* m
The file is named myfile, a relative filename and only 
part 2 of the file is represented here.
Part one fo the file is found on the previous volume of the set.

The most you can get on a current technology floppy is 800 blocks.
2400 blocks will fit on an 8 inch floppy.
.bd
fp 
automatically sets its directory size to one eightieth the
size of the volume, with a minimum of 20 blocks.
In the case of soft sectored 1K 5 inch floppies, the volume
size is 800 blocks, the directory size is 20 blocks.
A maximum of 160 entries can be put on the volume.
There are 8 directory entries per directory block.
Sometimes this is wasteful (for instance when the
average file size is small).

When splitting files, 
.bd
fp 
does not waste space.
It writes right up to the end of the volume.

.ti -5
.bd
EXAMPLES

To produce the first full dump of your file system, have 
many volumes formatted and:

	cd / ; fp cril

This creates a new volume (or set of volumes), backs up 
everything starting with the root directory (/), makes an en.he "chmod (2)		          3/18/82               chmod (2)"
.fo "				    -#-"
.rm 65
.in 5
.bd
NAME
.in +5
.bd
chmod
- change mode of file
.sp 2
.in -5
.bd
C
.in +5
.br
chmod(name, mode)
.br
char *name;
.sp 2
.in -5
.bd
FUNCTION    
.in +5
.br
The mode of the file is set as indicated.
Only the owner of a file, or the super-user, may change the mode.
Modes are constructed by ORing together some combination
of the following (octal) values:

.in +8
.nf
.bd 8
4000  Set user id on execution
2000  Set group id on execution
1000  Currently ignored
0400  Read by owner
0200  Write by owner
0100  Execute (or search directory) by owner
0070  Read, write, execute (search) by group
0007  Read, write, execute (search) by others
.in -8

.fi
When a file with the set-user-id flag is executed,
the effective user ID of the process is set to the owner
of the file. 
(In this way, for instance, a spelling program could use
a secret dictionary.)

For security reasons, whenever a file is opened
for writing, its set-id flags are clearles.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.
.sp 2
.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(close = 6)
.br
.bd
(file descriptor in hl)
.br
.bd
sys; close
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
e user ID of the process is set to the owner
of the file. 
(In this way, for instance, a spelling program could use
a secret dictionary.)

For security reasons, whenever a file is opened
for writing, its set-id flags are clear.he "creat (2)		          3/18/82               creat (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
creat
- create a new file (or truncate an old one)
.sp 2
.in -5
.bd
C
.in +5
.br
creat(name, mode)
.br
char *name;
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
If the file does not exist,
and if the parent directory is writable,
it is created with the given mode.
If the file does exist and is writable,
it is truncated to 0 length,
and its mode and owner remain unchanged.
In either case, the file is
oed.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.
.sp 2
.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(chmod = 15)
.br
.bd
sys; chmod; name; mode
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
lags (optional)

.in +9
.ti -9
v	verbose - The v flag causes a note to be printed as each file
is processed.  The v flag is always on (unless the s flag is used 
to suppress it).  
With the t flag, v causes extra detail about the files
on the fp .he "chown (2)		          3/18/82               chown (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
chown
- change owner and group of a file
.sp 2
.in -5
.bd
C
.in +5
.br
chown(name, owner)
.br
char *name;
.sp 2
.in -5
.bd
FUNCTION         
.in +5
.br
The owner of the file is changed to the low byte of "owner",
and the group is changed to the high byte.
Only the super-user may execute this call.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.
.sp 2
.in -5
.bdpened for writing only, and a file descriptor is returned.

See 
.bd
chmod 
(2) for the construction of modes. Note that the
file is opened for writing, even if the given mode does not
allow writing.
This can be used as a locking mechanism, in that another
program will not be able to create the same file.

.bd
Creat
is subject to the limit of 16 open files per process.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
.bd
Creat()
returns a file descriptor (a small, positive number)
on success, or a -1 on failure.
.sp 2
.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(creat = 8)
.br
.bd
sys; creat; name; mode
.br
.bd
(file descriptor in hl)
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
If successful, a file descriptor is returned in hl.
n failure.
lags (optional)

.in +9
.ti -9
v	verbose - The v flag causes a note to be printed as each file
is processed.  The v flag is always on (unless the s flag is used 
to suppress it).  
With the t flag, v causes extra detail about the files
on the fp 
ASSEMBLER
.in +5
.br
.bd
(chown = 16)
.br
.bd
sys; chown; name; owner
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.

0007  Read, write, execute (search) by others
.in -8

.fi
When a file with the set-user-id flag is executed,
the effective user ID of the process is set to the owner
of the file. 
(In this way, for instance, a spelling program could use
a secret dictionary.)

For security reasons, whenever a file is opened
for writing, its set-id flags are clear.he "close (2)		          3/18/82               close (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
close 
- close a file
.sp 2
.in -5
.bd
C
.in +5
.br
close(descriptor)
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
Given a file descriptor previously returned by
.bd
open, creat,
or
.bd
pipe, close
closes the associated file.
A close of all files is automatic on
.bd
exit,
but since processes are limited to 16 simultaneously open files,
.bd
close ()
may be necessary for programs that deal with many fi.he "csw (2)		          3/19/82                 csw (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
csw
- read the console switches
.sp 2
.in -5
.bd
C
.in +5
.br
getcsw()
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
The setting of the console switches is returned.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
The setting of the console switches is returned.
.sp 2
.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(csw = 38)
.br
.bd
sys; csw
.br
.bd
(switch setting in hl)
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
The switch setting is returned in hl.
ly, and a file descriptor is returned.

See 
.bd
chmod 
(2) for the construction of modes. Note that the
file is opened for writing, even if the given mode does not
allow writing.
This can be used as a locking mechanism, in that another
program will not be able to create the same file.

.bd
Creat
is subject to the limit of 16 open files per process.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
.bd
Creat()
returns a file descriptor (a small, positive number)
on success, or a -1 on failure.
.sp 2
..in +5
.br
.bd
(exit = 1)
.br
.bd
(status in hl)
.br
.bd
sys; exit


.in -5
.bd
RETURNS
.in +5
.fi
None.
binations of
.bd
dup
and
.bd
close
can be used to move file descriptors
in a general way. This is used mostly for manipulating
the standard input (file descriptor 0) and the
standard output (file descriptor 1).

.bd
Dup
is subject to the limit of 16 active file descriptors
per process.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
.bd
Dup()
returns a file descriptor (positive) if successful,
or a -1 if not.
.sp 2
.he "fork (2)                     3/19/82                     fork (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
fork
- create a new process


.in -5
.bd
C
.in +5
.br
fork()


.in -5
.bd
FUNCTION      
.in +5
.br
.bd
Fork
is the only way to create a new process.
The calling process splits into a "parent"
and a "child". The child's core image is a
copy of the parent's, open files are shared,
and signals remain unchanged.
.bd
Fork()
returns a zero to the child process,
while it returns a non-zer.he "dup (2)                      3/19/82                      dup (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
dup
- duplicate a file descriptor
.sp 2
.in -5
.bd
C
.in +5
.br
dup(descriptor)
.sp 2
.in -5
.bd
FUNCTION       
.in +5
.br
.bd
Dup 
takes a file descriptor previously returned by
.bd
open, creat,
or
.bd
pipe
and allocates a new descriptor
synonymous with the original.  Subsequent reads or writes
with the new descriptor will have exactly the same
effect as the same call with the old descriptor.

Since the algorithm that allocates file descriptors
returns the lowest available value, combinations of
.bd
dup
and
.bd
close
can be used to move file descriptors
in a general way. This is used mostly for manipulating
the standard input (file descriptor 0) and the
standard output (file descriptor 1).

.bd
Dup
is subject to the limit of 16 active file descriptors
per process.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
.bd
Dup()
returns a file descriptor (positive) if successful,
or a -1 if not.
.sp 2
o number to the parent.
This is the process ID of the child,
and is used by
.bd
wait
(2) and
.bd
kill
(2).


.in -5
.bd
RETURNS
.in +5
.br
.bd
Fork()
returns a zero to the child, and the non-zero
process ID of the child to the parent. 
A return of -1 (not just negative) indicates a
temporary lack of process space.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(fork = 2)
.br
.bd
sys; fork
.br
.bd
(child return)
.br
.bd
(+ 3 bytes)
.br
.bd
(parent return) (child id in hl)


.in -5
.bd
RETURNS
.in +5
.br
The child process returns to the location
immediately following the fork.
The parent skips three bytes before returning,
and receives the child ID in hl.
If a new process cannot be created,
the carry flag is set on return to the
parent (and the child return
never happens).
arry flag is set.
l)

.in +9
.ti -9
v	verbose - The v flag causes a note to be printed as each file
is processed.  The v flag is always on (unless the s flag is used 
to suppress it).  
With the t flag, v causes extra detail about the files
on the fp .in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(dup = 41)
.br
(old descriptor in hl)
.br
.bd
sys; dup
.br
(new descriptor in hl)
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
On success, the carry flag is cleared and the new descriptor
is returned in register hl.  On failure, the carry flag is set.
l)

.in +9
.ti -9
v	verbose - The v flag causes a note to be printed as each file
is processed.  The v flag is always on (unless the s flag is used 
to suppress it).  
With the t flag, v causes extra detail about the files
on the fp .he "exit (2)                     3/19/82                     exit (2)"     
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
exit
- terminate this process


.in -5
.bd
C
.in +5
.br
exit(status)


.in -5
.bd
FUNCTION    
.in +5
.fi
.bd
Exit
closes all open files,
terminates the calling process,
and notifies the parent process
(if it is executing a wait).
The low byte of status is available
to the parent (via wait).
.nf


.in -5
.bd
RETURNS
.in +5
.fi
This call can never return.


.in -5
.bd
ASSEMBLER
.he "fstat (2)                    3/19/82                    fstat (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
fstat
- get the status of an open file


.in -5
.bd
C
.in +5
.br
fstat(descriptor, buf)
.br
struct stat *buf;


.in -5
.bd
FUNCTION       
.in +5
.fi
.bd
Fstat 
is identical to
.bd
stat,
except that it operates on open files
(via the file descriptor)
rather than on files given by name.
This is often used to examine
the status of the standard input and output,
whose names are usually unknown.
Buf is the address of a 36 byte buffer,
into which the following information is
placed:

.nf
.bd 15
struct stat
	{
char	minor,		/* minor device */
	major;		/* major device */
int	inumber,	/* inode number */
	flags;		/* see below */
char	nlinks,		/* number of links */
	uid,		/* user id of owner */
	gid,		/* group id of owner */
	size0;		/* high byte of size */
int	size1,		/* low word of size */
	sddr[8];	/* block numbers */
long	actime,		/* time of last access */
	modtime;	/* " last modification */.he "gtty (2)                     3/19/82                     gtty (2)"  
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
gtty
- get typewriter status


.in -5
.bd
C
.in +5
.br
.nf
gtty(descriptor, vec)
struct
	{
	char	ispeed,		/* input speed */
		ospeed,		/* output speed */
		erase,		/* erase character */
		kill;		/* kill character */
	int	mode;		/* see below */
	}
	*vec;



.fi
.in -5
.bd
FUNCTION   
.in +5
.br
.bd
Gtty
gets the status of the terminal
associated with the file descriptor,
and writes the status into the 6-byte
structure pointed at by vec.
(This structure is the same as that passed by 
.bd
stty.
) Actually, this call may be made to any character device,
but devices that do not like it may
return an error.

.bd
Ispeed and ospeed are one of:

.nf
.in +4
.bd 16
0     1200 baud
1       50 baud
2       75 baud
3      110 baud
4      134.5 baud
5      150 baud
6      200 baud
7      300 baud
8      600 baud
9     1200 baud
10    1800 baud
11    2400 baud
12    4800 baud
13    9600 baud
14   1
	};

The flags are as follows (values in octal):

.nf
.bd 15
 100000		inode is allocated
 060000		2-bit file type
	 000000		plain file
	 040000		directory
	 020000		character-special file
	 060000		block-special file
 010000		large file
 004000		set user-id on execution
 002000		set group-id on execution
 001000		currently ignored
 000400		read (owner)
 000200		write (owner)
 000100		execute or search directory (owner)
 000070		read, write, execute (group)
 000007		read, write, execute (others)
.bp
.in -5
.bd
RETURNS
.in +5
.fi
A 0 indicates success, a -1 indicates failure
(bad file descriptor).


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(fstat = 28)
.br
.bd
(file descriptor in hl)
.br
.bd
sys; fstat; buf


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
On success, the status is placed in the 36-byte area
pointed at by buf.
 for dump table.)
If this file is lost, so is the memory of previous
dump dates.
One entry in the dtab file is produced for each
file named on the comma9200 baud
15    1200 baud
.in -4
.fi

The next two characters specify the
erase and kill characters, respectively.
(The defaults are ^H and ^X).
.bp
The mode specifies what services are performed
by the system on input and output.
Currently, these are:
.nf

.in +4
.bd 5
0200  Use the RS-232 clear-to-send line
0040  Raw input
0020  Cr -> lf mapping
0010  Echo input
0002  Expand tabs
.in -4

.fi
In raw mode, all characters are passed immediately
to the program without waiting for a full line to be typed,
there is no erase or kill processing,
and there is no recognition
of any special control characters.
In cooked mode, the following control characters
are recognized:
.in +4

.nf
.bd 6
^D  end-of-file (when typed alone on a line)
^\  send a quit signal to this tty's processes
DEL send an interrupt signal to same
^B  send a background signal to same
ESC freeze the output from this tty
^S  same as ESC
.in -4

.fi
Note that even while the tty is in raw mode,
the other modes still have an effect.

In cr->lf mode, in.he "getpid (2)                   3/19/82                   getpid (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
getpid
- get process ID


.in -5
.bd
C
.in +5
.br
getpid()


.in -5
.bd
FUNCTION         
.in +5
.br
.bd
Getpid
returns the process ID of the current process.
This is the same ID that is used by the
.bd
fork, kill,
and
.bd
wait
system calls.


.in -5
.bd
RETURNS
.in +5
.br
.bd
Getpid
returns the process ID.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(getpid = 20)
.br
.bd
sys; getpid
.br
.bd
(id in hl)


.in -5
.bd
RETURNS
.in +5
.br
.bd
Getpid
returns the process ID in hl.
s
placed:

.nf
.bd 15
struct stat
	{
char	minor,		/* minor device */
	major;		/* major device */
int	inumber,	/* inode number */
	flags;		/* see below */
char	nlinks,		/* number of links */
	uid,		/* user id of owner */
	gid,		/* group id of owner */
	size0;		/* high byte of size */
int	size1,		/* low word of size */
	sddr[8];	/* block numbers */
long	actime,		/* time of last access */
	modtime;	/* " last modification */put crs are turned into lfs,
and output crs or lfs are turned into cr-lfs.

In echo mode, input is echoed immediately.
If the mode is also raw, it is echoed exactly
as typed; otherwise, the special control characters
are not echoed, the kill character is echoed as
itself plus a newline, and the erase character
is echoed as backspace-space-backspace.

In expand-tabs mode, tabs are output as the
number of spaces needed to bring the cursor
to the next 0-mod-8 column.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.
On success, the status is placed in the 6-byte structure
pointed at by vec.
.bp
.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(gtty = 32)
.br
.bd
(file descriptor in hl)
.br
.bd
sys; gtty; vec


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
On success, the status is placed in the 6-byte area pointed
at by vec.
save you during a long backup.  If you want to change 
the name of the formatting program invoked, use the e option, 
followed by the.he "mount (2)                    3/19/82                    mount (2)" 
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
mount 
- mount a file system


.in -5
.bd
C
.in +5
.br
.bd
mount(device, on, ronly)
.bd
.br
char *device, *on;


.in -5
.bd
FUNCTION       
.in +5
.br
.bd
Mount
informs the system that the given
block device contains a file system.
Subsequent references to the file "on"
will refer to the root directory of the
new file system. The old contents of "on"
are inaccessible until the device is
unmounted.

If ronly is non-zero, the system will not
allow writing on the device. If the device
is physically write protected, it should
still be mounted read-only to prevent
the system from trying to update access times.

This call is restricted to the super-user.
There is a limit to the number of devices
that can be mounted concurrently.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(mount = 21)
.br
.bd
sys; mount; device; on; r.he "indir (2)                    3/19/82                    indir (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
indir
- indirect system call


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(indir = 0)
.br
.bd
sys; indir; syscall


.in -5
.bd
FUNCTION    
.in +5
.br
The system call at the location syscall is executed.
Execution resumes after the
.bd
indir
call.

The main purpose of
.bd
indir
is to allow programs to
construct system calls in their data segments,
avoiding modifications to their code.

The system call at syscall must begin with the
"sys" byte. An
.bd
indir
executed indirectly is a no-op.


.in -5
.bd
RETURNS
.in +5
.br
The returns depend on the indirectly executed call.
that do not like it may
return an error.

.bd
Ispeed and ospeed are one of:

.nf
.in +4
.bd 16
0     1200 baud
1       50 baud
2       75 baud
3      110 baud
4      134.5 baud
5      150 baud
6      200 baud
7      300 baud
8      600 baud
9     1200 baud
10    1800 baud
11    2400 baud
12    4800 baud
13    9600 baud
14   1only


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
cters, respectively.
(The defaults are ^H and ^X).
.bp
The mode specifies what services are performed
by the system on input and output.
Currently, these are:
.nf

.in +4
.bd 5
0200  Use the RS-232 clear-to-send line
0040  Raw input
0020  Cr -> lf mapping
0010  Echo input
0002  Expand tabs
.in -4

.fi
In raw mode, all characters are passed immediately
to the program without waiting for a full line to be typed,
ther.he "sync (2)                     3/19/82                     sync (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
sync 
- update the disks


.in -5
.bd
C
.in +5
.br
sync()


.in -5
.bd
FUNCTION   
.in +5
.br
.bd
Sync 
causes all information in core memory that should
be on disk to be written out.
This includes modified super-blocks, modified inodes,
and delayed block I/O.


.in -5
.bd
RETURNS
.in +5
.br
No information is returned.  
.bd
Sync
always succeeds.


.in -5
.bd
ASSEMBLER
.in +5
.br
.b.he "mknod (2)                    3/19/82                    mknod (2)" 
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
mknod
- make a directory or special file
.sp 2
.in -5
.bd
C
.in +5
mknod(name, mode, addr)
char *name;


.in -5
.bd
FUNCTION         
.in +5
.fi
.bd
Mknod
creates a new file.  Unlike
.bd
creat,
it may be used
to create directories and special files;              
it does not truncate or open files.

The mode of the new file (including the file type bits)
is taken from the mode argument, and the first address is
taken from addr. For directories, this address should be
0, while for special files it should be the device number.

This call is restricted to the super-user.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(mknod = 14)
.br
.bd
sys; mknod; name; mode; addr


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
 1800 baud
11    2400 baud
12    4800 baud
13    9600 baud
14   1d
(sync = 36)
.br
.bd
sys; sync


.in -5
.bd
RETURNS
.in +5
.br
No error indication is returned.
evice
is physically write protected, it should
still be mounted read-only to prevent
the system from trying to update access times.

This call is restricted to the super-user.
There is a limit to the number of devices
that can be mounted concurrently.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(mount = 21)
.br
.bd
sys; mount; device; on; r.he "time (2)                     3/19/82                     time (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
time 
- get date and time


.in -5 
.bd
C
.in +5
.br
time(tp)
.br
long *tp;


.in -5 
.bd
FUNCTION   
.in +5
.br
.bd
Time 
fills the long value pointed to by the argument
with the number of seconds since 0:00 GMT January 1 1970.


.in -5 
.bd
RETURNS
.in +5
.br
The user-supplied long integer is filled in.
There are no error conditions.


.in -5 
.bd
ASSEMBLER
.in +5
.br
.bd
(time = and less than the stack pointer are not in
the address space of the program.
These locations may be overwritten by the system,
and may cause memory faults if accessed.
The system will refuse to set the break above the stack pointer,
but a program is free to move its stack pointer below the
break.

.bd
Sbrk
adds incr more bytes to the program's data space
and returns a pointer to the start of the new area.

When a program begins execution via
.bd
exec
(2), its break is set to the top of its program and data storage
areas.  Thus, only programs that must dynamically allocate
data space need to use these calls.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
The old break is returned on success.
A -1 is returned if the request would require more memory
than the system limit, or if it would move the break across
the stack pointer.
.sp 2
.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(break = 17)
.br
.bd
sys; break; addr
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
Only success or failure is returned,
by clearing or setting the carry flag, respec13)
.br
.bd
sys; time
.br
.bd
(time in hl-de)


.in -5 
.bd
RETURNS
.in +5
.br
The time is returned with the high order word in hl
and the low order word in de.
There are no error conditions.
 from trying to update access times.

This call is restricted to the super-user.
There is a limit to the number of devices
that can be mounted concurrently.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(mount = 21)
.br
.bd
sys; mount; device; on; r.he "access (2)		          3/18/81              access (2)"
.fo "			           -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
access
- test file access permissions
.sp 2
.in -5
.bd
C
.in +5
.br
access(name, mode)
.br
char *name;
.br
int mode;
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
Permission to access the named file, in the specified mode,
is tested. The test is based on the real user and group IDs,
rather than the effective IDs, so that a set-user-id program
may test the permissions of its invoker.
Mode is thetively.
erase or kill processing,
and there is no recognition
of any special control characters.
In cooked mode, the following control characters
are recognized:
.in +4

.nf
.bd 6
^D  end-of-file (when typed alone on a line)
^\  send a quit signal to this tty's processes
DEL send an interrupt signal to same
^B  send a background signal to same
ESC freeze the output from this tty
^S  same as ESC
.in -4

.fi
Note that even while the tty is in raw mode,
the other modes still have an effect.

In cr->lf mode, in.he "exec (2)                     3/19/82                exec (2)"
.fo "                               -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
exec
- execute a program
.sp 2
.in -5
.bd
C
.in +5
.br
execv(name, argv)
.br
char *name;
.br
char *argv[];

execl(name, arg0, arg1, ..., argn, 0)
.br
char *name, *arg0, *arg1, ..., *argn;
.sp 2
.in -5
.bd
FUNCTION
.in +5
.br
.bd
Exec
overlays the calling core image with the named file,
then transfers to the beginning of the new core image.
There can be no return fr 
.ul
sum 
of any of the following:

.nf
.in +8
.bd 3
4  read
2  write
1  execute
.in -8

.in -5
.bd
RETURNS
.in +5
.fi
.br
.bd
Access
returns a 0 if permission is granted, -1 if not.
.sp 2
.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(access = 33)
.br
.bd
sys; access; name; mode
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
.bd
Access 
returns with the error bit clear if the permissions
are granted, or with the error bit set if they are not.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(mount = 21)
.br
.bd
sys; mount; device; on; r.he "break (2)			  3/18/82               break (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
break, brk, sbrk
- change core allocation
.sp 2
.in -5
.bd
C
.in +5
.br
char * brk(addr)
.br
char * sbrk(addr)
.sp 2
.in -5
.bd
FUNCTION    
.in +5
.fi
.br
.bd
Brk
sets the system's idea of the lowest memory location
not used by the program (called the "break")
to addr (which may be rounded up to suit
memory management hardware).
The old break is returned.

Locations greater than or equal to the break
om a successful
.bd
exec:
the calling core image is lost.

Exec does not create a new process -
the same process continues with the new core image.
Previously opened files remain open
(so standard input and output are preserved),
and ignored signals remain ignored.
Caught signals, however, are reset to their default behavior.

Each process has "real" user and group IDs and "effective"
user and group IDs. The real IDs identify the user;
the effective IDs determine the access privileges.
If a file does not have "set-user-id" or "set-group-id"
mode [see
.bd
chmod,
(2)], then
.bd
exec
sets all IDs,
real and effective, to the individual executing the file.
If the file does have either mode,
.bd
exec
sets the corresponding
effective ID to the owner of the executed file. The real IDs
remain unchanged. This allows a user to write a
program that takes advantage of his own access privileges
(rather than its invoker's privileges).

In order to be executed, a file must have one of the
execute permission bits set, even fo is limited
to 512.

It is conventional to repeat the name
of the file being executed as the first argument,
so that programs can use the name with which they are invoked.
.bp
When a C program is executed, it begins as follows:

.bd
main(argc, argv)
.in +8
.br
.bd
int argc;
.br
.bd
char **argv;
.in -8

where
.bd
argc
is the argument count, and
.bd
argv
is a list of pointers to the argument strings themselves.  Conventionally,
.bd
argc
is at least 1 and
.bd
argv[0]
is the program name.
As delivered by the system, argv[argc] == -1, so that
.bd
argv
cannot be used directly in another
.bd
execv
until
.bd
argv[argc]
is set to 0.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
Any return is an error return.
In that case, the calling image is not lost and can continue.
Possible errors include: the file cannot be found,
is not an ordinary file,
is not executable, is too big, or the argument list
is too long.
.sp 2
.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(exec = 11)
.br
.bd
sys; exec; name; argv


.bp
.bd
Argv
is the address of a lisr the super-user.
The system expects one of two file formats.
If the first byte is hex 99, then the first 16
bytes are taken to be a header with the following structure
.nf
.bp
struct header
        {
        char     ident,         /* hex 99 */
                 conf;          /* not used by exec */
        unsigned tablsize,      /* not used by exec */
                 textsize,      /* bytes in text segment */
                 datasize,      /* bytes in data segment */
                 bss_size,      /* bytes in bss segment */
                 heapsize,      /* minimum stack + heap */
                 textoff,       /* text segment offset */
                 dataoff;       /* data segment offset */
        };
.sp
.fi
(This header structure is produced by Whitesmith's compilers.)
The rest of the file is assumed to contain textsize bytes of
text, followed by datasize bytes of data. Text is loaded at
address textoff, data is loaded at address dataoff, and bss
space is allocated following the data. The break ist of string pointers.
The last pointer must be 0. When the file starts
execution, core is set up as follows:


.nf
.bd 9
(top of user core)
argn:   string\0
        ...
arg0:   string\0
        -1
        argn
        ...
        arg0
sp ->   argc
.sp 2
.fi
.in -5
.bd
RETURNS
.in +5
.br
If
.bd
exec
returns at all, the carry flag is set to
indicate an error.
volume, 
after the block with the error,
will be effectively marked out.

Links are preserved across 
.bd
fp 
operations.
If you copy a file to which th.he "getuid (2)                   3/25/82                   getuid (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
getuid
- get user IDs


.in -5
.bd
C
.in +5
.br
getuid()


.in -5
.bd
FUNCTION   
.in +5
.br
.bd
Getuid
returns the real user IDs of the current process.
The real group ID is in the high byte of the returned word.
The real user ID is in the low byte.
(The real IDs identify the individual,
while the effective IDs determine his
current access privileges. See the
.bd
exec
and
.bd
chmod set at the
highest location in the text or data + bss segments.

If the first byte of the file is not hex 99, then the file is
taken to be pure object code origined at address 256 (100
hex). The brake is set to the file size.

In any case, the program must meet the maximum-size
restriction (currently 65024 bytes), and it must keep a "halt"
instruction (the system-call trap) at address 8. (This is
supplied by the system, unless the text offset is <= 8.)

C offers two different interfaces to
.bd
exec.  Execl
is useful when a known file is being executed
with known arguments.
The arguments are all string pointers.
Any number of arguments may be given, but the last
must be a 0.

When the number of arguments
is not known in advance,
.bd
execv
is handy. Pointers
to the argument strings are collected into a list,
a null pointer is appended to mark the end of the
list, and
.bd
execv
is called with the address of the list.

Currently, the total number of bytes in the argument
strings (including the terminating nulls)
system calls for a discussion.)


.in -5
.bd
RETURNS
.in +5
.br
.bd
Getuid
returns the real user IDs:
.br
high byte = group ID, low byte = user ID.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(getuid = 24)
.br
.bd
sys; getuid
.br
.bd
(IDs in hl)


.in -5
.bd
RETURNS
.in +5
.br
.bd
Getuid
returns the real process IDs:
.br
.bd
high byte = group ID, low byte = user ID.
oup IDs and "effective"
user and group IDs. The real IDs identify the user;
the effective IDs determine the access privileges.
If a file does not ha.he "alarm (2)                    3/19/82                    alarm (2)"  
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
alarm 
- set the alarm clock


.in -5
.bd
C
.in +5
.br
alarm(seconds)


.in -5
.bd
FUNCTION   
.in +5
.br
This call sets the "alarm clock", which will send an
.bd
alarm
signal to the calling process after the given number of seconds
( see
.bd
signal (2)
). Meanwhile, the process continues to run.

An argument of 0 turns the alarm clock off.

See also
.bd
pause (2) and sleep(2).

.er),
and must not have more than 254 links.
.nf


.in -5
.bd
RETURNS
.in +5
.fi
A 0 indicates success, a -1 indicates failure.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(link = 9)
.br
.bd
sys; link; old; new


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
l)
.br
.bd
sys; kill; sig


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
The real IDs identify the user;
the effective IDs determine the access privileges.
If a file does not ha.he "open (2)                     3/19/82                     open (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
open
- open a file for reading or writing


.in -5
.bd
C
.in +5
.br
.bd
open(name, mode)
.br
.bd
char *name;


.in -5
.bd
FUNCTION       
.in +5
.br
The named file is opened for
.nf

.in +4
.bd 3
reading	(mode 0),
writing	(mode 1), or
both	(mode 2).
.in -4

.fi
The returned file descriptor should be saved
for subsequent calls to 
.bd
read, 
.bd
write, 
and 
.bd
close.

There is a liin -5
.bd
RETURNS
.in +5
.br
If an alarm was previously set but not yet triggered,
.bd
alarm
returns the number of seconds remaining until the old alarm.
Otherwise it returns 0.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
alarm = 27)
.br
.bd
(seconds in hl)
.br
.bd
sys; alarm


.in -5
.bd
RETURNS
.in +5
.br
The time remaining on any old alarm is returned in hl.
There is no error return.
ve"
user and group IDs. The real IDs identify the user;
the effective IDs determine the access privileges.
If a file does not ha.he "kill (2)                     3/19/82                     kill (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
kill
- signal a process


.in -5
.bd
C
.in +5
.br
kill(pid, sig)


.in -5
.bd
FUNCTION   
.in +5
.br
.bd
Kill
sends the signal, sig, to the process with the given ID.
The usual effect is to kill the process - see
.bd
signal
(2) for a discussion and a list of signals.

The sending and receiving processes must have the same effective
user IDs, or the sender must be the super-user.

Ifmit of 16 open files per process.
.nf


.in -5
.bd
RETURNS
.in +5
.fi
A non-negative return indicates success, a -1 indicates failure.
On success, a file descriptor (small non-negative number)
is returned.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(open = 5)
.br
.bd
sys; open; name; mode
.br
.bd
(file descriptor in hl)


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
On success, a file descriptor is returned in hl.
Ds determine the access privileges.
If a file does not ha.he "pipe (2)                     3/19/82                     pipe (2)" 
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
pipe
- create an inter-process channel


.in -5
.bd
C
.in +5
.br
.bd
pipe(descriptor)
.br
.bd
int descriptor[2];
.br
.bd
(read descriptor = descriptor[0])
.br
.bd
(write descriptor = descriptor[1])


.in -5
.bd
FUNCTION         
.in +5
.br
.bd
Pipe
returns two file descriptors that can
be used to communicate between processes
created by subsequent 
.bd
fork 
calls.
When the pipe is the given process ID is 0, then the signal is sent
to all other processes with the same controlling tty.

A process can never kill itself.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(kill = 37)
.br
.bd
(process ID in hl)
.br
.bd
sys; kill; sig


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
The real IDs identify the user;
the effective IDs determine the access privileges.
If a file does not ha.he "link (2)                     3/19/82                     link (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
link
- link to a file


.in -5
.bd
C
.in +5
.br
link(old, new)
.br
char *old, *new;


.in -5
.bd
FUNCTION        
.in +5
.fi
A link to "old" is created, with the name "new".
Either name may be an arbitrary pathname.

"New" must not already exist,
its directory must be writable,
and it must be on the same device as "old".
"Old" must not be a directory
(unless the user is the super-us written using descriptor[1],
up to 4096 bytes of data will be buffered
before the writing process is suspended.
A read using descriptor[0] will pick up the data.

Read calls on an empty pipe with no writers
will return an end-of-file (i.e., 0 bytes read).
Write calls under similar conditions will
generate a signal.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(pipe = 42)
.br
.bd
sys; pipe
.br
.bd
(read descriptor in hl)
.br
.bd
(write descriptor in de)


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
e, to the individual executing the file.
If the file does have either mode,
.bd
exec
sets the corresponding
effective ID to the owner of the executed file. The real IDs
remain unchanged. This allows a user to write a
program that takes advantage of his own access privileges
(rather than its invoker's privileges).

In order to be executed, a file must have one of the
execute permission bits set, even fo 
.ti -2
- If 
.bd
from 
is 2, the pointer is set to the size of the file         
plus offset.                                                              
.sp
.ti -2
- If 
.bd
from 
is 3, 4, or 5, the meaning is the same as for 0, 1, or 2,
except that offset is multiplied by 512.
.sp
.ti -2
- If 
.bd
from 
is 0 or 3, offset is treated as signed.
Otherwise it is unsigned.
.sp
.in -2
.nf
.ce
.bd
IN SUMMARY:

.ta 8
.bd 6
Byte	Block
seeks	seeks	Motion is relative to

0	3	Beginning of file (unsigned)
1	4	Current location (signed)
2	5	End of file (signed)

.fi
.bd
Seeks 
are not allowed on pipes, but are allowed on character devices,
although most such devices ignore them.
Seeking far past the end of a file and writing
will create a "hole" in the file that occupies no space.
Reading the hole will allocate zero-filled space.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.
.bp
.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(seek = 19)
.br
.bd
(descriptor in hl)
.br
.bd
sys; seek; offset; from

.he "read (2)                     3/19/82                     read (2)"
.fo "				   -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
read
- read a file


.in -5
.bd
C
.in +5
.br
.bd
read(descriptor, buffer, nbytes)
.br
.bd
char buffer[];


.in -5
.bd
FUNCTION       
.in +5
.br
A file descriptor is a word returned from a successful
.bd
open, creat, dup,
or
.bd
pipe
call.
Buffer is a memory location where at most
nbytes of data will be placed.
The number of bytes actually read is returned.
This may well be less than nbytes;
a read on a terminal, for example, will return at most one line.
If the value 0 is returned, then the file has been exhausted.


.in -5
.bd
RETURNS
.in +5
.br
A - 1 indicates an error.  A return of 0 indicates end-of-file.
Any other value indicates a successful read of that many bytes.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(read = 3)
.br
.bd
(file descriptor in hl)
.br
.bd
sys; read; buffer; nbytes
.br
.bd
(number of bytes read in hl)


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on suc
.in -5
.bd
RETURNS
.in +5
.br 
The carry flag is cleared on success, or set on failure.
, then the first 16
bytes are taken to be a header with the following structure
.nf
.bp
struct header
        {
        char     ident,         /* hex 99 */
                 conf;          /* not used by exec */
        unsigned tablsize,      /* not used by exec */
                 textsize,      /* bytes in text segment */
                 datasize,      /* bytes in data segment */
                 bss_size,      /* b.he "setuid (2)                   3/19/82                   setuid (2)"  
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
setuid 
- set process user IDs


.in -5
.bd
C
.in +5
.br
setuid(uid)


.in -5
.bd
FUNCTION          
.in +5
.br
This call sets the real group and user IDs
and the effective group and user IDs.
The group IDs are set to the high byte of the argument,
and the user IDs are set to the low byte.
This call can be used to set the effective IDs to the real IDs.
Only the super-user is permicess, or set on failure.
5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
e, to the individual executing the file.
If the file does have either mode,
.bd
exec
sets the corresponding
effective ID to the owner of the executed file. The real IDs
remain unchanged. This allows a user to write a
program that takes advantage of his own access privileges
(rather than its invoker's privileges).

In order to be executed, a file must have one of the
execute permission bits set, even fo.he "seek (2)                     3/19/82                     seek (2)"
.fo "				   -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
seek 
- move read/write pointer


.in -5
.bd
C
.in +5
.br
seek(descriptor, offset, from)


.in -5
.bd
FUNCTION           
.in +5
.br
Each open file has an associated read/write pointer.
.bd
Seek 
moves this pointer as follows:

.in +2
.ti -2
- If 
.bd
from 
is 0, the pointer is set to offset.
.sp
.ti -2
- If 
.bd
from 
is 1, the pointer is set to its current location plus offset.
.sptted to change the real IDs.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(setuid = 23)
.br
.bd
(uid in hl)
.br
.bd
sys; setuid;


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
i -2
- If 
.bd
from 
is 0 or 3, offset is treated as signed.
Otherwise it is unsigned.
.sp
.in -2
.nf
.ce
.bd
IN SUMMARY:

.ta 8
.bd 6
Byte	Block
seeks	seeks	Motion is relative to

0	3	Beginning of file (unsigned)
1	4	Curr.he "signal (2)                   3/19/82                   signal (2)" 
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
signal
- set disposition of signals


.in -5
.bd
C
.in +5
.br
signal(sig, func)
.br
int (*func)();


.in -5
.bd
FUNCTION   
.in +5
.br
A signal is a means of notifying a process
of some external event.
A signal can be sent from the system
(in response to an attempt to execute an
illegal instruction, for example),
from a terminal (to abort a process),
or at the request of another pr

.in -5
.bd
RETURNS
.in +5
.br
The return value is the old signal disposition.
A 0 indicates success, a -1 indicates failure
(signal number out of range).


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(signal = 48)
.br
.bd
sys; signal; sig; func;
.br
.bd
(old value in hl)


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
(the system-call trap) at address 8. (This is
supplied by the system, unless the text offset is <= 8.)

C offers two different interfaces to
.bd
exec.  Execl.he "sleep (2)                    3/19/82                    sleep (2)"  
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
sleep 
- stop execution for an interval


.in -5
.bd
C
.in +5
.br
sleep(seconds)


.in -5
.bd
FUNCTION   
.in +5
.br
The calling process is suspended for at least
the given number of seconds.


.in -5
.bd
RETURNS
.in +5
.br
The call returns after the given number of seconds.
A 0 indicates success, a -1 indicates failure.
The only cause of failure is an early return
caused by a cauocess
(via the 
.bd
kill 
system call).
Normally, a signal causes termination
of the receiving process, but this call
allows the process either to ignore it
or to "catch" it via an interrupt to
a specified location.
There are 15 signals:

.nf
.in +4
.bd 15
1    -- (hangup)
2    interrupt (caused by typing DEL)
3    quit (caused by typing control \) *
4    illegal instruction *
5    -- (trace trap)
6    background (caused by typing control b)
7    record available at terminal **
8    -- (floating point exception)
9    kill (cannot be caught or ignored)
10   -- (bus error)
11   memory fault
12   bad argument to a system call *
13   write to a pipe with no one to read it
14   alarm clock
15   terminate (catchable kill)
.sp
.fi
.bd
* 
causes a core dump unless caught or ignored
.sp
.bd
** 
not reset when caught
.in -4

.fi
Signals marked "--" are not currently sent by the system.
(The Unix V6 descriptions are given).

A "func" of 0 tells the system to institute the default
action for the given signal. For all sigght signal.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
sleep = 35)
.br
.bd
(seconds in hl)
.br
.bd
sys; sleep


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
The only cause of failure is an early return
caused by a caught signal.
hangup)
2    interrupt (caused by typing DEL)
3    quit (caused by typing control \) *
4    illegal instruction *
5    -- (trace trap)
6    background (caused by typing control b)
7    record available at terminal **
8    -- (floating point excep.he "stat (2)                     3/19/82                     stat (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
stat 
- get the status of a named file


.in -5
.bd
C
.in +5
.nf
.br
stat(name, buf)
char *name;
struct stat *buf;
.fi


.in -5
.bd
FUNCTION       
.in +5
.br
.bd
Stat
is identical to
.bd
fstat,
except that it operates on named files
rather than open-file descriptors.
Buf is the address of a 36 byte buffer,
into which the following information is
placed:

.nf
.bd 15
struct stat
	{
cnals but 6 and 7,
this means process termination on receipt of the signal.
For signal 6, the default action is to put the process
into the "background" (all further signals, except 9, will be
ignored, and reads on a terminal will return eof).
For signal 7, the default action is to ignore the signal.
.bp
If "func" is 1, the signal will be ignored.
If "func" is any value greater than 1, then it is
taken as an address, and receipt of the signal will
cause an interrupt to that address.
Except as noted, a signal is reset to 0 after being
caught. So in general, the catching routine must
issue another signal call if it wants to continue
catching the signal.

If a signal is caught during a slow system call
(read or write to a terminal,
.bd
sleep
, or
.bd
wait
), the call will terminate prematurely and return
an error (number EINTR - see the Introduction).

After a fork, the child inherits all signal dispositions.
.bd
Exec
passes on all default and ignore dispositions,
but resets all caught signals to default action.
har	minor,		/* minor device */
	major;		/* major device */
int	inumber,	/* inode number */
	flags;		/* see below */
char	nlinks,		/* number of links */
	uid,		/* user id of owner */
	gid,		/* group id of owner */
	size0;		/* high byte of size */
int	size1,		/* low word of size */
	addr[8];	/* block numbers */
long	actime,		/* time of last access */
	modtime;	/* " last modification */
	};

The flags are as follows (values in octal):

.bd 15
 100000		inode is allocated
 	 060000		2-bit file type
	 000000		plain file
	 040000		directory
	 020000		character-special file
 060000		block-special file
 010000		large file
 004000		set user-id on execution
 002000		set group-id on execution
 001000		currently ignored
 000400		read (owner)
 000200		write (owner)
 000100		execute or search directory (owner)
 000070		read, write, execute (group)
 000007		read, write, execute (others)


.fi
It is not necessary to have read permission on the file,
but all directories leading to the file must be searchable.


.in -5
.bd
RETUus is taken from a 6-byte
structure pointed at by vec.
This structure is the same as that obtained by 
.bd
gtty.
Actually, this call may be made to any character device,
but devices that do not like it may
return an error.

.bd
Ispeed 
and 
.bd
ospeed 
are one of:
.nf
.in +4
.sp
.bd 16
0     1200 baud
1       50 baud
2       75 baud
3      110 baud
4    134.5 baud
5      150 baud
6      200 baud
7      300 baud
8      600 baud
9     1200 baud
10    1800 baud
11    2400 baud
12    4800 baud
13    9600 baud
14   19200 baud
15    1200 baud
.in -4

.fi
The next two characters specify the
erase and kill characters, respectively.

The mode specifies what services are performed
by the system on input and output.
Currently, these are:
.nf
.bp
.in +4
.bd 5
0200  Use the RS-232 clear-to-send line
0040  Raw input
0020  Cr -> lf mapping
0010  Echo input
0002  Expand tabs
.in -4

.fi
In raw mode, all characters are passed immediately
to the program without waiting for a full line to be typed,
there is no erase or kill proRNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(stat = 18)
.br
.bd
stat; name; buf


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
On success, the status is placed in the 36-byte area
pointed at by buf.
al.
.bp
If "func" is 1, the signal will be ignored.
If "func" is any value greater than 1, then it is
taken as an address, and receipt of the signal will
cause an interrupt to that address.
Except as noted, a signal.he "stime (2)                    3/19/82                    stime (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
stime 
- set date and time


.in -5
.bd
C
.in +5
.br
stime(time)
.br
long * time;


.in -5
.bd
FUNCTION   
.in +5
.br
.bd
Stime 
sets the system's idea of the date and time.
The argument is the number of seconds since
0:00 GMT, January 1, 1970.
Only the super-user may make this call.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure
(not super-user).


.icessing,
and there is no recognition
of any special control characters.
In cooked mode, the following control characters
are recognized:
.in +4

.nf
.bd 6
^D  end-of-file (when typed alone on a line)
^\  send a quit signal to this tty's processes
DEL send an interrupt signal to same
^B  send a background signal to same
ESC freeze the output from this tty
^S  same as ESC
.in -4

.fi
Note that even while the tty is in raw mode,
the other modes still have an effect.

In cr->lf mode, input crs are turned into lfs,
and output crs or lfs are turned into cr-lfs.

In echo mode, input is echoed immediately.
If the mode is also raw, it is echoed exactly
as typed; otherwise, the special control characters
are not echoed, the kill character is echoed as
itself plus a newline, and the erase character
is echoed as backspace-space-backspace.

In expand-tabs mode, tabs are output as the
number of spaces needed to bring the cursor
to the next 0-mod-8 column.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicaten -5
.bd
ASSEMBLER
.in +5
.br
.bd
(stime = 25)
.br
.bd
(time in hl-de: hl = high word, de = low word)
.br
.bd
sys; stime


.in -5
.bd
RETURNS
.in +5
.fi
The carry flag is cleared on success, or set on failure.
*/
	size0;		/* high byte of size */
int	size1,		/* low word of size */
	addr[8];	/* block numbers */
long	actime,		/* time of last access */
	modtime;	/* " last modification */
	};

The flags are as follows (values in octal):

.bd 15
 100000		inode is allocated
 	 060000		2-bit file type
	 000000		pla.he "stty (2)                     3/19/82                     stty (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
stty 
- set typewriter status


.in -5
.bd
C
.in +5
.bd 10
stty(descriptor, vec)
.br
struct
.nf
	{
	char	ispeed,		/* input speed */
		ospeed,		/* output speed */
		erase,		/* erase character */
		kill;		/* kill character */
	int	mode;		/* see below */
	}
	*vec;


.in -5
.bd
FUNCTION   
.in +5
.fi
.bd
Stty 
sets the status of the terminal
associated with the file descriptor.
The stats failure
(file descriptor does not refer to a character device).


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(stty = 31)
.br
.bd
(file descriptor in hl)
.br
.bd
sys; stty; vec


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
n hl)


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
(the system-call trap) at address 8. (This is
supplied by the system, unless the text offset is <= 8.)

C offers two different interfaces to
.bd
exec.  Execl.he "umount (2)                   3/19/82                   umount (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
umount 
- dismount a file system


.in -5
.bd
C
.in +5
.br
umount(device)
.br
char *device;


.in -5
.bd
FUNCTION        
.in +5
.br
.bd
Umount 
tells the system that the given special file
should no longer be treated as a file system.
The file on which the device was mounted reverts
to its ordinary interpretation.

.bd
Umount 
will return an error if there are still any
active fileof all the deaths.

Wait returns the process ID of the terminated child,
and fills in the user-supplied address with the termination status.
In the case of a normal termination via
.bd
exit,
the low byte of the status is 0, and the high byte
is the low byte of the child's exit argument.
In the case of a signal-caused termination,
the low byte of the status is the signal number,
and the high byte is the child's l register.

If a parent process terminates without waiting
for its children, the initialization process
(process id = 1) inherits the children.


.in -5
.bd
RETURNS
.in +5
.br
A positive number indicates success, a -1 indicates failure
(no children).  On success, the pointed-to status
is filled in with the child's termination status,
and the child's process ID is returned.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(wait = 7)
.br
.bd
sys; wait
.br
.bd
(process id in hl)
.br
.bd
(status in de)


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure
(no children). On success, ts on the mounted system.

This call is restricted to the super-user.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(umount = 22)
.br
.bd
sys; umount; device


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
d
2       75 baud
3      110 baud
4    134.5 baud
5      150 baud
6      200 baud
7      300 baud
8      600 baud
9     1200 baud
10    1800 baud
11    2400 baud
12    4800 baud
13    9600 baud
1.he "unlink (2)                   3/19/82                   unlink (2)"      
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
unlink 
- remove a directory entry


.in -5
.bd
C
.in +5
.br
unlink(name)
.br
char *name;


.in -5
.bd
FUNCTION            
.in +5
.br
.bd
Unlink 
removes the indicated entry from its directory.
If this was the last link to the file, the file is
removed and its space is freed. If the file was open
in any process, this removal is delayed until the file
is closed, even though ithe child's process ID
is returned in hl, and its termination status is
returned in de.
 the following control characters
are recognized:
.in +4

.nf
.bd 6
^D  end-of-file (when typed alone on a line)
^\  send a quit signal to this tty's processes
DEL send an interrupt signal to same
^B  send a background signal to same
ESC freeze the output from this tty
^S  same as ESC
.in -4

.fi
Note that even while the tty is in raw mode,
the other modes still have an effect.

In cr->lf mode, input crs are turned into l.he "write (2)                    3/19/82                    write (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
write 
- write to a file


.in -5
.bd
C
.in +5
.br
write(descriptor, buf, nbytes)
.br
char *buf;


.in -5
.bd
FUNCTION   
.in +5
.br
This call writes nbytes from the indicated buffer to the
given open file. The number of bytes actually written
is returned. Unlike the 
.bd
read 
call, this number should be the
same as requested; otherwise, an error is indicated.


.in -5
.bd
RETURNS
s last directory entry
has disappeared.

In order to unlink a file, a user must have write
permission on its directory. Write permission is not
required on the file itself. Only the super-user
can unlink a directory.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(unlink = 10)
.br
.bd
sys; unlink; name


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
11    2400 baud
12    4800 baud
13    9600 baud
1.he "wait (2)                     3/19/82                     wait (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
wait 
- wait for a process to terminate


.in -5
.bd
C
.in +5
.br
wait(pstat)
.br
int *pstat;


.in -5
.bd
FUNCTION    
.in +5
.br
This call waits for the termination of any of the caller's children.
If any child has died since the last wait, return is immediate.
If there are no children, an error is returned.
If there are several children, several wait calls are necessary
to learn .in +5
.br
A -1 indicates an error (bad descriptor or physical
IO error). Otherwise, the value nbytes is returned.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(write = 4)
.br
.bd
(descriptor in hl)
.br
.bd
sys; write; buf; nbytes


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
The number of characters actually written is returned in hl.
umber,
and the high byte is the child's l register.

If a parent process terminates without waiting
for its children, the initialization p.fo "		               -#-"
.rm 65
.in 5
.bd
		INTRODUCTION TO SYSTEM CALLS


This section of the manual lists all Micronix system calls.
The syntax for these calls is in most cases identical
with that for Unix Version 6 system calls, differing
only in the assembly language register names.
For most purposes, Section II of the Unix V6 Programmer's Manual
can be used as a reference in place of this one.

Call syntax for both C and assembly language is given.
Familiarity with one of these languages is necessaryal sections).
For the sake of portability, however, it is unwise to
depend on this.

From assembly language, an error is always indicated by
turning on the carry bit of the condition flags. Thus a
system call can be followed by a
jc
(jump on carry) to handle an error return, or a
jnc
(jump on no carry) to handle an error-free return.
The error number is returned in register hl.


.ce
.bd
Error Numbers

Following is a list of error numbers, their names in the
system source code, the standard error message available
thru
.bd
perror,
and a short explanation.

.bd
0	(not used)
.sp
.bd
1	EPERM	Not super user
.sp
The current user was attempting something reserved
for the super-user.
.sp
.ta 5
.in +5
.ti -5
.nf
.bd
2	ENOENT	No such file or directory
.fi
The last component of a path name does not exist.

.ti -5
.nf
.bd
3	ESRCH	No such process
.fi
The process whose number was given to
.bd
signal
does not exist, or is already dead.

.ti -5
.nf
.bd
4	EINTR	Interrupted system call
.fi
A slow system call (such as read or to
understand this section.

Many system calls take a file name.
This can be an arbitrary path name,
of unlimited length,
but it must be terminated by a 0-byte,
and the calling process must have search permission on
all directories in the path.

An error during a system call never causes an automatic
error message,
but an error number is always available (see below),
and the program can request a standard error message
if it wants [see
.bd
perror 
(3)].


.ce
.bd
C System Calls

The type of declarations given for system call arguments
are not meant to be copied literally;
they are simply indications of how the system
will treat the arguments.
A string, for example,
is always acceptable in place of a 
.bd
(char *)
argument.  When no declaration is given, an 
.bd
int 
is expected.

From C, an error is indicated by an otherwise impossible
return value. This is usually -1; the individual sections
specify the details.
The error number is always left in
the external variable,
.bd
errno.
This variable is not cleare write on a tty,
but never on a disk) was interrupted by a caught signal.
.bp
.ti -5
.nf
.bd
5	EIO	I/O error
.fi
A physical I/O error occurred during a read or write.

.ti -5
.nf
.bd
6	ENXIO	No such device or address
.fi
An I/O call was made to a non-existent device, or beyond the
limits of the device.

.ti -5
.nf
.bd
7	E2BIG	Arg list too long
.fi
A call to 
.bd
exec 
was made with an argument list longer than 512 bytes.

.ti -5
.nf
.bd
8	ENOEXEC	Exec format error
.fi
An attempt was made to execute an inappropriate file
(such as a directory or special file), even though
the user had execute permission on the file.

.ti -5
.nf
.bd
9	EBADF	Bad file number
.fi
A file descriptor refers to no open file,
or a read or write request is made to a file
not opened for that activity.

.ti -5
.nf
.bd
10	ECHILD	No children
.fi
There were no child processes to
.bd
wait
for.

.ti -5
.nf
.bd
11	EAGAIN	No more processes
.fi
.bd
Fork
found the system process table temporarily full.

.ti -5
.nf
.bd
12	ENOMEM	Not enough core
.fi
d on successful calls,
so that it remains available across message writes, etc.


.ce
.bd
Assembly Language System Calls

Syntax is given for A-Natural (Whitesmith's)
assembly language.
Translation to Intel or Zilog mneumonics is straightforward.
For example, the 
.bd
chmod 
system call in A-Natural is
.ti +8
.sp
.bd
sys; chmod; name; mode
.bp
In Intel assembly language, this looks like
.in +8
.sp
.bd 
db sys
.br
.bd
db chmod
.br
.bd
dw name
.br
.bd
dw mode
.in -8
.sp 2
.fi
The "sys" byte that begins each system call
is a synonym for "restart 1".
The names of the calls themselves are
synonyms for 1-byte quantities that can be found
in the individual sections, or by
inspecting or including the files
/include/an.h and /include/intel.h.
Succeeding in-line arguments, if any, are always 2-byte quantities.
A "name" argument is always a pointer to a null-terminated string.

Registers are preserved across system calls,
except for the error flag and error number (see below),
and for any return values (see the individuDuring an
.bd
exec
or
.bd
break,
the program asked for more core than the system could supply.
This is not a temporary condition: the maximum program size is
a system parameter.

.ti -5
.nf
.bd
13	EACCES	Permission denied
.fi
The user attempted a file access forbidden by the file's
permission bits.

.ti -5
.nf
.bd
14	ESYS	System error
.fi
The system has detected an "impossible" error, caused
by corrupted disk, memory, or a system bug,
but not yet severe enough to warrant a panic stop.
This should be reported.

.ti -5
.nf
.bd
15	ENOTBLK	Block device required
.fi
A plain file or a directory was given where a block device
was required, (in
.bd
mount,
for example).

.ti -5
.nf
.bd
16	EBUSY	Device busy
.fi
An attempt was made to mount a device that was already mounted,
to unmount a device on which there was an open file or
a current directory,
or to open a one-user-only device that is already busy.
.bp
.ti -5
.nf
.bd
17	EEXIST	File exists
.fi
The new file name passed to
.bd
link
or
.bd
mknod
is already taken.

.ti.he "nice (2)                     7/19/82                     nice (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
nice
- set process priority


.in -5
.bd
C
.in +5
.br
nice(arg)


.in -5
.bd
FUNCTION   
.in +5
.br
The "nice" of a process is the opposite of its intuitive
"priority" -- the "nicer" it is, the less cpu time it hogs.
This systen entry sets the nice of the calling process to
the given argument. Nice values range from -128 to 127;
the normal value is 0.
Only the super-user can set a negative nice (== high
priority). Long running background programs should be
run at a positive nice as a favor to other users.

A process' nice is passed to its children via the
.bd
fork
system call.

.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(nice = 34)
.br
.bd
(nice value in hl)
.br
.bd
sys; nice;


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
ce
.bd
C System Calls

The type of declarations gi -5
.nf
.bd
18	EXDEV	Cross-device link
.fi
A link to a file on another device was attempted.

.ti -5
.nf
.bd
19	ENODEV	No such device
.fi
An attempt was made to open a non-existent device.

.ti -5
.nf
.bd
20	ENOTDIR	Not a directory
.fi
A non-directory was specified where a directory was required,
as an intermediate component in a path name, for example, or
as an argument to
.bd
chdir
.

.ti -5
.nf
.bd
21	EISDIR	Is a directory
.fi
An attempt was made to write on a directory.

.ti -5
.nf
.bd
22	EINVAL	Invalid argument
.fi
An invalid argument was given to a system call:
currently, unmounting a non-mounted device, mentioning
an unknown signal in
.bd
signal,
or invoking a non-existing system call.
Ordinarily, the latter case generates a fatal signal;
the error is returned only if the signal is caught or ignored.

.ti -5
.nf
.bd
23	ENFILE	File table overflow
.fi
The system's table of open files is temporarily full.

.ti -5
.nf
.bd
24	EMFILE	Too many open files
.fi
Only 16 files can be open per process

.ti -5
.nf
..he "pause (2)                    3/19/82                    pause (2)"  
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
pause 
- wait for a signal


.in -5
.bd
C
.in +5
.br
pause()


.in -5
.bd
FUNCTION   
.in +5
.br
This call suspends the calling process until the receipt of a signal.
If the signal is caught,
( see
.bd
signal (2)
), then the pause() returns (with an "interrupted system call" error).
Otherwise, the signal kills the process.

See also
.bd
alarm (2) and sleep(2).

.in -5
.bd
RETURNS
.in +5
.br
.bd
Pause
returns only after a signal has been caught, and always with
an EINTR error (see Intro(2)). If the signal is received but
not caught, then the process is killed and the pause() never
returns.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
pause = 29)
.br
.bd
sys; pause
 -5
.bd
ASSEMBLER
.in +5
.br
.bd
(nice = 34)
.br
.bd
(nice value in hl)
.br
.bd
sys; nice;


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
ce
.bd
C System Calls

The type of declarations gibd
25	ENOTTY	Not a typewriter
.fi
The file mentioned to
.bd
stty
or
.bd
gtty
is not a typewriter or other character-device.

.ti -5
.nf
.bd
26	ETXTBSY	Text file busy
.fi
Not currently used.

.ti -5
.nf
.bd
27	EFBIG	File too big
.fi
The user attempted to extend a file beyond the
maximum size of 2^24 bytes.

.ti -5
.nf
.bd
28	ENOSPC	No space left on device
.fi
The disk's free space has been exhausted.

.ti -5
.nf
.bd
29	ESPIPE	Illegal seek
.fi
A seek was issued to a pipe.

.ti -5
.nf
.bd
30	EROFS	Read-only file system
.fi
An attempt was made to write to a device mounted read-only.
.bp
.ti -5
.nf
.bd
31	EMLINK	Too many links
.fi
The program attempted to make a 256th link to a file.

.ti -5
.nf
.bd
32	EPIPE	Broken pipe
.fi
The program wrote on a pipe that had no reader.
Ordinarily this generates a fatal signal; the error is
returned if the signal is caught or ignored.
 a numeric value to
the right of the colon as one of the arguments.
If the specified time interval expires before
the RETURN key has been pressed, .fo "		               -#-"
.rm 65
.in 5
.bd
		INTRODUCTION TO SYSTEM CALLS


This section of the manual lists all Micronix system calls.
The syntax for these calls is in most cases identical
with that for Unix Version 6 system calls, differing
only in the assembly language register names.
For most purposes, Section II of the Unix V6 Programmer's Manual
can be used as a reference in place of this one.

Call syntax for both C and assembly language is given.
Familiarity with one of these languages is necessary to
understand this section.

Many system calls take a file name.
This can be an arbitrary path name,
of unlimited length,
but it must be terminated by a 0-byte,
and the calling process must have search permission on
all directories in the path.

An error during a system call never causes an automatic
error message,
but an error number is always available (see below),
and the program can request a standard error message
if it wants [see
.bd
perror 
(3)].


.ce
.bd
C System Calls

The type of declarations giailable
thru
.bd
perror,
and a short explanation.

.ti -5
.bd
0	(not used)
.sp
.ti -5
.bd
1	EPERM	Not super user
.sp
The current user was attempting something reserved
for the super-user.
.sp
.ta 5
.in +5
.ti -5
.nf
.bd
2	ENOENT	No such file or directory
.fi
The last component of a path name does not exist.

.ti -5
.nf
.bd
3	ESRCH	No such process
.fi
The process whose number was given to
.bd
signal
does not exist, or is already dead.

.ti -5
.nf
.bd
4	EINTR	Interrupted system call
.fi
A slow system call (such as read or write on a tty,
but never on a disk) was interrupted by a caught signal.
.bp
.ti -5
.nf
.bd
5	EIO	I/O error
.fi
A physical I/O error occurred during a read or write.

.ti -5
.nf
.bd
6	ENXIO	No such device or address
.fi
An I/O call was made to a non-existent device, or beyond the
limits of the device.

.ti -5
.nf
.bd
7	E2BIG	Arg list too long
.fi
A call to 
.bd
exec 
was made with an argument list longer than 512 bytes.

.ti -5
.nf
.bd
8	ENOEXEC	Exec format error
.fi
An attempt was made to exven for system call arguments
are not meant to be copied literally;
they are simply indications of how the system
will treat the arguments.
A string, for example,
is always acceptable in place of a 
.bd
(char *)
argument.  When no declaration is given, an 
.bd
int 
is expected.

From C, an error is indicated by an otherwise impossible
return value. This is usually -1; the individual sections
specify the details.
The error number is always left in
the external variable,
.bd
errno.
This variable is not cleared on successful calls,
so that it remains available across message writes, etc.


.ce
.bd
Assembly Language System Calls

Syntax is given for A-Natural (Whitesmith's)
assembly language.
Translation to Intel or Zilog mneumonics is straightforward.
For example, the 
.bd
chmod 
system call in A-Natural is
.ti +8
.sp
.bd
sys; chmod; name; mode
.bp
In Intel assembly language, this looks like
.in +8
.sp
.bd 
db sys
.br
.bd
db chmod
.br
.bd
dw name
.br
.bd
dw mode
.in -8
.sp 2
.fi
The "sys" byte that begins each secute an inappropriate file
(such as a directory or special file), even though
the user had execute permission on the file.

.ti -5
.nf
.bd
9	EBADF	Bad file number
.fi
A file descriptor refers to no open file,
or a read or write request is made to a file
not opened for that activity.

.ti -5
.nf
.bd
10	ECHILD	No children
.fi
There were no child processes to
.bd
wait
for.

.ti -5
.nf
.bd
11	EAGAIN	No more processes
.fi
.bd
Fork
found the system process table temporarily full.

.ti -5
.nf
.bd
12	ENOMEM	Not enough core
.fi
During an
.bd
exec
or
.bd
break,
the program asked for more core than the system could supply.
This is not a temporary condition: the maximum program size is
a system parameter.

.ti -5
.nf
.bd
13	EACCES	Permission denied
.fi
The user attempted a file access forbidden by the file's
permission bits.

.ti -5
.nf
.bd
14	ESYS	System error
.fi
The system has detected an "impossible" error, caused
by corrupted disk, memory, or a system bug,
but not yet severe enough to warrant a panic stop.
This shoystem call
is a synonym for "restart 1".
The names of the calls themselves are
synonyms for 1-byte quantities that can be found
in the individual sections, or by
inspecting or including the files
/include/an.h and /include/intel.h.
Succeeding in-line arguments, if any, are always 2-byte quantities.
A "name" argument is always a pointer to a null-terminated string.

Registers are preserved across system calls,
except for the error flag and error number (see below),
and for any return values (see the individual sections).
For the sake of portability, however, it is unwise to
depend on this.

From assembly language, an error is always indicated by
turning on the carry bit of the condition flags. Thus a
system call can be followed by a
jc
(jump on carry) to handle an error return, or a
jnc
(jump on no carry) to handle an error-free return.
The error number is returned in register hl.


.ce
.bd
Error Numbers

Following is a list of error numbers, their names in the
system source code, the standard error message avuld be reported.

.ti -5
.nf
.bd
15	ENOTBLK	Block device required
.fi
A plain file or a directory was given where a block device
was required, (in
.bd
mount,
for example).

.ti -5
.nf
.bd
16	EBUSY	Device busy
.fi
An attempt was made to mount a device that was already mounted,
to unmount a device on which there was an open file or
a current directory,
or to open a one-user-only device that is already busy.
.bp
.ti -5
.nf
.bd
17	EEXIST	File exists
.fi
The new file name passed to
.bd
link
or
.bd
mknod
is already taken.

.ti -5
.nf
.bd
18	EXDEV	Cross-device link
.fi
A link to a file on another device was attempted.

.ti -5
.nf
.bd
19	ENODEV	No such device
.fi
An attempt was made to open a non-existent device.

.ti -5
.nf
.bd
20	ENOTDIR	Not a directory
.fi
A non-directory was specified where a directory was required,
as an intermediate component in a path name, for example, or
as an argument to
.bd
chdir
.

.ti -5
.nf
.bd
21	EISDIR	Is a directory
.fi
An attempt was made to write on a directory.

.ti -5
.nf
.bd
22	loc
and
.bd
free
provide an easy-to-use memory allocation package.  The
.bd
alloc
routine returns a pointer to a block of at least
.bd
size
bytes long, which begins on a word boundary.

The argument to
.bd
free
is a pointer to a block allocated previously by
.bd
alloc.
This block is available for further allocation; its contents are
left undisturbed.

.bd
Alloc 
allocates the first large reach of free space it finds in its
circular search from the last allocated or freed block,
uniting neighboring free blocks as it searches.  If no additional space
is free, 
.bd
alloc
calls
.bd
sbrk
(see section 2) for more system memory.

Block sizes pointed to by
.bd
ptr
are changed by
.bd
realloc
to 
.bd
size
bytes.  It may also return a pointer to a block, if the block
is removed.  The values of the new and old block 
sizes determine the changes in block contents; the contents remain
unchanged up to the lesser value of the old and new sizes.
 
.bd
Alloc
contains a valuable search function which may be used to do storage
cEINVAL	Invalid argument
.fi
An invalid argument was given to a system call:
currently, unmounting a non-mounted device, mentioning
an unknown signal in
.bd
signal,
or invoking a non-existing system call.
Ordinarily, the latter case generates a fatal signal;
the error is returned only if the signal is caught or ignored.

.ti -5
.nf
.bd
23	ENFILE	File table overflow
.fi
The system's table of open files is temporarily full.

.ti -5
.nf
.bd
24	EMFILE	Too many open files
.fi
Only 16 files can be open per process

.ti -5
.nf
.bd
25	ENOTTY	Not a typewriter
.fi
The file mentioned to
.bd
stty
or
.bd
gtty
is not a typewriter or other character-device.

.ti -5
.nf
.bd
26	ETXTBSY	Text file busy
.fi
Not currently used.

.ti -5
.nf
.bd
27	EFBIG	File too big
.fi
The user attempted to extend a file beyond the
maximum size of 2^24 bytes.

.ti -5
.nf
.bd
28	ENOSPC	No space left on device
.fi
The disk's free space has been exhausted.

.ti -5
.nf
.bd
29	ESPIPE	Illegal seek
.fi
A seek was issued to a pipe.

.ti -5
.nf
.bd
30	EROFompaction.
.bd
Realloc works if
.bd
ptr
points to a block that has been freed since the last call of
.bd
alloc, realloc
or
calloc.
Compounding sequences of
.bd
free, alloc
and
realloc 
thereby augments
.bd
alloc's
search strategy for storage compaction.

Allocation of space for an array of
.bd
nelem
elements of
.bd
elsize
size is done by
.bd
calloc.  Each of these routines returns a pointer to a space
aligned for any type of storage.
.sp 2
.in -5
.bd
ERRORS
.in +5
.br
Note that chaos results if space assigned by 
.bd
alloc
is overrun, or if a random number is given to
.bd
free.

A NULL pointer (0) is returned by
.bd
alloc, realloc
and
.bd
calloc
if no memory is available, or if a corrupt arena is detected that was
caused by storage outside the bounds of a block.  If user wishes to
recompile the
.bd
alloc
routine to rigidly check the arena during every transaction, he/she
is referred to the source code.
.sp 2
.in -5
.bd
NOTES
.in +5
.br
The block pointed to by
.bd
ptr
may be destroyed if
.bd
realloc
returns a S	Read-only file system
.fi
An attempt was made to write to a device mounted read-only.
.bp
.ti -5
.nf
.bd
31	EMLINK	Too many links
.fi
The program attempted to make a 256th link to a file.

.ti -5
.nf
.bd
32	EPIPE	Broken pipe
.fi
The program wrote on a pipe that had no reader.
Ordinarily this generates a fatal signal; the error is
returned if the signal is caught or ignored.
ue to
the right of the colon as one of the arguments.
If the specified time interval expires before
the RETURN key has been pressed, .he "alloc (3)                    3/22/82                    alloc (3)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
alloc, free, realloc, calloc
- main memory allocator
.sp 2
.in -5
.bd
C
.in +5
.br
.bd 2
char *alloc(size)
.br
unsigned size;
.sp
.bd 2
free(ptr)
.br
char *ptr;
.sp
.bd 3
char *realloc(ptr, size)
.br
char *ptr;
.br
unsigned size;
.sp
.bd 2
char *calloc(nelem, elsize)
.br
unsigned nelem, elsize;
.sp 2
.in -5
.bd
FUNCTIONS
.in +5
.br
The routines
.bd
al0. sections).
For the sake of portability, however, it is unwise to
depend on this.

From assembly language, an error is always indicated by
turning on the carry bit of the condition flags. Thus a
system call can be followed by a
jc
(jump on carry) to handle an error return, or a
jnc
(jump on no carry) to handle an error-free return.
The error number is returned in register hl.


.ce
.bd
Error Numbers

Following is a list of error numbers, their names in the
system source code, the standard error message av.he "ctime (3)                    3/22/82                    ctime (3)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
ctime, localtime, gmtime, asctime, timezone
- convert time and date to ASCII
.sp 2
.in -5
.bd
C        
.in +5
.br
.bd 2
char *ctime(clock)
.br
long *clock
.sp
.bd
#include <time.h>
.sp
.bd 2         
struct tm *localtime(clock)
.br
long *clock;
.sp
.bd 2
struct tm *gmtime(clock)
.br
long *clock;
.sp
.bd 2
char *asctime(tm)
.br
struct tm *tm;
.sp
.bd
se content is overwritten by 
each call.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
time (2)om assembly language, an error is always indicated by
turning on the carry bit of the condition flags. Thus a
system call can be followed by a
jc
(jump on carry) to handle an error return, or a
jnc
(jump on no carry) to handle an error-free return.
The error number is returned in register hl.


.ce
.bd
Error Numbers

Following is a list of error numbers, their names in the
system source code, the standard error message av.he "fclose (3s)                  3/22/82                  fclose (3s)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
fclose, fflush
- close or flush a stream
.sp 2
.in -5
.bd
C           
.in +5
.br
.bd
#include <stdio.h>
.sp
.bd 2
fclose(stream)
.br
FILE *stream;
.sp
.bd 2
fflush(stream)
.br
FILE *stream;
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
.bd
Fclose
causes any buffers for the named
.bd
stream
to be emptied and the file to be closed.  Buffers
allocated by the char *timezone(zone,dst)
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
.bd
Ctime
converts a time pointed to by 
.bd
clock
[as returned by 
.bd
time
(2)] 
into ASCII.  It returns a pointer to a 26-character string in the
following form:
.sp 2
.ce
.bd
Wed Mar 10 12:12:59 1982\n\0
.sp
All fields have constant width.
.sp 2
.bd
Localtime
and
.bd
gmtime
return pointers to structures containing the broken-down time.

.bd
Localtime
corrects for the time zone and daylight savings time, if necessary.

.bd
Gmtime 
converts to Greenwich Mean Time - the time that Micronix uses.

.bd
Asctime 
converts broken-down time to ASCII and returns a 26-character string.
.sp
The 
.bd
include
file structure declaration follows:
.bp
.nf
.in +8
.bd 11
struct tm { /* see ctime(3) */
	int	tm_sec;
	int	tm_min;
	int	tm_hour
	int	tm_mday;
	int	tm_mon;
	int	tm_year;
	int	tm_wday;
	int	tm_yday;
	int	tm_isdst;
};
.in -8
.sp 2
.fi
The time is given using the following elements:
.sp
.in +8
- 24 hour clock
.br
- day of month, 1-31 days per month
.br
- standard I/O system are freed.  This function is
performed automatically by calling
.bd
exit
(2).

.bd
Fflush 
causes any buffered data for the named output
.bd
stream
to be written to that file.  The stream file remains open.
.sp 2
.in -5
.bd
ERRORS        
.in +5
.br
These routines return an
.bd
EOF
if
.bd
stream 
is not associated with an output file, or if
buffered data cannot be transferred to that file.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
close (2), fopen (3), setbuf (3)
  ry.

.bd
Gmtime 
converts .he "ferror (3s)                  3/22/82                  ferror (3s)
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
feof, ferror, clearerr, fileno
- stream status inquiries
.sp 2
.in -5
.bd
C         
.in +5
.br
.bd
#include <stdio.h>
.sp
.bd 2
feof(stream)
.br
FILE *stream;
.sp
.bd 2
ferror(stream)
.br
FILE *stream
.sp
.bd 2
clearerr(stream)
.br
FILE *stream
.sp
.bd 2
fileno(stream)
.br
FILE *stream
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
The following functions armonth of year, numbered 0-11
.br
- day of the week, numbered 0-6
.br
- date of the year, beginning 1900 - 
.br
- day of the year, 0-365
.br
- non-zero flag indicates daylight savings 
.sp 2
.in -8
The program checks the system to determine if time zone and/or
daylight savings time adjustments are appropriate whenever the 
local time is called for.  (Adjustments for changes in these conversions
in 1974 and 1975 are included.)

.bd
Timezone 
returns the time zone, measured in minutes westward from
Greenwich, associated with its first argument.  If the second argument
is 0, the standard name is used.  A non-zero flag indicates daylight
savings time.

A table is built into the routine.  If the required name does not
appear on this table, the difference from GMT is produced.  
In Afghanistan, for example:
.sp
.ce
.bd
timezone(-60*4+30), 0)
.sp
would be appropriate because it is eastward of GMT +4:30.  The string
.bd
GMT+4:30
is produced.
.sp 2
.in -5
.bd
ERRORS
.in +5
.br
The return values point to static data whoe implemented as macros and cannot
be redeclared:

.bd
Feof
returns a non-zero when an end of file is read on the named input
stream; otherwise a zero is returned.

.bd
Ferror
returns a non-zero when an error occurs while reading or writing
the named 
.bd
stream.  Error must be cleared by
.bd
clearerr
or the error indication lasts until the stream is closed.  A zero
is returned if no error occurs.

.bd
Fileno
returns an integer file descriptor associated with 
.bd
stream
[see
.bd
open
(2)].
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
fopen (3), open (2)cronix uses.

.bd
Asctime 
converts broken-down time to ASCII and returns a 26-character string.
.sp
The 
.bd
include
file structure declaration follows:
.bp
.nf
.in +8
.bd 11
struct tm { /* see ctime(3) */
	int	tm_sec;
	int	tm_min;
	int	tm_hour
	int	tm_mday;
	int	tm_mon;
	int	tm_year;
	int	tm_wday;
	int	tm_yday;
	int	tm_isdst;
};
.in -8
.sp 2
.fi
The time is given using the following elements:
.sp
.in +8
- 24 hour clock
.br
- day of month, 1-31 days per month
.br
- .he "fread (3s)                   3/22/82                   fread (3s)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.bd
fread, fwrite
- buffered binary I/O
.sp 2
.in -5
.bd
C
.in +5
.br
.bd
#include <stdio.h>
.sp
.bd 2
fread(ptr, sizeof(*ptr), nitems, stream)
.br
FILE *stream;
.sp
.bd 2
fwrite(ptr, sizeof(*ptr), nitems, stream)
.br
FILE *stream;
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
Fread
reads 
.bd
nitems
of 
.bd
*ptr
data from the named input stream into a block beginning at
.bd
ptr.
The return is the number of items actually read.

The standard output is line buffered if
.bd
stream
is
.bd
stdin;
any partial output line is flushed before any call to
.bd
read
(see section 2) to satisfy the
.bd
fread
call.

.bd
Fwrite 
appends
.bd
nitems
(maximum) of data to the named output stream.  Data is of the type 
.bd
*ptr
beginning at
.bd
ptr.
It returns the actual number of items written.
.sp 2
.in -5
.bd
DIAGNOSTICS
.in +5
.br
A 0 is returned by 
.bd
fread
and
.bd
fwrite
upon.he "fopen (3s)                   3/22/82                   fopen (3s)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
fopen, freopen, fdopen
- open a stream
.sp 2
.in -5
.bd
C
.in +5
.br
.bd
#include <stdio.h>
.sp
.bd 2
FILE *fopen(filename, type)
.br
char *filename, *type;
.sp
.bd 3
FILE freopen(filename, type, stream)
.br
char *filename, *type;
.br
FILE *stream;
.sp
.bd 2
FILE *fdopen(fildes, type)
.br
char *type;
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
.bd
Fopen
opens the file specified by "filename" and associates it with a stream. 
It returns a pointer to be used to identify the stream in subsequent
operations.
.sp
.bd
Type
is a character containing one of the following values:
.sp
.in +8
.bd
a
- append; begin new writing, or begin at end 
.nf
    of current writing.
.sp
.fi
.bd
r
- open for reading
.sp
.bd
w
- create for writing
.sp 2
.in -8
.bd
Freopen
substitutes the named file in place of an open stream; it returns the
original value of
.bd
stream.  
The origi error or at end of file.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
read (2), write (2), fopen (3), getc (3), putc (3), puts (3), 
printf (3) and scanf (3).

.bd
Fdopen
associates a stream with a file descriptor obtained from
.bd
creat, dup, open
or
.bd
pipe 
(see section 2). The 
.bd
type
of the stream must agree with the mode of the open file.
.bp
.in -5
.bd
NOTES
.in +5
.br
If
.bd
filename
cannot be accessed,
.bd
fopen
and
.bd
freopen
return the NULL pointer.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
open (2), f.he "fseek (3s)                   3/22/82                   fseek (3s)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
fseek, ftell, rewind
- reposition a stream
.sp 2
.in -5
.bd
C         
.in +5
.br
.bd
#include <stdio.h>
.sp
.bd 3
fseek(stream, offset, ptrname)
.br
FILE *stream;
.br
long offset;
.sp
.bd 2
long ftell(stream)
.br
FILE *stream;
.sp
.bd
rewind(stream)
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
.bd
Fseek
sets the position of the next input or output operatnal value of 
.bd
stream
is closed.  This routine may also be used to attach preopened constant
names -
.bd
stdin, stdout, stderr,
- to specified files.

.bd
Fdopen
associates a stream with a file descriptor obtained from
.bd
creat, dup, open
or
.bd
pipe 
(see section 2). The 
.bd
type
of the stream must agree with the mode of the open file.
.bp
.in -5
.bd
NOTES
.in +5
.br
If
.bd
filename
cannot be accessed,
.bd
fopen
and
.bd
freopen
return the NULL pointer.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
open (2), fclose (3)year, numbered 0-11
.br
- day of the week, numbered 0-6
.br
- date of the year, beginning 1900 - 
.br
- day of the year, 0-365
.br
- non-zero flag indicates daylight savings 
.sp 2
.in -8
The program checks the system to determine if time zone and/or
daylight savings time adjustments are appropriate whenever the 
local time is called for.  (Adjustments for changes in these conversions
in 1974 and 1975 are included.)

.bd
Timezone 
returns the time zone, measured in minutes westward from
Greenwich, ion on 
.bd
stream.
This new position is at the signed distance, which is
.bd
offset
bytes from the beginning of the file, the current position, or at 
the end of the file, determined by whether 
.bd
ptrname
has a value of 0, 1 or 2.  This routine also undoes any effects
of the 
.bd
unget
routine.

.bd
Ftell
returns the current value of the offset relative to the beginning
of the file associated with the named
.bd
stream.
This routine provides the only foolproof way to obtain an 
.bd
offset
for
.bd
fseek.

Rewind(stream) = fseek(stream, 0l, 0).
.sp 2
.in -5
.bd
ERRORS     
.in +5
.br
A -1 is returned by
.bd
fseek
for improper seeks.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
lseek (2), fopen (3)

 a file descriptor obtained from
.bd
creat, dup, open
or
.bd
pipe 
(see section 2). The 
.bd
type
of the stream must agree with the mode of the open file.
.bp
.in -5
.bd
NOTES
.in +5
.br
If
.bd
filename
cannot be accessed,
.bd
fopen
and
.bd
freopen
return the NULL pointer.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
open (2), f.he "gets (3s)                    3/22/82                    gets (3s)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
gets, fgets
- get a string from a stream
.sp 2
.in -5
.bd
C
.in +5
.br
.bd
#include <stdio.h>
.sp
.bd 2
char *gets(s)
.br
char *s;
.sp
.bd 3
char *fgets(s, n, stream)
.br
FILE *stream;
.sp 2
.in -5
.bd
FUNCTION
.in +5
.br
.bd
Gets
reads a string into 
.bd
s
from the standard input stream, 
.bd
stdin.
A newline character terminates the string.  This character is replaced
in
.bd
s
by a NULL character;
.bd
gets
returns its argument.

.bd
Fgets
reads 
.bd
n-1
characters (or up to a newline character) from the
.bd
stream
into the
.bd
s
string.  A NULL character follows the last character read into
.bd
s; fgets 
returns its first argument.
.sp 2
.in -5
.bd
ERRORS
.in +5
.br
Both
.bd
gets
and
.bd
fgets
return the constant pointer (NULL) upon an error or at end of file.
.sp 2
.in -5
.bd
NOTES
.in +5
.br
To maintain backward compatibility,
.bd
fgets
maintains a .he "getpwent (3)                  3/22/82                getpwent (3)"
.fo "                                -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
getpwent, getpwuid, getpwnam, setpwent, endpwent
- get password file entry
.sp 2
.in -5
.bd
C
.in +5
.br
.bd
#include <pwd.h>
.sp
.bd
struct passwd *getpwent()
.sp
.bd 2
struct passwd *getpwuid(uid)
.br
int uid;
.sp
.bd 2
struct passwd *getpwnam(name)
.br
char *name;
.sp
.bd
int setpwent()
.sp
.bd
int endpwent()
.sp 2
.in -5
.bd
DESCRIPTIONS
.in +5
.br
Each of the "get" routines - 
.bd
getpwent, getpwuid
and
.bd
getpwnam
- each return a pointer to an object with the following structure:
.sp
.in +8
.nf
.bd 7 
    struct passwd                         
        {
	char	*name               
	        *passwd,  
	unsigned char uid, gid;
	char    *person, *dir, *shell;
        }
.sp 
.fi
.in -8
Each pointer contains the broken-out fields of a line in the 
password file.				

Two fields, 
.bd
pw_quota
and
.bd
pw_comment,
are unused.  All the other fields have newline,
.bd
gets
deletes a newline.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
puts (3), getc (3), scanf (3), fread (3), ferror (3)it will open the file, if necessary.
.sp
.bd
setpwent
- rewinds the file
.sp
.bd
endpwent
- closes the file
.sp
.bd
getpwuid
- searches from the beginning of the file until a matching user ID is
found, or until an end of file is encountered.
.sp
.bd
getpwnam
- searches from the beginning of the file until a matching name is
found, or until an end of file is encountered.
.sp 2
.in 0
.he "putc (3s)                    3/23/82                    putc (3s)"
.fo "                               -#-"
.in 5
.rm 65
.bd
PROGRAM(S)
.in +5
.br
.bd
puts, putchar, fputc, putw
- put character or word on a stream
.sp 2
.in -5
.bd
C
.in +5
.br
.bd
#include <stdio.h>
.sp
.bd 3
int putc(c, stream)
.br
char c;
.br
FILE *stream;
.sp
.bd
putchar(c)
.sp
.bd 2
fputc(c, stream)
.br
FILE *stream;
.sp
.bd 2
putw(w stream)
.br
FILE *stream;
.sp 2
.in -5
.bd
FUNCTIONS
.in +5
.br
.bd
Putc
appends 
.bd
c
(character)meanings which are described
in
.bd
passwd
(5).

Routine Functions:
.sp
.in +5
.bd
getpwent
- reads the next line in the file; it will open the file, if necessary.
.sp
.bd
setpwent
- rewinds the file
.sp
.bd
endpwent
- closes the file
.sp
.bd
getpwuid
- searches from the beginning of the file until a matching user ID is
found, or until an end of file is encountered.
.sp
.bd
getpwnam
- searches from the beginning of the file until a matching name is
found, or until an end of file is encountered.
.sp 2
.in 0
.in 5
.bd
ERRORS
.in +5
.br
A zero (NULL pointer) is returned upon an error or at end of file.
.sp 2
.in -5
.bd
NOTES
.in +5
.br
All information to be saved should be copied since it is contained only
in a temporary area.
.sp 2
.in -5
.bd
FILES
.in +5
.br
/etc/passwd
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
getlogin (3), passwd (5)


e is called for.  (Adjustments for changes in these conversions
in 1974 and 1975 are included.)

.bd
Timezone 
returns the time zone, measured in minutes westward from
Greenwich,  to
.bd
stream,
the named output; it returns the character written.

.bd
Putchar(c)
is the same as
.bd
putc(c, stdout).

.bd
Fputc
acts the same as
.bd
putc
but is a function rather than a macro.  It can be used to save
object text.

.bd
Putw
appends 
.bd
w
(word) to output 
.bd
stream 
and returns the word written.  It does not assume or cause
special alignment in the file.

.bd
Stdout
(standard stream) is only buffered if the output refers to something
other than a terminal (default).
.bd
Setbuf
(3) changes the default.

.bd
Stderr
(also a standard stream) is unbuffered unconditionally (default).
.bd
Freopen
[see
.bd
fopen 
(3)] causes it to become buffered; again,
.bd
setbuf
changes the default.

Unbuffered output streams appear on the destination file or terminal
as soon as they are written.  Buffered output streams save up characters
and write them as a block.  Blocks may be forced out prematurely with
.bd
fflush
[see
.bd
fclose
(3)].
.sp 2
.in -5
.bd
ERRORS
.in +5
.br
These functions return the end of fanf
reads from 
.bd
stdin,
the standard input stream.

.bd
Fscanf
reads from the named input,
.bd
stream.

.bd
Sscanf
reads from the
.bd
s
character string.

Each of these functions read and interpret characters
according to a format, then store the results in its argument.
A control string
.bd
format
and a set of 
.bd
pointer
arguments indicating where the converted input is stored are
arguments expected by these routines.  These are described below.
.sp 2
.in +4
Blanks, tabs or newlines, which match optional white space in the input.

Any ordinary character besides % that must match the next character
of the input stream.

Optional conversion specifications, which consist of an assignment
suppressing character (*), maximum field width number, a conversion
character and the % character.

.in -4
The control string usually contains conversion specifications that
direct interpretation of the next input field.  Unless assignment
suppression was indicated (using the * character), the result is placed
in the variaile constant upon error. 

.bd
Ferror
(3) should be used to detect
.bd
putw
errors.

Errors may occur some time after the initial call to
.bd
putc.
.sp 2
.in -5
.bd
NOTES
.in +5
.br
Since 
.bd
putc
is implemented as a macro, it treats a
.bd
stream
argument improperly.  Specifically,

.ce
.bd
putc(c, *f++);

does not work sensibly.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
fopen (3), fclose (3), getc (3), puts (3), printf (3), fread (3)imezone 
returns the time zone, measured in minutes westward from
Greenwich, .he "puts (3s)                    3/24/82                    puts (3s)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
puts, fputs
- put a string on a stream
.sp 2
.in -5
.bd
C
.in +5
.br
.bd
#include <stdio.h>
.sp
.bd 2
puts(s)
.br
char *s;
.sp
.bd 3
fputs(s, stream)
.br
char *s;
.br
FILE *stream;
.sp 2
.in -5
.bd
FUNCTION
.in +5
.br
.bd
Puts
copies 
.bd
s
(null-terminated string) to
.bd
stdout,
the standard output stream.  It also appends a newline character.

.bd
Fble pointed to by the corresponding argument.

An input field is a string of non-space characters.  The field extends
to the next inappropriate character, or until the field width (if
specified) is exhausted.

The interpretation of the input field is indicated by the conversion
character.  Corresponding pointer arguments are usually of a restricted
type.  A list and description of legal conversion characters follows:
.sp 2
.in +4
.ti -1
.bd
%
.br
A single percent sign (%) is expected.  No assignment is done.
.sp
.ti -1
.bd
d
.br
Decimal integer is expected.  Corresponding argument should be integer
pointer.
.sp
.ti -1
.bd
o
.br
Octal integer expected.  Corresponding argument should be integer pointer.
.sp
.ti -1
.bd
x
.br
Hexadecimal integer expected. Corresponding argument should be 
integer pointer.
.sp
.ti -1
.bd
s
.br
Character string expected.  Corresponding argument should be a character
pointer pointing to an array of characters.  Array must be large enough
to accept string and terminating "\0" charactputs
copies
.bd
s
to the named output,
.bd
stream.

Neither of these routines copies the terminal NULL character.
.sp 2
.in -5
.bd
NOTES
.in +5
.br
To maintain backward compatibility, 
.bd
puts
appends a newline,
.bd
fputs
does not.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
fopen (3), gets (3), putc (3), printf (3), ferror (3), fwrite in 
fread (3)
special alignment in the file.

.bd
Stdout
(standard stream) is only buffered if the output refers to something
other than a terminal (default).
.bd
Setbuf
(3) chang.he "scanf (3s)                   3/24/82                   scanf (3s)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
scanf, fscanf, sscanf
- formatted input conversion
.sp 2
.in -5
.bd
C
.in +5
.br
.bd
#include <stdio.h>
.sp
.bd 2
scanf(format [, pointer]...)
.br
char *format;
.sp
.bd 3
fscanf(stream, format [, pointer]...)
.br
FILE *stream;
.br
char *format;
.sp
.bd 2
sscanf(s, format [, pointer]...)
.br
char *s, *format;
.sp 2
.in -5
.bd
FUNCTION
.in +5
.br
.bd
Scer that will be added.  A
space character or newline terminates the input field.
.sp
.ti -1
.bd
c
.br
Character expected.  Corresponding argument should be a character pointer. 
The normal skip-over-space characters are suppressed.  Use "%ls" to
read the next non-space character.  

Corresponding argument should refer
to a character array and indicate number of characters read if a field
width is given.
.sp
.ti -1
.bd
e, f
.br
Floating point number is expected.  Next field is converted and stored
through the corresponding argument which should be a pointer to a 
.bd
float.

The format for floating point numbers is an optionally signed string
of digits that may contain a decimal point followed by an optional
exponent field consisting of E (or e), followed by an optionally signed
integer.
.bp
.ti -1
.bd
[
.br
Left bracket indicates a string not to be delimited by space
characters. The string is defined by characters followed by a right bracket.
A
.bd
^
as the first character after the left bracket defines the i.he "setbuf (3s)                  3/24/82                  setbuf (3s)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
setbuf
- assign buffering to a stream
.sp 2
.in -5
.bd
C
.in +5
.br
.bd
#include <stdio.h>
.sp
.bd 3
setbuf(stream, buf)
.br
FILE *stream;
.br
char *buf;
.sp 2
.in -5
FUNCTION
.in +5
.br
.bd
Setbuf
is used after a stream is opened, but before it is read or written to
cause the
.bd
buf
character array to be used instead of an automatically allocated buffer.

If
.bd
buf
is NULL (constant pointer), I/O is completely unbuffered.

Size of array is determined by a the constant, BUFSIZ.  An example:
.sp
.ce
.bd
char buf[BUFSIZ];
.sp
A buffer is obtained from
.bd
alloc
(3) upon the first 
.bd
getc
or
.bd
putc
on the file.  One exception is when the standard output is directed
to a terminal, in which case it is line buffered.  Normally, output
streams directed to terminals and
.bd
stderr
(standard error stream) are not buffered. 

When standard output is line bunput field
as all characters in the set of characters following the 
.bd
^ 
sign.  Absence of this sign means the input field is all the 
characters within the brackets.  Corresponding argument must point to
a character array.
.sp 2
.in -4
The conversion characters
.bd
d, o
and
.bd
x
may be either capitalized or preceded by an
.bd
l
to indicate that a pointer to
.bd
long
rather than
.bd
int
is in the argument list. If these are preceded by
.bd
h,
indicates a pointer to 
.bd
short
rather than
.bd
int.

The
.bd
e
and
.bd
f
conversion characters may also be capitalized or preceded by
.bd
l
to indicate a pointer to
.bd
double
rather than
.bd
float.

.bd
Scanf
returns the number of input items successfully matched and assigned.
This may also be used to decide how many items were actually found.
The constant end of file is returned upon end of input.  This is different
from 0, which may be interpreted to mean no conversion was done.  
If conversion was intended, it was frustrated by an inappropriate 
character in tffered, it is flushed by
.bd
read
(2) each time data is read from the standard input.
.sp 2
.in -5
.bd
ERRORS
.in +5
.br
By default, the standard error stream should be line buffered.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
fopen (3), getc (3), putc (3), alloc (3)
er and the % character.

.in -4
The control string usually contains conversion specifications that
direct interpretation of the next input field.  Unless assignment
suppression was indicated (using the * character), the result is placed
in the varia.he "stdio (3s)                    3/22/82                  stdio (3s)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINES
.in +5
.br
.bd
stdio
- standard buffered I/O package
.sp 2
.in -5
.bd
C           
.in +5
.br
.bd
#include <stdio.h>
.sp
.bd
FILE *stdin;
.br
.bd
FILE *stdout;
.bd
.br
FILE *stderr;
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
This section describes two levels of buffered input/output utilities:
1) in-line macros designated by (3), and 2) higher level standard I/O
utilitiehe input.  As an example:
.sp
.in +8
.bd 2
int i; float x; char name[50];
.br
scanf("%d%f%s", &i, &x, name);
.sp
.in -8
with the input
.sp
.in +8
.bd
25 54.32E-1 McCleary
.sp
.in -8
assigns to
.bd
i
the value 25, 
.bd
x
the value 5.432.  Name contains "mccleary\0". Another example:
.sp
.in +8
.bd 2
int i; float x; char name[50];
.br
scanf("%2d%f%*d%[1234567890]", &i, &x, name
.sp
.in -8
with the input
.sp
.in +8
.bd
56789 0123 56a72
.sp
.in -8
assigns 56 to
.bd
i,
789.0 to
.bd
x,
skips "0123" and places the string "56\0" in 
.bd
name.
The next call to
.bd
getchar
will return "a".
.bp
.in -5
.bd
ERRORS
.in +5
.br
The success of matches and suppressed assignments can be determined
only indirectly.
.sp 2
.in -5
.bd
NOTES
.in +5
.br
In cases of missing or illegal data,
.bd
scanf
returns an end of file on end of input.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
atof (3), getc (3), printf (3)


e that is already busy.
.bp
.ti -5
.nf
.bd
17	EEXIST	File exists
.fi
The new file name passed to
.bd
link
or
.bd
mknod
is alreas designated by (3s) or (3m).

The in-line macros,
.bd
getc
and
.bd
putc
handle characters quickly.

Routines such as
.bd
gets, fgets, printf, fprintf, fwrite, fread, puts
and
.bd
scanf
and
.bd
fscanf
use the in-line macros; both levels may be freely intermixed.

Files with this type of associated buffering are called
.bd
streams
and are declared to be a pointer to a defined type
.bd
FILE.  Fopen
(3) has the ability to create descriptive data for streams.  It
returns a pointer to designate the stream in all further transactions.
Normally, there are three open streams with constant pointers declared 
in the 
.bd
include 
file associated with a standard open file:
.sp
.in +4
.bd 
stdin
- standard input file
.br
.bd
stdout
- standard output file
.br
.bd
stderr
- standard error file
.sp 2
.in -4	
A constant "pointer" (NULL 0) designates no stream.
.sp
An integer constant (end of file, or EOF -1) is returned upon error by any 
integer functions that deal with streams or upon end of file.

Routines that use the I/Ohe exit status of the shell.
.sp 2
.in -5
.bd
ERRORS
.in +5
.br
An exit status of 127 means the shell could not be executed.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
popen (3), exec (2), wait (2)d
fscanf
use the in-line macros; both levels may be freely intermixed.

Files with this type of associated buffering are called
.bd
streams
and are declared to be a pointer to a defined type
.bd
FILE.  Fopen
(3) has the ability to create descriptive data for streams.  It
returns a pointer to designate the stream in all.he "ttyname (3)                  3/24/82                  ttyname (3)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
ttyname, isatty, ttyslot
- find name of a terminal
.sp 2
.in -5
.bd
C
.in +5
.br
.bd
char *ttyname(fildes)
.sp
.bd
isatty(fildes)
.sp
.bd
ttyslot()
.sp 2
.in -5
.bd
FUNCTION
.in +5
.br
.bd
Ttyname 
returns a pointer to the null-terminated path name of
the terminal associated with
.bd
fildes,
the file descriptor.

.bd
Isatty
returns a 1 if the file des package must have the header file 
with the pertinent macro definitions (<stdio.h>).  The 
.bd
include
file declares all functions and constants described in the sections
designated by (3s); they need no further declaration.
.bp
The following constants and functions are used as macros:
.sp
.in +8
.bd
feof  ferror  fileno  getc  getchar  putc
.in -8
.sp
It is dangerous to redeclare these names.
.sp 2
.in -5
.bd
ERRORS         
.in +5
.br
The
.bd
EOF
value is consistently returned, indicating that a 
.bd
FILE 
pointer has not been initialized with 
.bd
fopen.
This means that input or output has been attempted on an output 
or input stream, or that a 
.bd
FILE
pointer designates corrupt
.bd
FILE
data.

This use of the standard library has been changed to line buffer output
to a terminal by default.  It attempts to flush the output whenever a
.bd
read
(see Section 2) from the standard input is necessary.  In most 
cases, this makes the utility more efficient.  The actions 
themselves should be transparent unlesscriptor is associated with a terminal; 
a 0 is returned if it isn't.

.bd
Ttyslot
returns the number of the entry in the
.bd
ttys
file (see Section 5) for the control terminal of the current process.
.sp 2
.in -5
.bd
ERRORS
.in +5
.br
.bd
Ttyname
returns a 0 (NULL pointer) if the file descriptor does not describe
a terminal that exists in the "/dev" directory.

.bd
Ttyslot
returns a 0 if the "/etc/ttys" directory is inaccessible, or if
it can't determine the control terminal.
.sp 2
.in -5
.bd
NOTES
.in +5
.br
Return values point to static data whose content is overwritten
by each call.
.sp 2
.in -5
.bd
FILES
.in +5
.br
/dev/*
.br
/etc/ttys
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
??ioctl (2), ttys (5)ut file
.br
.bd
stdout
- standard output file
.br
.bd
stderr
- standard error file
.sp 2
.in -4	
A constant "pointer" (NULL 0) designates no stream.
.sp
An integer constant (end of file, or EOF -1) is returned upon error by any 
integer functions that deal with streams or upon end of file.

Routines that use the I/O it
is used with programs which use standard I/O routines 
.ul
and
.bd
read
(2) to read from the standard input. 

When large amounts of computation are done after outputting part of a line
to a terminal, it is necessary to
.bd
fflush
(3) the standard output before continuing on so that the output appears.
.sp 2
.in -5 
.bd
ALSO READ
.in +5
.br
close (2), open (2), read (2), write (2)eld
width is given.
.sp
.ti -1
.bd
e, f
.br
Floating point number is expected.  Next field is converted and stored
through th.he "system (3)                   3/24/82                   system (3)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
system
- issue a shell command
.sp 2
.in -5
.bd
C
.in +5
.br
.bd 2
system(string)
.br
char *string;
.sp 2
.in -5
.bd
FUNCTION
.in +5
.br
.bd
System
causes
.bd
string
to be given to
.bd
sh
(see shell - Section 1) as input just as if the string had been typed as
a command at a terminal.  Current process waits until the shell
has completed then returns t.he "floor (3m)                   3/22/82                   floor (3m)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
fabs, floor, ceil
- absolute value and floor and ceiling functions
.sp 2
.in -5
.bd
C          
.in +5
.br
.bd 2
double floor(x)
.br
double x;
.sp
.bd 2
double ceil(x)
.br
double x;
.sp
.bd 2
double fabs(x)
.br
double x;
.sp 2
.in -5
.bd
FUNCTION    
.in +5
.br
.bd
Fabs
returns the absolute value 
.bd
|x|.

.bd
Floor
returns the largest integer not greater than
.bd
x.

.bd
Ceil
returns the smallest integer not less than 
.bd
x.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
abs (3)
ttys
file (see Section 5) for the control terminal of the current process.
.sp 2
.in -5
.bd
ERRORS
.in +5
.br
.bd
Ttyname
returns a 0 (NULL pointer) if the file descriptor does not describe
a terminal that exists in the "/dev" directory.

.bd
Ttyslot
returns a 0 if the "/etc/ttys" directory is inaccessible, or if
it can't determine the control terminal.
.sp 2
.in -5
.bd
NOTES
.in +5
.be used as 
an input filter,
the type "w" as an output filter.


.in -5
.bd
ERRORS     
.in +5
.br
.bd
Popen
returns a 0 (NULL pointer) if the shell cannot be accessed, or if 
files or processes cannot be created. 

.bd
Pclose 
returns -1 if 
.bd
stream 
is not associated with a command opened by 
.bd
popen.


.in -5
.bd
NOTES
.in +5
.br
Filter input may be badly positioned if user attempts
buffered reading before opening an input filter. 

Similar problems 
with an output filter may be prevented by flushing the buffer, i.e., using
.bd
fflush. 
[See 
.bd
fclose
(3).]


.in -5
.bd
READ ALSO
.in +5
.br
pipe (2), fopen(3), fclose (3), system (3), wait (2)scribed in the sections
designated by (3s); they need no further declaration.
.bp
The following constants and functions are used as macros:
.sp
.in +8
.bd
feof  ferror  fileno  getc  getchar  putc
.in -8
.sp
It is dangerous to redeclare these names.
.sp 2
.in -5
.bd
ERRORS         
.in +5
.br
The
.bd
EOF
value is consistently returned, indicating that a 
.bd
FIL.he "perror (3)                   3/23/82                   perror (3)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
perror                        
- system error messages
.sp 2
.in -5
.bd
C
.in +5
.br
.bd 2
perror(s)
.br
char *s;
.sp 2
.in -5
.bd
FUNCTION
.in +5
.br
.bd
Perror
displays error messages on the error file.  These messages describe the
last error encountered during a C program system call.  The
.bd
s
argument string is printed, followed by a colon, the message and a
newline.  The argument string defines the name of the program in
which the error occurred.  The message is taken from
.bd
errno
(see Introduction to Section 2), which is set when errors have occurred
but have not been cleared.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
Intro (2)
criptor does not describe
a terminal that exists in the "/dev" directory.

.bd
Ttyslot
returns a 0 if the "/etc/ttys" directory is inaccessible, or if
it can't determine the control terminal.
.sp 2
.in -5
.bd
NOTES
.in +5
..he "printf (3s)                  3/22/82                  printf (3s)" 
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
printf, fprintf, sprintf
- formatted output conversion

.in -5
.bd
C        
.in +5
.br
.bd
# include <stdio.h>
.sp
.bd 2
printf(format [, arg]...)
.br
char *format;
.sp
.bd 3
fprintf(stream, format [, arg] ...)
.br
FILE *stream;
.br
char *format;
.sp
.bd 2
sprintf(s, format [, arg ] ...)
.br
char *s, format;
.sp 2
.in -5
.bd
FUNCTION
.in +5
.br
.bd
Printf
places output on
.bd
stdout
- the standard output stream.

.bd
Fprintf
places output on
.bd
stream
- the named output.

.bd
Sprintf
places output in the
.bd
s
string.  This string is followed by a "\0" character.

These functions convert, format and print their arguments under the
control of the first argument.  This first argument will be a character
string containing 1) plain characters that are copied to the output
stream, and 2) conversion specifications which enable conversion
and printing of th.he "popen (3)                    3/23/82                    popen (3)"
.fo "                               -#-"  
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
popen, pclose
- initiates I/O to/from a process


.in -5
.bd
C       
.in +5
.sp
.bd
# include <stdio.h>
.sp
.bd 2
FILE *popen(command, type)
.br
char *command, *type;
.sp
.bd 2
pclose(stream)
.br
FILE *stream;


.in -5
.bd
FUNCTION   
.in +5
.br
The arguments to 
.bd
popen 
are pointers to null-terminated strings.  These strings contain: 
1) a shell command line
and 2) an I/O mode, either "r" for reading or "w" for writing.
A pipe is created 
between the calling process and the command to be executed.
The value returned is a stream
pointer that may be used to write to the 
standard input of the command or to read from its standard output.

Streams opened by 
.bd
popen 
are closed by 
.bd
pclose.  Pclose 
waits for the associated process to terminate, then returns the exit 
status of the command.

Since open files are shared, the type "r" command can e next
.bd
printf
argument.

The conversion specifications are introduced by the
.bd
%
character.  The options listed below may follow this character:
.sp 2
.in +4
A minus sign (-) specifying 
.ul
left adjustment
of the converted value in the indicated field.

A string of digits specifying
.ul
field width.
Converted values with fewer characters than the indicated field
width may be blank-padded to make up the difference, unless the
field width begins with a 0, in which case it will be zero-padded.

A period (.) may separate the field width from the next string of digits.

An additional digit string may be added specifying a
.ul
precision,
or the number of digits that will appear after the decimal point.  This
is used for
.bd
-e
and 
.bd
-f
conversions, or to specify the maximum number of characters
to be printed from a string. [An asterisk (*) may indicate
field width or precision, in which case an integer argument
indicates the field width or precision.]

A
.bd
1
may be specified with
.bd
d, o, x,    
or
.bd.he "djdma (4)                   9/27/82                     djdma (4)"
.fo "                             -#-"
.in 5
.rm 65
.bd
NAME
.br
.in +5
.bd
djdma 
- Morrow Designs Disk Jockey Direct 
.nf
        Memory Access floppy disk controller
.fi


.ti -5
.bd
DESCRIPTION 
.br
The Morrow Designs DJDMA is an S-100 floppy disk drive 
controller.
This document describes the Micronix driver for the DJDMA.
All access to the DJDMA is handled by the driver.

The DJDMA provides
access to up to eight 8 inch and/or 5 1/4 inch floppy disk drives
(limited to four of each type).
At present, there may be only one controller board per system.

Currently supported formats are:
IBM format 8" floppies,
10 hole hard sector 5" floppies,
and many formats of soft-sectored 5" floppies.

Diskettes used with Micronix must be formatted.

The following formats are supported.  They are
listed with the number of blocks per disk 
(a block is 512 bytes).
.nf


    8",   128 byte sectors, single-sided,  487 blocks
    8",   128 byte sectors, d
u
to indicate correspondence with a long integer argument.  The
same thing may be accomplished with a capitalized conversion code.

Any character may be given that specifies the type of conversion 
to be executed.
.in -4
.sp 2
The conversion characters are listed and described below:
.sp 2
.in +4
.ti -1
.bd
dox
.br
Integer
.bd
arg
is converted to decimal, octal or hexadecimal notation.
.sp 2
.ti -1
.bd
f
.br
Float or double
.bd
arg
is converted to decimal notation in the following format:

.ce
.bd
[-]ddd.ddd

The precision specification determines the amount of "d"s.  A 
precision of 0 results in no digits; default is
six digits.
.sp 2
.ti -1
.bd
e
.br
Float or double
.bd
arg
is converted in the following format:

.ce
.bd
[-]d.ddde+dd

One digit before and one number after the decimal point equal the
precision specification. By default, six digits are produced.
.sp 2
.ti -1
.bd
g
.br
Float or double
.bd
arg
is printed in one of the formats listed above, depending upon which one
specifies full precision in thouble-sided,  975 blocks
    8",   256 byte sectors, single-sided,  975 blocks
    8",   256 byte sectors, double-sided, 1950 blocks
    8",   512 byte sectors, single-sided, 1125 blocks
    8",   512 byte sectors, double-sided, 2250 blocks
    8",  1024 byte sectors, single-sided, 1200 blocks
    8",  1024 byte sectors, double-sided, 2400 blocks

    5 1/4",  256 byte sectors, single-sided, 35 track,  160 blocks
    5 1/4",  512 byte sectors, single-sided, 35 track,  330 blocks
    5 1/4",  512 byte sectors, double-sided, 35 track,  660 blocks

    5 1/4",  512 byte sectors, single-sided, 40 track,  380 blocks
    5 1/4",  512 byte sectors, double-sided, 40 track,  760 blocks

    5 1/4",  512 byte sectors, single-sided, 80 track,  780 blocks
    5 1/4",  512 byte sectors, double-sided, 80 track, 1560 blocks


.fi
Note that because of reserved tracks (usually the 
first two), the available space is reduced slightly.

All 8 inch formats are standard 77 track.

While you gain approximately 7% in additional
cape least amount of space.
.bp
.ti -1
.bd
c
.br
Character
.bd
arg
printed; NULL characters are ignored.
.sp
.ti -1
.bd
s
.br
Character
.bd
arg
is defined as a character pointer; string characters are printed up
to a NULL character, or if specified, up to point indicated by
the precision specification.
.sp 2
.ti -1
.bd
%
.br
Only the
.bd
% 
is printed; arguments are not converted.
.sp 2
.in 0
.in 5
.bd
NOTES
.in +5
.br
Small or non-existent fields do not cause truncation.  Fields are
padded when the specified field exceeds the actual width.

Fields larger than 128 characters will fail.

.bd
Putc
(3) prints the characters generated by
.bd
printf.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
putc (3), scanf (3), ecvt (3)

a character array.
.sp 2
.in -4
The conversion characters
.bd
d, o
and
.bd
x
may be either capitalized or preceded by an
.bd
l
to indicate that a pointer to
.bd
long
rather than
.bd
int
is in the argument list. If these are preceded by
.bd
h,
indicates a pointer to 
.bd
short
rather than
.bd
int.

The
.acity with 1024 byte sectors on an 8 inch floppy diskette, 
the loss in transfer speed is considerable.

The optimum choice for Micronix floppy diskettes
is 512-bytes, single or double sided, unless
space considerations dictate otherwise.

The other formats are included for backward compatibility.

Alternate sectoring is optional and available by selecting
the appropriate minor device number from the table below.

Bit 4 of the minor device number selects
alternate sectoring.


(Alternate sectoring is recommended because
it doubles the reading speed, but does not make much
difference in writing speed.)

Note that alternate and non-alternate sectored media
are incompatible (i.e., the sectors appear scrambled).
The 
.bd
far 
utility (see Section 1) can read a CP/M formatted
diskette under either alternate or straight sectoring, however.


The sector arrangement schemes fall into classes
for even and odd sector per track values.

The sectors are numbered

0, 2, 4, 6, 8, 10, 12, 14, 1, 3, 5, 7, 9, 11, 13, 15

for drive type
is encoded in bits 4 and 5 of the minor device number.


.ti -5
EXAMPLES
.br

For a SA800 drive "A" with alternating sectoring
the minor device number would be 8.

For a SA850 drive "A" with alternating sectoring
the minor device number would be 24.

For a SA200 drive "A" with alternating sectoring
the minor device number would be 28.


To create an appropriate special file for an SA200 (5 1/4" drive),
the command would be:

	mknod /dev/mfa b 2 28


.ti -5
.bd
SEE ALSO
.br
mknod (1), far (1), fdj (1)

Disk Jockey / Direct Memory Access Floppy Disk Controller Technical Manual
her device was attempted.

.ti -5
.nf
.bd
19	ENODEV	No such device
.fi
An attempt was made to open a non-existent device.

.ti -5
.nf
.bd
20	ENOTDIR	Not a directory
.fi
A non-directory was specified where a directory was required,
as an intermediate component in a path name, for example, or
as an argument to
.bd
chdir
.

.ti -5
.nf
.bd
21	EISDIR	Is a directory
.fi
An attempt was made to write on a directory.

.ti -5
.nf
.bd
22	a 15 sector per track disk (for instance).

and

0, 2, 4, 6, 1, 3, 5, 7

for an 8 sector per track disk.

The major and minor device numbers listed below are
used in conjunction with the mknod program.

See mknod in section 1 of the Micronix reference manual.


The major device number corresponding to the DJDMA is
currently 2.

The minor device numbers have the following meanings:
.nf

	minor	meaning

	 0	8" - drive 0
	 1	8" - drive 1
	 2	8" - drive 2
	 3	8" - drive 3

	 4	5 1/4" - drive 0
	 5	5 1/4" - drive 1
	 6	5 1/4" - drive 2
	 7	5 1/4" - drive 3

	 8	8" - drive 0 with alternate sectoring
	 9	8" - drive 1 with alternate sectoring
	10	8" - drive 2 with alternate sectoring
	11	8" - drive 3 with alternate sectoring

	12	5 1/4" - drive 0 with alternate sectoring
	13	5 1/4" - drive 1 with alternate sectoring
	14	5 1/4" - drive 2 with alternate sectoring
	15	5 1/4" - drive 3 with alternate sectoring


.fi
Note that there are 96-track 5 1/4" drives and 48-track 5 1/4" drives.
For example, if you have only 48 tr.he "multio (4)                   12/2/82                   multio (4)"
.fo "                               -#-"
.in 10
.rm 65
.bd  
.ti -5
NAME
.br
.bd
multio 
- Morrow Designs MULT/IO board interface


.ti -5
.bd
DESCRIPTION
.br
The Micronix  
.bd
MULT/IO
interface supports all features of the
MULT/IO and Wunderbuss I/O boards.
It will run unchanged in rack mount or table top models of the Decision I.

Serial ports and both Diablo and Centronics style parallel
parallel protocols are supported.
A cable adapter (available from Morrow Designs)
is required to use the MULT/IO with a 
Centronics style parallel interface.

The MULT/IO board has three ACEs (Asyncronous Communication
Elements) and 1 parallel port for I/O device connection. 
The ACEs communicate via standard RS232 serial interface.
The parallel port is a standard Diablo (50-pin daisy-wheel) interface.

Each MULT/IO board must have its I/O port addresses set by means of
switches on the circuit board.  For proper operation, the base I/O 
address must back drives, you cannot 
read 96-track diskettes.

There are five different
sets of delay constants available
for stepping delay and head settle delay.
The delay numbers for step time and head settle time
were taken from real-world drive descriptions
and are intended to be appropriate for the drive
types listed below.

If you are using a drive not listed below,
you should select the ones most closely suited to the 
types of drives you are using.


Refer to the following table:


	seek	settle	minor	type
	
	 8	 8	 0	SA 800		(8" drives)
	 3	15	16	SA 850


	 5	15	 0	Tandon
	20	20	16	SA 200		(5 1/4" drives)
	40	10	32	SA 400



The column entitled "seek" gives the seek time in milliseconds per track.
"settle" is the disk drive head settle time in milliseconds.
"minor" is the minor device addend, and "type" gives
manufacturers drive types.
"SA" stands for Shugart Associates.

To select a particular drive type, add in the value listed in
the "minor" column of this table.

If you are familiar with binary notation, the e 48 (hex) for the first MULT/IO board.

In a Micronix system in which there are possibly many MULT/IO boards,
the boards form a series.  In the Decision I Table Top model, the
Wunderbuss I/O motherboard functions as the first of the series.
Micronix expects to find the Mult/IO boards (or Wunderbuss) as
I/O (hex) locations 48, 58, 68, 78.
The current incarnation of the Micronix Mult I/O drivers
supports at most 4 Mult I/O boards (or 1 Wunderbus I/O and 3 Mult I/O boards).

In the following we talk about "minor device numbers".

Use "mknod" to create a new special file with a particular
minor device number.

Use "ls -l" to view the minor device numbers of existing
files.

Minor device numbers 0-3 
refer to the Mult/IO board addresses at I/O location 48 hex.

Minor device numbers 4-7 refer to the Mult/IO board addresses at 
location 58 hex, and so on with 68, 78.

The first minor device number of each group of four refers to 
the parallel printer on that board.
Minor device numbers 0, 4, 8, etc. refer to parally (4) - Description the tty interface.

mknod (1) - Make a new special file.

ls (1) - List files (including major/minor device numbers).
ettle delay.
The delay numbers for step time and head settle time
were taken from real-world drive descriptions
and are intended to be appropriate for the drive
types listed below.

If you are using a drive not listed below,
you should select the ones most closely suited to the 
types of drives you are using.


Refer to the following table:


	seek	settle	minor	type
	
	 8.in 5
.rm 65
.he "null (4)                    6/25/82                      null (4)"
.fo "                              -#-"
.bd
NAME
.in +5
.br
.bd
null 
- the null device
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
The null device has the curious property that
everything written to it is completely ignored and thrown away.
Reading from this device yields
an end of file every time.

The minor device number is ignored.
The major device number is zero in the current
implementation.

This device may seem to be ofel printers.

If the 16's bit is set in the minor device number, then
the port will be treated as a Centronics rather than 
Diablo parallel interface.
Minor device numbers 16, 20, 24, and 28 refer to Centronics
parallel ports on the four MULT/IO boards.

You may mix Diablo and Centronics style
parallel interfaces in the same system.
It is possible to run Centronics interface printer(s)
and Diablo interface printer(s) concurrently.

Sending data to the Mult I/O is fairly straightforward
except for the case of the Diablo parallel interface.

Here the parallel data path is wider than one byte.
In order to pass data to the driver through a byte
stream, a special format was developed.

A conversion filter
is provided which is capable of encoding an ordinary
text file into a form suitable for the driver.

Bytes sent to the parallel printer device have the following format:

.in +3
Each byte is stand-alone and has a meaning all by itself.

Bit-0 is the least significant bit and bit-7 is the most significant
bit in t limited usefulness,
but don't get rid of it, the shell uses it
to set up the standard input of background processes.
.sp 2
.in -5
.bd
EXAMPLE
.in +5
.ti +5
.br
cat file > /dev/null

To read a file but discard the results.
ection. 
The ACEs communicate via standard RS232 serial interface.
The parallel port is a standard Diablo (50-pin daisy-wheel) interface.

Each MULT/IO board must have its I/O port addresses set by means of
switches on the circuit board.  For proper operation, the base I/O 
address must b.in 5
.rm 65
.he "io (1)                       7/19/82                       io (1)"      
.fo "                               -#-"
.bd
NAME
.in +5
.bd
io 
- Z80 I/O space device
.sp 2
.in -5
.bd
DESCRIPTION
.br
.in +5
Under a multi-user operating system, it is not acceptable
to allow user programs to execute certain instructions
in an unregulated way.  
The Z80 instructions "in" and "out" fall into this category.
It is, however, desirable to be able to perform these operations
in special circumstances.

Thhis discussion.

There are two types of information one can send to the 
printer, motion commands and print commands.

If bit-7 is clear, the the byte is taken to mean a character to be
printed.
Otherwise,
if bit-7 is set, the byte indicates a motion command.

If bit-6 is set, the byte indicates vertical motion.

If bit-5 is set, the byte indicates backwards motion
(up or left).

Bits 0 - 4 (the low order 5 bits) are taken to be the magnitude of motion
desired.
.in -3

The unit of motion is 1/120" for horizontal motion and
1/48" for vertical motion.

If you want to move farther than 31 increments,
you must send a series of motion bytes.

These are accumulated and optimized, then sent all at once.

Note that this scheme allows elaborate high-level interface.
Even several different interfaces, each
with its own set of escape sequences or what have you, all translate
to common Mult/IO parallel printer motion and print byte formats.


.ti -5
.bd
SEE ALSO
.br
diablo (1) - Diablo parallel high level conversion.

tte "io" device allows users to access the Z80 I/O ports
through the file system.
Reading from the device causes the results of "in" instructions
to be transferred to the user's memory space.

Writing to the device causes "out" instructions to be executed
using the data in the user's memory space.

Seeking on the device sets the I/O address for subsequent
reading/inputting or writing/outputting.

There are two classes of I/O device.
One allows access to all of I/O space.
The other allows access only to a single port.

Note that it would be extremely easy to crash the system
through this avenue, and it is therefore
recommended that the "/dev/io" file be heavily protected,
perhaps mode 0 and owned by root.

Examples are in order:
.sp
.in +5
To input a value from port 10:
.sp
.nf
.bd
	f = open ("/dev/io", 0);

	seek (f, 10, 0);

	read (f, &data, 1);
.sp
.in -5
.fi
The operation of the I/O device is dependent on the minor
device number of the special file associated with it.

All 256 possible minor device numbers ( drive B is called "hdb", etc.
The major/minor device numbers are:

.ti +5
.nf
1/0  hda      1/1  hdb      1/2  hdc      1/3  hdd
.fi

Unlike the HDDMA drives, Micronix can automatically detect
the size of the HDCA drives, so there is no need to indicate
the drive size in the device name or number.

Micronix does not support a disk formatting program, so
each drive must be formatted under CP/M.
A sector skew of 6 is recommended, but is not critical.
Since these drives are soft-sectored, there is no
compatibility problem with different skews.
emely easy to crash the system
through this avenue, and it is therefore
recommended that the "/dev/io" file be heavily protected,
perhaps mode 0 and owned by root.

Examples are in order:
.sp
.in +5
To input a value from port 10:
.sp
.nf
.bd
	f = open ("/dev/io", 0);

	seek (f, 10, 0);

	read (f, &data, 1);
.sp
.in -5
.fi
The operation of the I/O device is dependent on the minor
device number of the special file associated with it.

All 256 possible minor device numbers (0 - 255) have meaning.

When accessed through minor device zero, it is possible to
select which I/O ports you access.
This is the meaning of a seek on the io device file.
For example, seeking to location 87 will cause subsequent
reads and writes to the file to be interpreted as references
to io port 87.

Unlike other devices, the file offset does not progress
with reads and writes.
It may only be changed by seeking.
It was thought that this arrangement was more in the spirit
of I/O space accesses than the more Micronix-like alternative.

Non-zero minor device numbers limit access to that one I/O port
whose address is the same as the minor device number.
It is therefore possible to have I/O space
selectively protected, while giving any user access
to some certain port.

For example, if you wanted to allow free access to ports
77 and 78 by any user on the system, you would issue the following
commands:

	mknod /dev/io77 c 3 77

	mknod /dev/io78 c 3 77

	chmod a=rwx /dev/io77 /dev/io78


If the minor device numb.he "hddma (4)			 8/6/82			     hddma (4)"
.fo "                             -#-"
.in 5
.rm 65
.bd
DEVICE
.br
.in +5
.bd
HDDMA
- Morrow Designs' dma hard disk controller


.in -5
.bd
FUNCTION
.in +5
.br
The HDDMA controls up to four 5 1/4 inch Winchester disk drives.
Micronix currently supports 3 drive sizes:

.in +5
.nf
m5      5 megabytes
m10     10 megabytes
m16     16 megabytes
.in -5
.fi

The device names (in the /dev directory) for these disks
depend on their position on the HDDMA daisy-chain.
An m5 attached as drive A is called "m5a", an m16 attached
as drive D is called "m16d", etc.
The major/minor device numbers are as follows:

.in +5
.nf
3/0  m5a        3/4  m10a       3/8  m16a
3/1  m5b        3/5  m10b       3/9  m16b
3/2  m5c        3/6  m10c       3/10 m16c
3/3  m5d        3/7  m10d       3/11 m16d
.in -5
.fi

Micronix does not support a disk formatting program, so each
drive must be formatted under CP/M. A sector skew of 6 is
recommended, but is not critical. Since these drives are
soft-sectorer is not zero, seeks are simply ignored.


.in -5
.bd
FILES
.in +5
.br
/dev/io - the device file
pass data to the driver through a byte
stream, a special format was developed.

A conversion filter
is provided which is capable of encoding an ordinary
text file into a form suitable for the driver.

Bytes sent to the parallel printer device have the following format:

.in +3
Each byte is stand-alone and has a meaning all by itself.

Bit-0 is the least significant bit and bit-7 is the most significant
bit in t.he "hdca (4)			 8/6/82			      hdca (4)"
.fo "                             -#-"
.in 5
.rm 65
.bd
DEVICE
.br
.in +5
.bd
HDCA
- Morrow Designs' Winchester disk controller


.in -5
.bd
FUNCTION
.in +5
.br
The HDCA controls up to four 8 inch Winchester disk drives.
Micronix currently supports 3 drive sizes:

.in +5
.nf
m10	10 megabytes
m20	20 megabytes
m26	26 megabytes
.in -5
.fi

The device names (in the /dev directory) for these disks
depend on their position on the HDCA daisy-chain.
Drive A is called "hda",ed, there is no compatibility problem with
different skews.

If you ever have to explore the surface of one
of these drives without the intervention of Micronix,
you should know that Micronix logically "rolls" the tracks
by (number of tracks) / 2. Thus on an m5, which has 153
tracks, logical track 0 is physical track 76.
The reason for this is that most Micronix systems have
only one hard disk, which must serve as both the root
device and the swap device. When Micronix sees that
rootdev == swapdev, it uses the space above the file
system as swap space. Thus, the logical disk looks like:

.in +5
.nf
 ilist           file space             swap space
|-------|-----------------------------|------------|

.ti -5
while the physical disk looks like:

 file space   swap space   ilist     file space
------------|------------|-------|-----------------
.in -5
.fi

In a busy system, the disk heads spend most of their time
over the swap space and the ilist, so this gives a
performance advantage.
space accesses than the m length of 25 feet (although much longer
cables have been known to work). The parallel cables can be made
with 50 conductor flat cable. They both have a 50 pin female
flat cable connector (Ansley 609-5000M) on the computer end. Cable 6
has the same connector on the the printer end, while cable 5 uses
a 36 pin female ribbon connector (Amphenol 57-40360).


.bp
.ti -5
DECISION TO SERIAL PRINTER OR TERMINAL
.br
The  cable required to comunicate with a terminal or printer  can
be  constructed so that it will work with both the Decision and
the MULTIO board. This  assumes  that  the   hardware
handshaking  on the printer is via pin 20. (Most printers  support
this. One exception is the NEC Spinwriter, which uses pin 19 instead.)

The Decision's serial ports cannot be jumpered.
On the MULTIO, the appropriate serial port
should be jumpered as follows:

.nf
         --------------------
        |                    |
        |  A  B  C  D  E  G  |
        |  |  |  |  |  |  |  |
        |  H  I  J  K  L  N  |
        .in 5
.rm 65
.he "mem (4)                    6/25/82                        mem (4)"
.fo "                              -#-"
.bd
DEVICE
.in +5
.br
.bd
mem
- core memory device
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
This device reads and writes kernel memory (addresses 0 to FFFF).
One must be exceedingly careful in protecting this device,
since there are several hardware registers in this address range
that will crash the system upon being read.
sks
depend on their position on the HDDMA daisy-chain.
An m5 a.in 10
.rm 79
.he "          cables (1)                     4/6/83                      cables (1)
.fo "                                          -#-"
.ta 5
.ti -5
NAME
.br
.bd
cables
- cables for modems, terminals, printers, and the network

.ti -5
DESCRIPTION
.br
This document tells you how to build cables
to connect the Decision to various devices.
The presentation is rather technical.
If you don't want to build one of these cables yourself,
you may purchase it from your dealer or from Morrow,
or your de|                    |
         --------------------
.fi

The cable requires 22 guage shielded 8 conductor wire.
The pinout for both the MULTIO and the Decision is the same:

.nf
         ---------------------------
        |         DECISION          |
        |     DB-25P connector      |
        |                           |
        |  1  2  3  7  5 6 8   20   |
        |  |  |  |  |   \|/    |    |
        |  |  |  |  |    |    /|\   |
        |  1  2  3  7    20  5 6 8  |
        |                           |
        |     DB-25P connector      |
        |    PRINTER or TERMINAL    |
         ---------------------------
.fi

Note: For most terminals, only pins 2, 3, and 7 need
be connected.
The cable described here has the advantages of working
interchangablly with printers and terminals, and of
higher reliability at high baud rates.


.bp
.ti -5
NETWORK
.br
The Micronix network uses the serial ports on the Decision
or the MULTIO. Since the first priority in
designing this network was low cost, a simple aler may be able to build it for you from these specifications.

The first three serial ports on the Decision
use the Wunderbus I/O motherboard, which
(unlike the MULTIO expansion board) has  no  provisions   for
configuring the RS-232 connections via jumpers.
Thus the cables must do this configuration internally.
Also, the Wunderbus has an artwork error which
assigns pin 5 as Carrier-Detect (RLSD) and pin 8 as Clear-To-Send
(CTS).  The cables detailed below take this into account.

Four serial cables and two parallel cables are discussed:

        1. Decision to serial printer or terminal
        2. Decision to Decision (network)
        3. Decision to modem
        4. MULTIO to modem

        5. Decision to Centronics-compatible parallel printer
        6. Decision to Diablo-compatible parallel printer

In general, the serial cables require two DB-25P male connectors
(ITT Cannon or AMP) with shielded shells on both ends, and should
be made with 22 guage shielded wire. The RS-232 standard
specifies a maximumunshielded
3 conductor cable is specified.
(The network does extensive error checking, so noise on the
cable will only slow it down.)
The MULTIO should be jumpered as for #1 above.
The cable should be constructed as follows:

.nf
         ----------------------
        |  Decision or MULTIO  |
        |                      |
        |   DB-25P connector   |
        |       2  3  7        |
        |       |  |  |        |
        |       3  2  7        |
        |   DB-25P connector   |
        |                      |
        |  Decision or MULTIO  |
         ----------------------
.fi


.ti -5
DECISION TO MODEM
.br
This requires 22 guage shielded 8 conductor wire:

.nf
         ---------------------------
        |          DECISION         |
        |      DB-25P connector     |
        |                           |
        |  1  2  3  5  6  7  8  20  |
        |  |  |  |  |  |  |  |  |   |
        |  1  3  2  8  6  7  5  20  |
        |                           |
        |      DB-25P connector     |
  -----------------------------------------------------

or, sorted the other way:

 ------------------------------------------------------
|                      DECISION                        |
|              50 pin flat cable connector             |
|                                                      |
|  21 37 36 39 33 40 42 43 45 26 27 3  28 2  13 12 24  |
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   |
|  1  2  3  4  5  6  7  8  9  10 11 12 13 16 31 32 36  |
|                                                      |
|            36 pin female ribbon connector            |
|            CENTRONICS-COMPATIBLE PRINTER             |
 ------------------------------------------------------
.fi


.ti -5
DECISION TO PARALLEL DIABLO
.br
This cable also works with the MULTIO expansion board,
since its parallel port is identical with the Decision's.
All you need is
a simple straight-through 50 conductor cable with 50-pin
flat cable female connectors on both ends.
It is the same cable that Morrow uses for i      |           MODEM           |
         ---------------------------
.fi

.bp
.ti -5
MULTIO TO MODEM
.br
(Note: this discussion assumes that the serial ports on the MULTIO
have been brought out to female D connectors on the back of the
computer with special cables installed at the factory. If this has
not been done, you can order these "MULTIO serial cables" from Morrow.)

Jumper  the appropriate MULTIO serial port for modem communications
as follows:

.nf
         -----------------------
        |                       |
        |  A  C  D  E  F  G  H  |
        |  |  |  |  |  |  |  |  |
        |  B  J  K  L  M  N  I  |
        |                       |
         -----------------------
.fi

The cable from the computer to the modem
requires 22 guage shielded 8 conductor wire:

.nf
         ---------------------------
        |         to MULTIO         |
        |      DB-25P connector     |
        |                           |
        |  1  2  3  5  6  7  8  20  |
        |  |  |  |  |  |  |  |  |   |
ts disk drives.
If you need to build the cable, only 17 conductors are
actually needed:

.nf
 ------------------------------------------------------
|                      DECISION                        |
|              50 pin flat cable connector             |
|                                                      |
|  2  3  12 13 21 24 26 27 28 33 36 37 39 40 42 43 45  |
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   |
|  2  3  12 13 21 24 26 27 28 33 36 37 39 40 42 43 45  |
|                                                      |
|             50 pin flat cable connector              |
|              DIABLO-COMPATIBLE PRINTER               |
 ------------------------------------------------------
.fi
ect LST:.
LST: reverts to the default (characters appear on your screen).
.in -6

.ti -5
.bd
Control characters

The control characters discussed below are
effective only when the "standard" CP/M
console I/O calls are used.
They will not be understood if the CP/M BIOS jumps
or CP/M direct I/O calls ar        |  1  2  3  5  6  7  8  20  |
        |                           |
        |      DB-25P connector     |
        |           MODEM           |
         ---------------------------
.fi


.bp
.ti -5
DECISION TO PARALLEL CENTRONICS
.br
This cable also works with the MULTIO expansion board,
since its parallel port is identical with the Decision's.
This is the most complex cable. It is available by
special order from Morrow. Its pinout is:

.nf
 ------------------------------------------------------
|                      DECISION                        |
|              50 pin flat cable connector             |
|                                                      |
|  2  3  12 13 21 24 26 27 28 33 36 37 39 40 42 43 45  |
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   |
|  16 12 32 31 1  36 10 11 13 5  3  2  4  6  7  8  9   |
|                                                      |
|            36 pin female ribbon connector            |
|            CENTRONICS-COMPATIBLE PRINTER             |
 -.he "ports (4)                    3/23/83                    ports (4)"
.fo "                               -#-"
.in 10
.rm 65
.ti -5
NAME
.br
.bd
ports
- how to identify the IO ports on the Decision I

.ti -5
DESCRIPTION
.br
The back of the Decision I has at least three "serial" ports
and at least one "parallel" port. The serial ports look like thin
sideways D's. They are called 25 pin female D connectors.
(There is a smaller 15 pin female D connector that is not used.)

The parallel ports are 50 pin "flat cable" male connectors.
The same kind of connector may also be used for disk drives, so you must
look inside the computer to tell which is which.
The connector is a parallel port if its cable goes to the
"bus board" (on the tabletop model)
or to a MULTIO board. It is a disk-drive port if
its cable goes to a disk controller.
(If you're not sure how to recognize a bus board, MULTIO board,
or disk controller, you should ask your dealer for assistance.)

Once you have identified the serial ports and parallel pts are consistently refered to as
ttyA through ttyL. (Some of the documentation that comes with the
Decision I hardware refers to ttyA as the "console" or as "serial
port 1", ttyB as "serial port 2", etc.)
Names for the parallel ports are a little more involved.
If ppr0 is connected to a parallel daisy-wheel printer, it is
called "diab0". If it is connected via a special cable
(available from Morrow)
to a Centronics type printer, it is called "cent0".

.nf
            references to       references to
IO board    serial ports        parallel port
--------    --------------      --------------
first       ttyA ttyB ttyC      diab0 or cent0

second      ttyD ttyE ttyF      diab1 or cent1

third       ttyG ttyH ttyI      diab2 or cent2

fourth      ttyJ ttyK ttyL      diab3 or cent3

.fi
These names are arbitrary, by the way: they are not built
into any program. But they are built into three other places:

.in +5
1. They appear in the /dev directory as names for device files;

2. They appear in the /etc/ttys filorts,
you should make sure that they are labeled.
Here is a stylized picture of the back of a basic tabletop
Decision I with the ports labeled:

.nf
 ---------------------------
| ************************* |
| ************************* |
 ---------------------------
            ppr0

-----------------   -----------------   -----------------
\ ************* /   \ ************* /   \ ************* /
 \ *********** /     \ *********** /     \ *********** /
   -----------         -----------         -----------
      ttyC                ttyB                ttyA

.fi
The back of a rack-mount Decision looks slightly different,
but the important thing is that on both models,
.bd
the first serial port, called ttyA, is the right-most one
(when looking at the computer from the back).

If you add a MULTIO board, its serial ports
should be labeled as follows. Make sure that the board is
plugged into the bus (with the component side of the board
facing the the front of the computer), and that three flat
cables are connecte in reference to these devices;

3. Finally, the curious program /bin/diablo (q.v.) may be linked to
a name that matches a device name in /dev. If so, it will write
to a parallel diablo printer attached to that device.
.in -5

If you want to change any of these names, make sure to change all
three occurrances.

.ti -5
.bd
SEE ALSO
.br
lpr (1), diablo (1), multio (4),
cables (4), printers (4), terminals (4),
ttys (5)
 7  5  20  |
        |                           |
        |      DB-25P connector     |
  .he "printers (4)                4/4/83                   printers (4)"
.fo "                             -#-"
.in 10
.ta 5
.rm 65
.ti -5
NAME
.br
.bd
printers
- interfacing printers to Micronix


.ti -5
INTRODUCTION

This document explains what kinds of printers are supported by Micronix,
how to plug them in, and how to test them.
This is not a stand-alone document, however. You will have to refer
to several others as you read. This will be easiest to do with the
printed version of the Micronix Reference Ming the board to three D connectors at the
back of the computer. (If you don't know how to do this,
or if you aren't sure which MULTIO is the second one,
you should ask your dealer for help.)
Stand in back of the computer and look at the MULTIO.
The three small connectors along the top of the MULTIO
are the serial "jacks"; the large one is the parallel jack.
The D connector attached
to the
.bd
right-most
(as seen from the back)
serial jack should be labeled
.bd
ttyD.
The one attached to the
.bd
middle
serial jack should be labeled
.bd
ttyE,
and the D connector attached to the
.bd
left-most
(as seen from the back)
serial jack should be labeled
.bd
ttyF.

If you have a third or fourth MULTIO, then its serial ports
should be labeled correspondingly as
ttyG, ttyH, ttyI, and ttyJ, ttyK, ttyL.

The parallel ports attached to the second, third, and fourth MULTIOs
should be labeled ppr1, ppr2, and ppr3. (Remember that
the first one was called ppr0.)

.ti -5
.bd
NAMES
.br
Under Micronix,
the twelve possible serial poranual. If you are reading
this at your terminal, you can switch to another document by hitting
DELETE or RUBOUT to get out of this one, and then typing the command
"help" followed by the new document name. The related documents are:

.ti -5
.bd
ttys (5)
.br
The document "configuration" in Section 5
(type the command "help configuration")
explains how to configure Micronix for additional printers,
automatic access from upm (the
Micronix CP/M emulator),
different baud rates, and hardware handshaking.

.ti -5
.bd
lpr (1)
.br
The document "lpr" in Section 1
(type the command "help lpr")
explains how to use the Micronix spooling program called lpr.
This allows several users to print files without conflict.

.ti -5
.bd
upm (1)
.br
The document "upm" in Section 1
(type the command "help upm")
explains (amoung many other things) how to use printers from
the Micronix CP/M emulator.

.ti -5
.bd
cables (4)
.br
The document "cables" in Section 4
(type the command "help cables")
explains how to build cables for various dee
printer wants to stop transmission, it lowers the voltage on this
wire.  To continue transmission, the voltage is raised again.
Unfortunately, there is no real standard for which wire
the printer should use.
Hardware handshaking  between  a
printer  and the Decision will probably require a special cable.

If your  printer requires hardware handshaking,
you will have to do two things:
(1) read the document "cables" in Section 4, and then make or
purchase a suitable cable, and (2) read the document "configuration" in
Section 4, and then tell Micronix that your printer needs
hardware handshaking.

Parallel printers also require special cables (which you can
either make or purchase from Morrow).
Please read the "cables"
document,  then return  to  the  next
section  and  follow  instructions for  parallel  printers.


.ti -5
PLUGGING IN YOUR PRINTER

In the discussion that follows, we will assume that you are
going to plug a serial printer into the port called "ttyC", and/or
a parallel printer into the port calvices, including printers.

.ti -5
.bd
ports (4)
.br
The document "ports" in Section 4
(type the command "help ports")
explains how to identify the various I/O connectors on the Decision.


.ti -5
PRINTER INTERFACES

Micronix  and  the Decision come equipped to  handle  four
types  of  printer  interfaces.   The  interface  refers  to  the
physical  connection,  the  cable,  between the printer  and  the
Decision.  The interface also refers to the type of "handshaking"
used by your printer. This is the method it uses
to stop the flow of characters from the computer when
it  gets  behind.
The four types of interfaces are:

.in +5
1. Serial (or "RS-232") printers with hardware handshaking,

2. Serial printers with software ("XON XOFF") handshaking,

3. Parallel printers with Centronics-standard interfaces, and

4. Parallel printers with Diablo-standard interfaces.
.in -5

If you have either the first or second type of printer, you're in
luck.   You  can skip the rest of this section and start  reading
PLUGGING led "ppr0". If you don't
know how to find these ports, please read the document called
"ports".
If you want to use other ports, you will have to tell Micronix
which ports you are using. The document "configuration" tells
how to do this.

The serial printer can only be plugged in one way, so you
don't have to worry about which way to orient the connector.
However, the 50 pin parallel connector is not "keyed": that is, it
is quite possible to plug it in upside down.
Read on for some guidance.  On many cables, pin 1 is
labeled by having a  red  stripe on that edge.   Or,  if you
constructed  your  own cable,  you should know where pin 1 is.
The 50 pin connector on the back of your Decision has pin 1 on
the left hand side  when looking at the back of the printer. Plug
the parallel cable into the Decision with the red stripe, and
pin 1, toward the left.


.ti -5
TESTING YOUR PRINTER

Plug in your printer, turn it
ON,  and make sure that it is ON-LINE and set to "1200 baud".
(These settings are usually governed by  IN  THE PRINTER.   If you don't have one of  these  two
types, or are unsure of which type you are using, read on.

Serial  printers  use  either   software
handshaking or hardware handshaking.   Software handshaking means
that  when  the printer's buffer is full it sends a "byte"   to
the   computer  to temporarily stop  the  flow of
characters.  The  printer sends a different byte when it  is
ready  to receive again.   The byte that Micronix recognizes
for stopping transmission is X-OFF.   Other aliases for X-OFF are
control-S, DC3 and 13 hex.  The byte that restarts output is
X-ON,  also known as control-Q,  DC1 and 11 hex.
If your printer uses X-ON and X-OFF, then you can skip ahead to
the section PLUGGING IN YOUR PRINTER. If you have  a
serial printer that doesn't use X-ON and X-OFF  (for example,  it
uses   ETX  and  ACK  instead),  you'll  have  to  try   hardware
handshaking.

Hardware handshaking makes use of one of the wires in the
printer cable to start and stop output from the computer.  When  thswitches on the printer.
Sometimes the switches are on the inside, especially the baud rate
switches.) If you can't set your printer to 1200 baud, you will
have to change Micronix to transmit at whatever rate is acceptable.
The document called "configuration" explains how to do this.

For serial printers plugged into ttyC, type the command

     echo A > /dev/ttyC

There are two different test commands for parallel printers.
The difference between them is the way the device is named.
For parallel daisy-wheel printers plugged into ppr0, type

     echo A > /dev/diab0

and for Centronic style parallel printers plugged into ppr0, use

     echo A > /dev/cent0

Did you get an "A" on your printer?
If not, remember
that  interfacing  printers  IS non-trivial.   First, rule out the
trivial problems by checking to see if:

.in +5
1. the printer is turned on (and plugged in),

2. the printer is set to ON-LINE,

3. there is paper in it (many printers won't print  unless
they  can  sense  a piece of paper in  them),  anLet's begin by describing the simplest network: two machines with one
cable between them. First, you must choose names for the two machines.
These names are arbitrary; the only requirement is that each machine
on the network must have a unique name. The names should also be short
and easy to type. In this case, let's call them "sales" and "doc".

Next, you must buy or build a cable long enough to connect them.
(See
.bd
cables
in section 4.)
Then you must choose a free serial port on each machine
(see
.bd
ports
in section 4).
Let's say that you have choosen ttyD on doc, and ttyF on sales.
The cable can be plugged in at this point -- either end to either
machine.

Now you must edit three files on each machine. These files are:

        /etc/ttys
        /etc/netmap
        /etc/rc

The /etc/ttys file tells which IO ports on the local machine are
connected to the network. The /etc/netmap file gives the layout
of the network. The /etc/rc file contains commands that are run
every time the system goes multi-user. Id

4. the  cable is plugged in at both ends at  the  correct
connector.
.in -5

If  you have a parallel cable,  you can also try plugging  it  in
upside  down.   After  trying  all of the  suggestions,  try  the
suggested command again,  please.   If you get a different letter
than  an  "A",  there may be some wires scrambled  in  your
cable, or your serial printer may be set to the wrong baud rate.

If none of these suggestions helps,  your cable is  suspect.
Home  built  cables should be rechecked and store  bought  cables
checked  for  flaws.    RS-232  cables,   whether  home-made   or
purchased,  can  be  checked by using them to replace  the  cable
connecting  your  terminal.  Parallel cables can be  checked  for
continuity.
DIABLO
.br
This cable also works with the MULTIO expansion board,
since its parallel port is identical with the Decision's.
All you need is
a simple straight-through 50 conductor cable with 50-pin
flat cable female connectors on both ends.
It is the same cable that Morrow uses for in this case, we will
insert a command to start the "network daemon" (the background
process that runs the network).

Miconix comes with
.bd
WordStar
(a screen editor) and
.bd
edit
(a line editor). You may use either to edit these files.
Instructions for using
.bd
edit
on the ttys file are contained in the
.bd
ttys
document in section 5.

.bp
Here is what you must do to each file on each machine:

.nf
machine   file          action
-------   ----          ------
doc     /etc/ttys       Find the line that begins with ttyD.
                        Change it to read as follows:
                        ttyD  1200  net-sales

doc     /etc/netmap     Change (or create) this file to read:
                        doc
                        sales

doc     /etc/rc         Add the following lines:
                        echo Starting network
                        netdaemon

sales   /etc/ttys       Find the line that begins with ttyF.
                        Change it to read as follows:
                        ttyF  .he "          network (4)                 4/19/83                       network (4)
.fo "                                       -#-
.rm 79
.in 10
.ta 5
.
.
.ti -5
NAME
.br
.bd
network
- the Miconix network


.ti -5
DESCRIPTION
.br
Micronix allows any number of Decisions to be interconnected in any
pattern with simple, low cost hardware. Files can be copied from
any source to any destination on the network
(see
.bd
cp
in section 1),
and any user may send
mail to any other user
(see
.bd
mail
in section 1).
This is all done with ordinary serial I/O
ports and 3-conductor unshielded cables. Error checking is
extensive, so that cables may be cut and patched, and machines may
be crashed and restarted, all with good assurance that all files will
arrive intact. There is a penalty for this generality and low
cost, however. The transfer rate is slow (about 40-50 bytes per
second). But since all network activity is in the background,
users need not wait idly for file transfers to finish.

.ti -5
Two-machine network
.br
1200  net-doc

sales   /etc/netmap     Change (or create) this file to read:
                        sales
                        doc

sales   /etc/rc         Add the following lines:
                        echo Starting network
                        netdaemon
.fi

You will have to bring the system down (with the down command)
and then start it up again before these changes take effect.
You can test the network by typing the following command
from the doc machine:

        % cp  /etc/ttys  sales%/tmp

The /etc/ttys file should appear on the sales machine in the /tmp
directory. See
.bd
cp
and
.bd
mail
in section 1 for more information on using the network.

.ti -5
Three-machine network
.br
Now suppose we want to connect a third machine named "admin"
to the network.

The new machine can be connected to any of the existing
machines. It is only necessary to connect it to one of them,
but connecting to more than one might speed up the network by
providing a more direct path between machines.
For example, you cit can be preceeded by
an anouncement to remind the operator the network is being started.

/etc/netmap -- The name of the local machine should appear alone on
the first line. Each succeeding line should begin with the name of
a machine that is directly connected to the local machine. If there
are additional machines on the network, their names should appear
(in any order) following the name of the direct connection through
which they can be reached. If there are several ways to reach an
"indirect" machine, only one connection should be given: the one
that leads to the machine via the shortest route.

For example, let's look at several different networks, and a possible
netmap file for the "doc" machine in each network.

.nf
                                             doc
Line    sales -- doc -- admin -- support     sales
                                             admin  support


Ring             doc ---- sales              doc
                  |         |                sales
                  |        ould connect the new machine as follows:

.nf
        sales -------- doc
          |             |
          |             |
           --- admin ---
.fi

This requires a total of 6 IO ports, 2 on each machine.
But messages will be sent directly between any pair of machines.
Or you could connect this way:

        sales -------- doc -------- admin

This network uses only 4 ports: 1 on sales,
2 on doc, and 1 on admin. The disadvantage is that
messages between sales and admin have to go through
doc. This will be done automatically, but it takes longer.
Since the emphasis in the design of this network is low cost,
the 4 port alternative is recommended. (But if you have no other
use for the ports, go ahead and use all 6.)

Let's assume that you are going to use the straight-line connection
(the 4 port alternative).
First, you must choose a free serial port on doc, say ttyE, and one
on admin, say ttyC. Connect these ports with a network cable, and
change the configuration files as follows:

.nf
         /etc/netma |                admin support
                admin -- support


Star          sales ---- doc ---- admin      doc
                          |                  sales
                          |                  admin
                       support               support


Star           doc ---- sales --- admin      doc
                          |                  sales admin support
                          |
                       support


Dipper         doc ---- admin --- support    doc
                |         |                  sales
                |         |                  admin support
                 ------ sales
.fi


.ti -5
SEE ALSO
.br
cp (1), mail (1), cables (4), ports (4)
             |
|              50 pin flat cable connector             |
|                                                      |
|  2  3  12 13 21 24 26 27 28 33 36 37 39 40 42 43 45  |
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   |
|  2  3  12 13 21 24 26 27 28 33 36 37 39 40 42 43 45  |
|                    p    /etc/rc      /etc/ttys
         -----------    -------      ---------
sales    sales          no change    no change
-----    doc admin

doc      doc            no change    ttyE 1200 net-admin
---      admin sales

admin    admin          netdaemon    ttyC 1200 net-doc
-----    doc sales
.fi

.ti -5
General networks
.br
The only restriction on the shape of the network is a physical one:
a seperate serial port is required at each end of each cable.
Otherwise, the network can be a straight line, a star, a ring, or
any pattern. The rules to follow in setting up the 3 configuration
files are as follows:

/etc/ttys -- Find the lines corresponding to each network port on the
local machine. Put the word 1200 on each line, and in addition, put
the word net-name, where "name" is the name of the machine to which
that port is connected.

/etc/rc -- Put the command netdaemon in the file. It should be alone
on a line. It should appear only once, no matter how many network
ports there are on the machine. Optionally, .he "djmem (4) 	     		 4/18/82                       djmem (4)"
.fo "				   -#-"
.in 10
.rm 65
.bd
.ti -5
NAME
.br
.bd
djmem
 - Morrow Designs DJDMA floppy controller memory device

.ti -5
.bd
DESCRIPTION 
.br
.bd
The djmem device provides access to the memory internal
to the DJDMA floppy controller and to the funcions "sense status"
and "execute controller routine".
The djdma memory device was originally implemented to allow
floppy diskette formatting under Micronix.
It is conceivable that it may be put to other uses.

The djdma memory device driver ignores the minor device number.
That is to say you may access only on djdma controller
and there is only one way to access it.

The djdma and djmem drivers are mutually exclusive.
If you attempt to use one while the other is in use
you will get the error return "File or Device Busy".

A read on the djmem device transfers data from the
djdma contoller's memory to the user's memory.

A write transfers from user memory to controler memory.

Seek may be used to posecurity breach.

It is recommended then that the file
/dev/djmem be highly restricted and write locked.

.ti -5
.bd
SEE ALSO
.br
djdma(4), formatdj(1)
intro(2), chmod(1), ls(1)
DJDMA Techincal Reference Manual.
ho Starting network
                        netdaemon
.fi

You will have to bring the system down (with the down command)
and then start it up again before these changes take effect.
You can test the network by typing the following command
from the doc machine:

        % cp  /etc/ttys  sales%/tmp

T.he "banner (5)                   3/15/82                   banner (5)
.fo "                               -#-"
.in 5
.rm 65
NAME
.in +5
.bd
banner 
- the log-in banner
.sp 2
.in -5
.bd
FUNCTION   
.br
.in +5
The banner file is printed on each terminal just prior to the
.bd
Name:
prompt for the user login name.
This file is inessential to system operation.
It may be edited to the user's preference, or deleted. 
.in -5
.sp 2
.bd
FILES
.in +5
.br
/etc/banner - banner file.

is conceivable that it may be put tition the pointer into controller memory.

The only safe locations to write are
0x1030 to 0x127f inclusive
according to the djdma tech. reference manual.

Note that the "0x" preceding the preceding numbers indicates
base 16.

At most 1024 bytes may be transferred in a single read/write call.
Larger byte counts cause an "invalid argument" error.

So far the implementation has been very straightforward.

In order to pull off formatting a couple extra
extended features are needed.
These are implemented via the system calls stty() and 
gtty().

Gtty on the device caused a "sense status"
command to be performed and the results returned.

Stty causes an "execute controller memory"
command to be performed.

Gtty returns 4 bytes of meaningful status.
Stty returns one byte of status.

Gtty and Stty are called by passing a pointer to 
a 6-byte structure in user memory.
The user process fills out the first 2 bytes of memory,
Gtty or Stty fill out the remaining 4 bytes.

For gtty the first 2 byte word
represents
the devi.he "core (5)                      3/17/82                    core (5)"            
.fo "                                -#-" 
.in 5
.rm 65
.bd
NAME
.in +5
.bd
core 
- core dump file
.sp 2
.in -5
.bd
FUNCTION    
.in +5
.br
A core file is produced by the system as a result of certain fatal signals;
the offending program is then terminated.
The file produced is named "core" in the current directory of the
dumped program at the time of the fatal signal.  The format of the
core dump file is as follows:

The first 65,536 bytes are simply a "snapshot" of the program as it
appeared in memory at the critical instant.  Following this "memory image"
is certain other pertinent information, mostly the contents of the
Z80's registers:
.sp 
.in +4
.ta 4
Task:	Micronix task number
.br
Mask:	The MPZ80 permission mode
.br
PC:	Program counter
.br
SP:	Stack pointer
.br
.ti -10
Registers:
.br  
af	   
.br
bc 	  
.br
de 	  
.br
hl           
.br
zir 	   
.br
zix        
.br  
ziy
.br
zaf
.br
zbc
.br
zde
.br
zhl
.sp 
.in -4
This ce number on which to perform the status operation.

For stty the first 2 byte quantity is the 
address in conroller memory to execute.

The user familiar with C will find the following
structure declarations illuminating.
Note that these declarations are available in
/include/dj.h.

struct djstat
	{
	int drive;
	char status[4];
	};

struct djexec
	{
	char *address;
	char status [4];
	};

For gtty the drives are numbered as follows:

There are 8 possible drives.
Four 5 inch and four 8 inch.

The 8 inch drives are numbered 0-3.
The 5 inch drives are numbered 4-7.

The meanings of the 4 status bytes returned are
described in the djdma technical reference manual.

The single status byte returned by the stty call
has whatever meaning the controller routine 
called ascribes to it.

Note that the stty call is potentially dangerous.
It is easily capable of dropping the whole system
because through it you can do anything the conroller
can do, which includes reading or writing 
any portion of memory.

This is also a ssection assumes previous knowledge of the Z80 processor.
locations to write are
0x1030 to 0x127f inclusive
according to the djdma tech. reference manual.

Note that the "0x" preceding the preceding numbers indicates
base 16.

At most 1024 bytes may be transferred in a single read/write call.
Larger byte counts cause an "invalid argument" error.

So far the implementation has been very straightforward.

In order to pull off formatting a couple extra
extended features are needed.
These are implemented via the.he "     terminals (5)                10/13/83                terminals (5)"
.fo "                                     -#-"
.rm 65
.in 5
.bd
NAME
.in +5
.br
.bd
terminals
- the terminal capabilities file
.sp 2
.in -5
.bd
FUNCTION
.in +5
.br
The
.bd
terminals
file, always located in the /etc directory, contains the list of
terminals and their capabilities.  The information in this file
is used by upm for terminal emulation.  The information here is
also available to other programs that make use of the featuw            return to normal intensity *

     * (Optional, since most programs actually do not use.)

LEVEL 3

     insline        insert a line
     inschar        insert a character in a line *
     delline        delete a line
     delchar        delete a character *

     * (Optional, since most programs actually do not use.)

.fi
The keywords must be spelled exactly as shown here, and must always
be in lower case.  When adding a terminal to the
.bd
terminals
file, try to define as many capabilities as possible.
If you are deciding what level your terminal fits, your
terminal must fulfill ALL of the categories in the
lower levels before you can consider it as fitting in a
higher level.  Three other keywords may optionally be used:
like, init and exit.  The characters following init may be sent
by a program to initialize a terminal; those following
exit may be sent just before a program terminates.
.sp
The like keyword is used to include a previously defined
terminal's keywords and their definitions for res
of intelligent terminals, such as, cursor addressing,
clear screen, erase to end of screen, etc.
.br
.sp 2
The
.bd
terminals
file is broken into descriptions of terminals by the terminal
name lines, which always begin at the leftmost margin (column 1).
The first word on the line is the "terminal abbreviation",
which should be short and mnemonic.
This should be followed by the full name of the terminal,
which is free-form. This full name will appear automatically
in the terminal menus presented by the reconfiguration program.
See recon (1).
.sp
The lines that follow each terminal name line define the
characters that the terminal uses for control of special
effects (cursor movement, clearscreen, highlighting, etc.).
.sp
Terminals can be divided into three categories according to their
capabilities.  Grouping terminals into these three "levels"
allows the use of only, at most, three different versions
of terminal-configured software.  The first level of terminals,
the simplest level, is defined by terminals the terminal
currently being defined.  Differences between a terminal
and one that it is "like" are adjusted by redefining keywords.
You can only use three levels of like-ness, that is, the terminal
you are describing can be "like" a previously defined terminal
that is "like" another terminal, that is "like" some fully
described terminal.  The like keyword should be the first keyword
used in a description; if you use it last, the keywords you were
trying to redefined will be overwritten by the definition of
the "like" terminal.
.sp
The keywords are followed by the characters that define them,
separated by spaces.  There are a number of abbreviations
and operators that are used with the keyword definitions.  The
abbreviations that are recognized are:
.sp
.nf
ABBREVIATIONS RECOGNIZED

     bs     backspace
     cr     carriage return
     esc    escape
     ff     formfeed
     nl     newline
     null   0-byte
     sp     space
     tb     tab
     vt     vertical tab

     row    see below
     col        "
 having the following
capabilities:
.sp
.nf
LEVEL 1

     Keyword        Description

     cursor         string of characters to move cursor
     home           home the cursor *
     up             character(s) to move the cursor up *
     down           character(s) to move the cursor down *
     right          character(s) to move the cursor right *
     left           character(s) to move the cursor left *
     clear          clear the screen and home cursor

     * (Optional, since most programs actually do not use.)

.fi
The keywords are used one per line, preceded by white-space
(tabs or spaces) that distinguish the keywords from terminal
names.  The characters that complete the keyword
definition follow, separated by more whitespace.  A newline
terminates each definition.  The keywords that define the next
two levels are:
.sp
.nf
LEVEL 2

     Keyword        Description

     ceol           clear to end of line
     ceos           clear to end of screen
     high           begin highlighting *
     lo    ascii      "
     +          "
     '          "
     ^          "
     numbers    "

     other  all other single characters are
            sent literally


.fi
These abbreviations provide a way of including human readable characters,
as opposed to using their octal equivalents in keyword definitions.
.sp
Several operators are also provided for keyword definitions.
These operators modify the characters that follow them, or are
used to include the row and column in cursor definitions.
.sp
.nf
OPERATORS

     row + n    Sends the line number plus an offset n
                as a single byte. The first row on the
                screen is row 0. Most terminals use
                row + 32.

     col + n    Sends the column number plus an offset n
                as a single byte. The first column on the
                screen is column 0. Most terminals use
                column + 32.

     row ascii  Send the row number as a series of ascii
                digits (with leading zeros supressed).
         the
.bd
terminals
file, use the list of keywords for the three levels and find
the character(s) used by your terminal for as many keywords as
possible.  These characters are usually buried in a table in
your terminal's manual describing control sequences or special
characters.  You should always be able to find all the control
sequences necessary for a level 1 terminal at a minimum.
The names of the various functions, for example, home or
highlight, will vary unpredictably from manual to manual.
.sp 2
.in -5
.bd
NOTE
.in +5
.br
The shorter the
.bd
terminals
files is, the quicker it may be searched for matching terminal
types.  You may wish to rename (mv) the
.bd
terminals
file, and keep an edited version with just the terminals you
normally use in the file /etc/terminals.
.sp 2
.in -5
.bd
FILES
.in +5
.br
/etc/terminals
.sp 2
.in -5
.bd
SEE ALSO
.in +5
.br
upm (1)

effective only when the "standard" CP/M
console I/O calls are used.
They will not be understood if the CP/M BIOS jumps
or CP/M direct I/O calls ar       Used by ANSI-standard terminals.

     col ascii  Send the column number as a series of ascii
                digits (with leading zeros supressed).
                Used by ANSI-standard terminals.

     '          Send the following characters literally with
                no conversion. Eg, '0 is the same as 48 or
                x30 (see x below).

     ^          Convert the character that follows to the
                corresponding control code

     xnn        Interpret the number nn that follows 
                as hexadecimal. (Any number of digits. 
                Converts to one byte.)

     0nnn       Interpret the number nnn that follows 
                as octal.  (Any number of digits. 
                Converts to one byte.)

.fi
The row and col operators must always be followed by a plus sign
and an offset (which may be zero), or by the word ascii.
(Each of these must be separated by a space.)
The quote operator (') converts any numbers that follow
into their ascii values (between 48 .he "ascii (5)                      10/20/82                    ascii (5)"
.fo "                                -#-" 
.in 10
.rm 65
.bd
.ti -5
NAME
.br
ascii - american standard code for information interchange

.ti -5
.bd
SYNOPSIS
.br
cat /usr/pub/ascii

.ti -5
.bd
DESCRIPTION
.br
The file /usr/pub/ascii serves as a cross
reference guide for conversion between ascii character
names and numeric values.
Values are given in base 16 and base 8.

The file contains:

.nf
.in -5
| 00 nul| 01 soh| 02 stx| 03 etx| 04 eot| 05 enq| 06 ack| 07 bel|
| 08 bs | 09 ht | 0a nl | 0b vt | 0c np | 0d cr | 0e so | 0f si |
| 10 dle| 11 dc1| 12 dc2| 13 dc3| 14 dc4| 15 nak| 16 syn| 17 etb|
| 18 can| 19 em | 1a sub| 1b esc| 1c fs | 1d gs | 1e rs | 1f us |
| 20 sp | 21  ! | 22  " | 23  # | 24  $ | 25  % | 26  & | 27  ' |
| 28  ( | 29  ) | 2a  * | 2b  + | 2c  , | 2d  - | 2e  . | 2f  / |
| 30  0 | 31  1 | 32  2 | 33  3 | 34  4 | 35  5 | 36  6 | 37  7 |
| 38  8 | 39  9 | 3a  : | 3b  ; | 3c  < | 3d  = | 3e  > | 3f  ? |
| 40  @ | 41  A | and 57).
The caret (^) indicates control
keys, for example, ^H represents a backspace.  If you prefer
to use hexadecimal or octal notation, use x or 0 to indicate
the type of conversion desired.  Numbers are converted to a
single byte (value 0 to 255). Strings or characters preceeded
by a single quote (') are sent literally. For example, 0123
sends a sends the byte with the octal value 123 (this is the
letter S), while '0 '1 '2 '3 sends the four ascii bytes 0, 1, 2, and 3.
.sp 2
.in -5
.bd
EXAMPLE
.in +5
.br

.nf
mor20   Morrow 20
        like    proto3
        cursor  esc = col + 32 row + 32
        clear   ^Z

.fi
This example defines a terminal, abbreviated as mor20, as being
"like" the proto3 definition, then goes on to redefine the
cursor and clear keywords.  The sequence of characters used
to move the cursor is:  an escape, an "=", the column number added
to 32, and the row number added to 32.  The character that clears
the screen is a Control-Z.
.sp
If you need to create an entry for a terminal not in 42  B | 43  C | 44  D | 45  E | 46  F | 47  G |
| 48  H | 49  I | 4a  J | 4b  K | 4c  L | 4d  M | 4e  N | 4f  O |
| 50  P | 51  Q | 52  R | 53  S | 54  T | 55  U | 56  V | 57  W |
| 58  X | 59  Y | 5a  Z | 5b  [ | 5c  \ | 5d  ] | 5e  ^ | 5f  _ |
| 60  ` | 61  a | 62  b | 63  c | 64  d | 65  e | 66  f | 67  g |
| 68  h | 69  i | 6a  j | 6b  k | 6c  l | 6d  m | 6e  n | 6f  o |
| 70  p | 71  q | 72  r | 73  s | 74  t | 75  u | 76  v | 77  w |
| 78  x | 79  y | 7a  z | 7b  { | 7c  | | 7d  } | 7e  ~ | 7f del|


|000 nul|001 soh|002 stx|003 etx|004 eot|005 enq|006 ack|007 bel|
|010 bs |011 ht |012 nl |013 vt |014 np |015 cr |016 so |017 si |
|020 dle|021 dc1|022 dc2|023 dc3|024 dc4|025 nak|026 syn|027 etb|
|030 can|031 em |032 sub|033 esc|034 fs |035 gs |036 rs |037 us |
|040 sp |041  ! |042  " |043  # |044  $ |045  % |046  & |047  ' |
|050  ( |051  ) |052  * |053  + |054  , |055  - |056  . |057  / |
|060  0 |061  1 |062  2 |063  3 |064  4 |065  5 |066  6 |067  7 |
|070  8 |071  9 |072  : |073  ; |074  < |075  = |0ctory of the 
master file system and for the root directories
of removable file systems.
In the first case, there is no parent, and
in the second, the system does not permit off-device 
references.
In both cases ".." has the same meaning as ".".
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
filesystem (5)
 f | 67  g |
| 68  h | 69  i | 6a  j | 6b  k | 6c  l | 6d  m | 6e  n | 6f  o |
| 70  p | 71  q | 72  r | 73  s | 74  t | 75  u | 76  v | 77  w |
| 78  x | 79  y | 7a  z | 7b  { | 7c  | | 7d  } | 7e  ~ | 7f del|


.he "group (5)                     3/15/82                   group (5)"
.fo "                                -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.bd
group 
- the group file
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
Each user name is associated with a group number.
Associated with each file is a user ID number (the owner of the file)
and a group ID number (the group of the file).  These numbers are used
in permission determinations.

The relationship between group numbers and names is established by the
group fi76  > |077  ? |
|100  @ |101  A |102  B |103  C |104  D |105  E |106  F |107  G |
|110  H |111  I |112  J |113  K |114  L |115  M |116  N |117  O |
|120  P |121  Q |122  R |123  S |124  T |125  U |126  V |127  W |
|130  X |131  Y |132  Z |133  [ |134  \ |135  ] |136  ^ |137  _ |
|140  ` |141  a |142  b |143  c |144  d |145  e |146  f |147  g |
|150  h |151  i |152  j |153  k |154  l |155  m |156  n |157  o |
|160  p |161  q |162  r |163  s |164  t |165  u |166  v |167  w |
|170  x |171  y |172  z |173  { |174  | |175  } |176  ~ |177 del|


nsity *

     * (Optional, since most programs actually do not use.)

LEVEL 3

     insline        insert a line
     inschar        insert a character in a line *
     delline        delete a line
     delchar        delete a character *

     * (Optional, since most programs actually do not use.)

.fi
The keywords must be spelled exactly as shown here, and must always
be in lower case.  When adding a terminal to the
.bd
terminals
file, try to define as many capabilities ale.
The format of the group file is as follows:
.sp
.in +3
Each line of the file defines one group name.

The group name is followed by a colon, then followed by the 
encrypted group password, if one exists.
This is followed by a colon, which is followed by the group 
number (in decimal), followed
by a colon, followed by the group comment field which may contain anything
you desire, or nothing at all.
.sp 2
.in -3
Here is a sample group file:
.sp
.in +7
.bd
sales::4:
.br
.bd
stock::5:
.sp 2
.in -7
Normally group 0 is reserved for the super-user only.  The 
.bd
newuser
program makes additions to this file.
.sp 2
.in -5
.bd
SEE ALSO
.in +5
.br
passwd(5)
he system does not permit off-device 
references.
In both cases ".." has the same meaning as ".".
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
filesystem (5)
 f | 67  g |
| 68  h | 69  i | 6a  j | 6b  k | 6c  l | 6d  m | 6e  n | 6f  o |
| 70  p | 71  q | 72  r | 73  s | 74  t | 75  u | 76  v | 77  w |
| 78  x | 79  y | 7a  z | 7b  { | 7c  | | 7d  } | 7e  ~ | 7f del|


.he "directory (5)                 3/15/82               directory (5)"
.fo "                                -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
directory 
- the format of directories.
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
Micronix uses the standard UNIX version 6 directory format.
A directory behaves like an ordinary file except that
a user may write into a file, but cannot write into a directory.

A directory is distinguished from a file
by a bit in the flag word of its i-node entry.
Directory entries are 16 bytes long.
The first word is the i-number of the file, represented by the entry
if non-zero.

If the first word is zero, the entry is empty.

Bytes 2 through 15 of the entry represent the 14-character file name, null
padded on the right.
These bytes are not cleared for empty slots.

By convention, the first two entries in each directory
are for "." and "..".
The first is an entry for the directory itself.
The second is for the parent directory.

The meaning of ".." is modified for the root dire.he "motd (5)                      3/15/82                    motd (5)"
.fo "                                -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.bd
motd 
- message of the day
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
The message of the day file is printed on each users' terminal
after the proper login sequence is completed.

The contents of this file are inessential to system operation.
This file is intended to be updated frequently
by the system administrator.  It may be used to inform the users 
of changing system conditions or upcoming events.
This file may be deleted from the system if the user so wishes.
.sp 2
.in -5
.bd
SEE ALSO
.in +5
.br
banner (5), signon (5)
the 
encrypted group password, if one exists.
This is followed by a colon, which is followed by the group 
number (in decimal), followed
by a colon, followed by the group comment field which may contain anything
you desire, or nothing at all.
.sp 2
.in -3
Here is a sample group file:
.sp
.in +7
.bd
sales::4:
.br
.bd
stock::5:
.sp 2
.in -7
Normally t
may be renamed to anything the user wishes.
.sp 2
.in -5
.bd
EXAMPLE
.in +5
.br
.bd
root::0:0:super:/:/bin/sh
.sp
.bd
sally::10:1:sally:/a/sally:/bin/sh
.sp 2
.in -5
.bd
FILES
.in +5
.br
/etc/passwd
.sp 2
.in -5
.bd
SEE ALSO
.in +5
.br
login (5), passwd (5), group (5)
D
.in +5
.br
filesystem (5)
 f | 67  g |
| 68  h | 69  i | 6a  j | 6b  k | 6c  l | 6d  m | 6e  n | 6f  o |
| 70  p | 71  q | 72  r | 73  s | 74  t | 75  u | 76  v | 77  w |
| 78  x | 79  y | 7a  z | 7b  { | 7c  | | 7d  } | 7e  ~ | 7f del|


.he "rc (5)                       3/16/82                       rc (5)"
.fo "                               -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.bd
.br
rc 
- multi-user start-up file
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
The 
.bd
init 
(initialization) program looks for the "/etc/rc" file just before 
entering the multi-user mode.
If such a file is found, and is readable,
it is run as a shell script.
That is, each of the commands in the file is executed as if from 
the keyboard.

Typically, it is used to cl.he "mtab (5)                        3/15/82                  mtab (5)"
.fo "                                  -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
mtab 
- mounted file system table
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
.bd
Mtab 
resides in the /etc directory and contains a table of devices
"mounted" by the 
.bd
mount 
command.  The 
.bd
umount 
command removes entries.

Each entry is 64 bytes long.
The first 32 bytes are the null padded name of the place where the
special file is mounted;
the second 32 are the null padded name of the special file.
The special file has all its directories stripped away,
that is, everything through the last '/' is thrown away.

This table is present only so people can look at it.
It does not matter to 
.bd
mount 
if there are
duplicate entries, nor to 
.bd
umount 
if a name cannot be found.
.sp 2
.in -5
.bd
FILES
.in +5
.br
etc/mtab
.sp 2
.in -5
.bd
SEE ALSO
.in +5
.br
mount (1), umount (2)

e group file:
.sp
.in +7
.bd
sales::4:
.br
.bd
stock::5:
.sp 2
.in -7
Normally ean out the temporary directory, 
remove locked files, start up daemons, etc.  The user may place
whatever he desires in the file.
.sp 2
.in -5
.bd
FILES
.in +5
.br
/etc/rc


Each user is separated from the next by a newline.
The encrypted passwords are kept in a separate file, the contents
of the password entry are immaterial.
This file resides in the "/etc" directory.

The first entry of the password file contains an 
entry for the
super-user account.  The name of this account is traditionally 
"root," bu.he "signon (5)                     3/15/82                 signon (5)"
.fo "                                 -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
signon
- file for the signon prompt
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
The signon file is printed on the system console
each time Micronix is booted.
The contents of this file is inessential to system operation.
It is merely there to display system-oriented information. 
It may be edited to suit the user, or deleted from the system.
.sp 2
.in -5
.bd
FIL.he "passwd (5)                     3/15/82                 passwd (5)"
.fo "                                 -#-"
.in 5
.rm 65
.bd  
NAME
.bd
.in +5
.br
passwd 
- password file
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
The name 
passwd 
has become a misnomer, but is commonly found
in UNIX documentation and we hesitate to change it here.
.sp
.bd
Passwd 
contains the following information:
.sp
.in +3
name (login name, no upper case letters)
.br
encrypted password
.br
numerical user ID
.br
numerical group ID
.br
comment
.br
home directory
.br
command interpreter program name
.in -3
.sp
This is an ASCII file.
Each field within each user's
entry is separated from
the next by a colon.
Each user is separated from the next by a newline.
The encrypted passwords are kept in a separate file, the contents
of the password entry are immaterial.
This file resides in the "/etc" directory.

The first entry of the password file contains an 
entry for the
super-user account.  The name of this account is traditionally 
"root," buES
.in +5
.br
/etc/signon
ctory, 
remove locked files, start up daemons, etc.  The user may place
whatever he desires in the file.
.sp 2
.in -5
.bd
FILES
.in +5
.br
/etc/rc


Each user is separated from the next by a newline.
The encrypted passwords are kept in a separate file, the contents
of the password entry are immaterial.
This file resides in the "/etc" directory.

The first entry of the password file contains an 
entry for the
super-user account.  The name of this account is traditionally 
"root," bu.he "     ttys (5)                        10/18/83                     ttys (5)
.fo "                                        -#-
.in +10
.rm 75
.
.ti -5
NAME
.br
.bd
/etc/ttys
- Micronix terminal and printer configuration

.ti -5
SUMMARY
.br
(This is a technical summary. Explanatory examples follow.)
.br

The
.bd
/etc/ttys
file specifies the Micronix terminal and printer configuration.
It is a humanly-readable text file consisting of lines with
whitespace-seperated words. Word order is not significant.

The	The word "lst". When
.bd
upm
(the CP/M emulator) is invoked, it reads the ttys file looking for
the word "lst". If found, it uses the corresponding device as its
LST: device (ie, its printer), unless it is told otherwise (by
a command line argument, a command in the .upm file, or a command
given in interactive mode). See
upm
in section 1.

.ti -5
7.	A word beginning with "net-". The rest of the word is taken to be
the network name of the machine to which that port is connected
(not the local machine, but the machine at the other end of the cable).
See
.bd
network
in section 4.
.in -5


.ti -5
DON'TS
.br
Don't use a login port for anything else.
Don't specify "shake" or a baud rate for a parallel port (the "cent's"
and the "diab's").

Don't specify one of the "diab's" as the lst device. (It takes a lot
of code to drive the Diablo-type parallel printers, and this was left
out of upm to save space.) If you want to use diab0 as the upm lst
device, then you should do the following. Change to the /bin directory
an first word on each line is the name of a
"character special" device file (one of the files in the /dev
directory). The rest of the words on the line apply to that device.
The following words are meaningful:

.ta 5
.in +5
.ti -5
1.	Any valid baud rate:
50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800, 9600, or 19200.
The system will set the baud rate as requested.
This is done by the init process
(a) when the system is powered up,
(b) each time a user logs off,
(c) each time the /etc/ttys file is changed (but only to devices
that are not currently logged in).
See
.bd
init, login, and update
in section 1 for more information.

.ti -5
2.	The word "shake". This refers to RS-232 Clear-To-Send handshaking.
The system will use this type of handshaking only if requested (since
some devices do not support it). XON-XOFF (software) 
handshaking is done by default.
The init process sets or resets this mode under the same circumstances
as in #1 above. (See
.bd
printers
in section 4 for more information on hand make a link called "diab0" to the "diablo" program. Then change to
your home directory and put "lst:|diab0" in your .upm file.


.ti -5
EXAMPLES
.br
The file
.bd
/etc/ttys
(that is, the file found by starting in the root directory
.bd
/,
proceeding to the subdirectory
.bd
etc,
then to the file
.bd
ttys)
tells the system about its terminals and printers.
More specifically, it tells which of the Decision's I/O
connectors are attached to terminals, which are attached
to printers, and what should be done with each of them.

The easiest way to understand it is to look at a sample
.bd
ttys
file:

.nf
ttyA  9600  login  term=tvi925
ttyB  9600  login  term=mor20
ttyC  1200  shake  lpr
ttyD  1200  net-sales
ttyF  1200  net-admin
ttyG  1200  login
ttyH
ttyI
ttyJ
ttyK
ttyL
cent0  xpr  lst
cent1
cent2
cent3
diab0
diab1
diab2
diab3
.fi

The first word on each line is the name of one of the I/O
connectors on the back of the Decision, and also the name
of the corresponding "character device" file in the /dev
directory. Bydshaking.)

.ti -5
3.	The word "login". When the system goes multi-user,
a login process will be created for each device designated
as a "login" terminal (see
.bd
init
in section 1).

.ti -5
4.	The word "term=" followed by a terminal mnemonic.  
.bd
upm 
reads the ttys file and provides
terminal emulation for the model of terminal named after the word "term=".
The terminal named is matched against an entry in
the /etc/terminals file, for the purpose of translating
generic control codes into the exact codes expected by the terminal.  (See
.bd
terminals
in section 5).

.ti -5
5.	The word "lpr", or the name of any link to lpr
(such as "dpr", "xpr", etc). When the lpr ("line printer")
program is invoked, it first looks to see what name it was called by.
It then reads the ttys file looking for its name. If found, it
uses the device on the same line as its printer. Thus, several
printers can be supported simply by keeping several copies of
the lpr program under different names (see
.bd
lpr
in section 1).

.ti -5
6. convention, the terminal that is attached to
the I/O connector is also called by the same name. (So when
you see "ttyA", you may have to infer from the context
which of these three things we are talking about: the device
file, the I/O connector, or the terminal itself.)

This example says that ttyA should be run
at 9600 baud, and that it is a login terminal.  When 
.bd
upm
is invoked,
it will send the correct control codes for a Televideo 925 (term=tvi925)
to the terminal connected to ttyA, and use software configured for
a ADM-31.
The same is true for ttyB, except that 
.bd
upm
will use control codes for the Morrow MD20 terminal.

TtyC should be run at 1200 baud, and needs hardware handshaking.
(See
.bd
printers
in section 4 for more information on handshaking.)
The "lpr" says that ttyC will be used by the
.bd
lpr
("line printer") program
(so it is presumably a printer).

TtyD and ttyE are network ports. Both run at 1200 baud.
TtyD is connected to the machine named "sales", while
ttyE is connected to "admin                             End the changes.
ttyC  1200  shake  lpr  lst     The editor prints the new line.
:w                              Write out the updated file.
"ttys" [writing] 19 lines       The editor prints this.
:q                              Quit the editor.
#
.fi

(There are faster ways to use edit, but these are the easiest
to explain.)


.ti -5
SEE ALSO
init (1), login (1), lpr (1), recon (1), stty (1), update (1), 
upm (1), network (4), printers (4), ports (4), cables (4).
l.
.sp 2
.in -.he "utmp (5)                        3/15/82                  utmp (5)"
.fo "                                 -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
utmp 
- user information
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br	
This file offers information on who is currently using Micronix.
The file is binary.
Each entry is described in the structure illustrated below:
.sp
.nf
.bd 4
struct utmp
	{    
	char line[8],	/* typewriter name */
	     name[8];   /* login name */
.sp
.bd 2		
	long	time;	/* login time */
	};
".

TtyF is a login device running at 1200 baud
(so it is probably a modem).  There isn't a "term=" entry on this
line, so 
.bd
upm
will not provide terminal emulation for ttyF.

The only other device that is is currently attached to the system
is a Centronics-type printer called "xpr".
It is attached to parallel port 0, and thus to the
device named "cent0". (If it were a Diablo-type parallel
printer, it would appear on the line with "diab0").
The "lst" means that the CP/M emulator
.bd
upm
will use this device as its LST: device (its printer),
unless told otherwise by a later command.


.ti -5
CHANGING THE TTYS FILE
.br
The 
.bd
recon
program is used to recon-figure the ttys file.  The
.bd
recon
program understands all the rules for using or modifying the ttys
file, and will also interpret the /etc/terminals file for you.

Since this is an ordinary text file, it can also be changed with your
favorite text editor. If you use WordStar, open the file in
"non-document" mode. Here is a sample session with the Micr

.fi
Line is the name of 
.bd
tty 
(null padded) on which the user is
logged in.  Name is the (null padded) name of the user who logged in.
Time is the time of login, expressed as a 32-bit quantity representing
the number of seconds since the epoch (midnight, January 1st, 1970).
.in -5
.bd
FILES
.in +5
.br
/etc/utmp
.br
/include/utmp.h
.sp 2
.in -5
.bd
SEE ALSO
.in +5
.br
d.
This is done by the init process
(a) when the system is powered up,
(b) each time a user logs off,
(c) each time the /etc/ttys file i.he "wtmp (5)                      3/15/82                    wtmp (5)"
.fo "                                -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
wtmp 
- user login history
.sp 2
.in -5
.bd
FUNCTION       
.in +5
.br
This file records all logins and logouts.
Its format is like 
.bd
utmp
(5) with these exceptions:
A null user name indicates a logout on the associated typewriter.
Furthermore, the typewriter name 
.bd
~
indicates the system was rebooted at the indicated time;
the adjacent pair of entries onix
line editor "edit".

Let's say that we want to change the "lst" device from cent0 to ttyC.
First log in as "root" (since only the super-user is allowed to
change the ttys file). In the lines below, the '#' is the super-user
shell prompt, and the ':' is edit's prompt.

.nf
# cd /etc                       Change directory to /etc.
# edit ttys                     Edit the ttys file.
"ttys" [reading] 19 lines       The editor prints this.
:/cent0                         Look for the line containing cent0.
cent0  xpr  lst                 The editor prints it.
:c                              Change the line.
cent0  xpr                      You type the new line.
.                               End the changes with a lone .
cent0  xpr                      The editor prints the new line.
:/ttyC                          Look for the line containing ttyC.
ttyC  1200  shake  lpr          The editor prints it.
:c                              Change the line.
ttyC  1200  shake  lpr  lst     You type the new line.
.  with typewriter names
.bd
|
and 
.bd
}
indicate the system-maintained time just before and just
after a 
.bd
date 
command changed the systems' idea of the time.
.bd
Wtmp 
is maintained by 
.bd
login 
(1) and 
.bd
init 
(1).  Neither of these programs creates the file,
so if is is removed, record-keeping is turned off.
.sp 2
.in -5
.bd
FILES
.in +5
.br
/usr/adm/wtmp
.br
/include/utmp.h
.sp 2
.in -5
.bd
SEE ALSO
.in +5
.br
utmp (5), login (1), init (1), who (1)
er logs off,
(c) each time the /etc/ttys file i.he "dtab (5)                     4/14/82                     dtab (5)
.fo "                               -#-"
.in 5
.rm 65
.bd       
NAME
.in +5
.br
.bd
dtab 
- the dump table
.sp 2
.in -5
.bd
FUNCTION
.in +5
.br
Information on the times of a dump are kept in the file "/etc/dtab."
This is a non-ASCII file presently used only by 
.bd
td
(1).  Each entry in 
.bd
dtab 
is eight bytes long and takes the form:


.in +5
.nf
.bd 7
struct dtab
	{
	int	device,
		inode;

	long	date;
	};
.sp 2
.in -5
.fi
There is ated 
from the free list, or is freed,
a diagnostic is written on the on-line
console.
Moreover,
the free array is cleared
to prevent further allocation from
a presumably corrupted free list.

The free list for each volume is maintained as follows.
The free array contains, in 
.bd
free[1], ... , free[nfree-1],
up to 99 numbers of free blocks.
.bd
Free[0] 
is the block number of the head of a 
chain of blocks constituting the free list.
The first word in each free-chain block is the number
(up to 100) of free-block numbers listed in the next 100 words of 
the chain member.  The first of these 100 blocks is the link to 
the next member of the chain.
.bp
To allocate a block:
decrement
.bd
nfree 
and the new block is 
.bd
free[nfree].

If the new block number is 0, there are no blocks left and an 
error is given.

If 
.bd
nfree 
becomes 0, read in the block named by the new block number, replace
.bd
nfree 
by its first word, and copy the block number in the next 100 words
into the 
.bd
free 
array.

To free a blocn entry in 
.bd
dtab 
for each directory that
has been dumped by 
.bd
td.
Device is the major/minor device number of the directory in question
(major device number in the high byte, minor in the low byte).
Inode is the inode number of the directory.
Date is the time of the last recorded dump of the directory
in question expressed as a 4-byte quantity representing
the number of seconds elapsed since Jan. 1, 1970 at midnight.
.sp 2
.in -5
.bd
FILES
.in +5
.br
/include/dtab.h
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
td (1)
but only to devices
that are not currently logged in).
See
.bd
init, login, and update
in section 1 for more information.

.ti -5
2.	The word "shake". This refers to RS-232 Clear-To-Send handshaking.
The system will use this type of handshaking only if requested (since
some devices do not support it). XON-XOFF (software) 
handshaking is done by default.
The init process sets or resets this mode under the same circumstances
as in #1 above. (See
.bd
printers
in section 4 for more information on hank, check if 
.bd
nfree 
is 100; if so, copy 
.bd
nfree 
and the 
.bd
free 
array into it, write it out, and set 
.bd
nfree 
to 0.

In any event, set 
.bd
nfree[nfree]
to the freed blocks's number and increment 
.bd
nfree.
.sp
.bd
Ninode 
is the number of free i-numbers in the inode array.
To allocate an i-node:
If 
.bd
ninode 
is greater than 0, decrement it and return 
.bd
inode[ninode].

If
.bd
ninode 
= 0, read the i-list and place
the number of all free inodes (up to 100) into the 
.bd
inode
array, then try again.  To free an i-node,
provided 
.bd
ninode 
is less than 100, place its number into 
.bd
inode[ninode]
and increment 
.bd
ninode.

If 
.bd
ninode 
is already 100, do not bother to enter the freed i-node into any table.
This list of i-nodes is used only to speed up the allocation process;
the information as to whether the inode is really free
or not is maintained in the inode itself.
.sp
.bd
Flock 
and 
.bd
ilock 
are flags maintained in the core copy of the file system while it is mounted;
their v.he "filesystem (5)               3/15/82               filesystem (5)"
.fo "                               -#-"
.in 5
.rm 65
.bd 
NAME
.in +5
.br
.bd
filesystem 
- format of UNIX version 6 file systems
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
Every file system storage volume,
(hard or floppy disk)
has a common format for certain vital information.
Every such volume is divided into a certain number
of 256 word (512 byte) blocks.
Block 0 is unused.

Block 1 is the super block.
Starting from its first word, the format of a super-block is as 
follows.

.nf
.bd 9
struct
	{
	unsigned	
		isize,
		fsize,
		nfree,
		free [100],
		ninode,
		inode [100],
.sp
.bd 3		
	char	flock,
		ilock,
		fmod;
.sp
.bd 2
	long	time;
	};
.sp 2
.fi
Isize is the number of blocks devoted to the i-list
which starts just after the super-block, in block 2.

Fsize is the first block not potentially available for allocation 
to a file.  These numbers
are used by the system to check for a bad block number.
If an impossible block number is allocaalues on disk are immaterial.
The value of 
.bd
fmod 
on disk is likewise immaterial;
it is used as a flag to indicate
that the super-block has changed and should be
copied to the disk during
the next periodic update of file system information.
.sp
.bd
Time 
is the last time the super-block of the file system was changed 
and is a long representation of the number of seconds that have 
elapsed since midnight
January 1st 1970 (GMT).
During a reboot, the time of the super-block for the root file 
system is used to set the system's idea of the time.
.sp
.bd
I-numbers 
begin at 1 and the storage for i-nodes begins in block 2.
Also, i-nodes are 32 bytes long,
so 16 of them fit into a block.
Therefore, i-node 
.bd
i 
is located in block 
.bd
(i + 31) / 16,
and begins 
.bd
32 * ((i + 31) (mod 16))
bytes form its start.
I-node 1 is reserved for
the root directory of the file system,
but no other i-number has a built-in meaning.
Each i-node represents one file.
The format of an i-node is as follows.
.sp 
.nf
.bd 5
strd-level indirect blocks points to a data block.
Notice that large files
are not marked by any mode bit, but by having 
.bd
addr[7]
non-zero.
Even though this scheme allows for more than 
33,554,432 (256 X 256 X 512) bytes per file,
the length of files is
stored in 24 bits.  In practice, a file can be at most 16,777,216
bytes long.

For block 
.bd
b 
in a file to exist, it is not necessary that all blocks less than 
.bd
b 
exist.  A zero block number in either  address words of the i-node,
or in an indirect block, indicates that the
corresponding block has never been allocated.
This type of missing block reads as if it contained all zero words.
.sp 2
.in -5
.bd
SEE ALSO
.in +5
.br
icheck (1), dcheck (1), fsck (1)
 is the super-user
shell prompt, and the ':' is edit's prompt.

.nf
# cd /etc                       Change directory to /etc.
# edit ttys                     Edit the ttys file.
"ttys" [reading] 19 lines       The editor prints this.
:/cent0                         Look for the line containing cent0.
uct
	{
	int	flags;
	char	nlinks,
		uid,
.sp
.bd 2		
		gid,
		size0;
.sp
.bd 2
	int	size1,
		addr[8],
.sp
.bd 3		
	long	actime,
		modtime;
	};
.sp 2
The flags are as follows:
.sp
.bd 6
100000	i-node is allocated
060000	2-bit file type:
	000000	plain file
	040000	directory
	020000	character-type special file
	060000  block-type special file
.sp
.bd 8
010000	large file
004000	set user-ID on execution
002000	ignored
000400	read permission for owner
000200	write permission for owner
000100	execute permission for owner
000070	read, write, execute permission for group
000007	read, write, execute permission for others
.sp
.fi
Special files are recognized by their flags, not by i-number.

A block-type special file is
one which can potentially be mounted as a file system,
a character-type special file cannot,
though it is not necessarily character-oriented.
For special files the high byte of the first
address word specifies the type of device and
the low byte specifies one of several devices of that
type.
The device ty.he "                   What's New in Micronix 1.6"
.in 12
.ti -8
What's new in Micronix 1.6
.br
Highlights: fancy memory management, networking, easier
printer installation.

.ti -8
help
.br
Some of the on-line documentation has been considerably expanded.
Try "help upm", "help lpr", "help printers", "help cables", "help network", and
"help ttys". Also, see the help documents on each of the programs
mentioned below.

.ti -8
recon
.br
A reconfiguration program makes it easy to add new terminals
or printers. Log in as the super-user and type recon.

.ti -8
upm
.br
More space, unlimited open files.
Easier printer hookup
(type the command "help ttys" for more information).
New documentation.

.ti -8
network
.br
The user sees the network simply as an extension of the
mail and cp commands. See below, and see the help pages on mail,
cp, and network.

.ti -8
fdj
.br
A floppy disk formatting program. For interactive use, just
type fdj with no arguments. Or type fdj ? for an explanation of how
to specify the options ope numbers of block and character special files overlap.

The address words of ordinary files and directories contain
the number of the blocks in the file
(if it is small)
or the number of indirect blocks (if the file is large).
Byte number 
.bd
N 
of a file
is accessed as follows:
.bd
N 
is divided by 512
to find its logical block number, use
.bd
b
as an example, in the file.  If the file is small
.bd
(flag 010000 is 0),
.bd
b 
must be less than 
.bd
8,
and the physical block number is 
.bd
addr[b].

If the file is large, 
.bd
b 
is divided by 256 to yield 
.bd
i.
If 
.bd
i 
is less than 
.bd
7,
then 
.bd
addr[i]
is the physical block number of the indirect block.
The remainder from the division yields the word in the indirect block
which contains the number of the block for the sought byte.
.sp
If
.bd
i 
is equal to 
.bd
7,
the file has become extra large and 
.bd
addr[7] 
is the address of a first indirect block.
Each word in this block is the number of a second level indirect
block;
each word in the seconn the command line.

.ti -8
mail
.br
When invoked with a network name, sends mail over the network.

.ti -8
cp
.br
Source or destination can be anywhere on the network.
A network pathname looks like  machine_name%path_name.

.ti -8
msgs
.br
A new system-wide bulletin board facility.
Messages are posted via the mail command (over the network if desired),
and are read via the msgs command.

.ti -8
last
.br
Gives login history and time accounting for each user.
Type "help last" for more information.

.ti -8
shell
.br
Runs CPM programs automatically (by invoking the CPM emulator
transparently). Restores terminal settings if a program changes them
and then bombs. Search-path hashing is now transparent to the user
(so that if you create a new command in the search path, the shell
will see this and re-hash).
Informs you of new mail and new messages.

.ti -8
lpr
.br
Interfaces to printers in a new way.
(/usr/spool/lpr/device is obselete. The information is in /etc/ttys)
Type the commands "help lpr" and "help ttys" fow (stamp it with the current time).

.ti -8
split
.br
Split a large file into several smaller ones.

.ti -8
ls
.br
A recursive list option has been added (ls -R).

.ti -8
down
.br
Now works even in single user mode.
It is IMPERITIVE that the system be brought down with "down",
and not just "sync", since there may be daemons running in the
background that need to be exorcised first.

.ti -8
rm
.br
-r option added.

.ti -8
ps
.br
Gives process size.

.ti -8
mount
.br
Now works with write-protected floppies, even without the
-r flag.  It informs you of the unexpected read-only status.
Mount allows you to omit the /dev/ prefix on the device name.

.ti -8
misc
.br
Changes have been made in the following programs or documentation:
badspots cc change clean far fsck more mv sum tty
type special file cannot,
though it is not necessarily character-oriented.
For special files the high byte of the first
address word specifies the type of device and
the low byte specifies one of several devices of that
type.
The device tyr more information.

.ti -8
kernel
.br
A running task now takes up only as much memory
as it needs (in 4K increments).
Exec now allows up to 2K bytes of arguments (up from 512).
The alarm system call has been added.
Swap I/O errors no longer cause a panic.
Kernel error messages are more readable.
Tty drivers have expanded capabilities (see below).

.ti -8
tty
.br
Terminal drivers:
"Cbreak" mode implemented.
"More" mode implemented
(scrolls 23 lines at a time and waits for a keystroke).
In all modes, Micronix
now sends Xon-Xoff, as well as reacts to it.
Now sends control-D's even in cooked mode.
A newline is still mapped to a cr-lf in "crmod" mode,
but a return is not. Thus when CP/M files (which end lines
with a cr-lf) are typed directly from Micronix, they will type
without double spacing (although they will still have garbage at
the end).

.ti -8
centronics
.br
Printer drivers are now included.
A cable is available by special
order that will connect a Centronix printer to a Decision parallel port.
Type the .he "                   Whats New in Micronix 1.61"
.in 12
.ti -8
The following files (and their on-line documentation)
have been changed:

.ti -8
/micronix.mw
.br
This is the micronix kernel for the mini-winchester controller.
(It is called micronix.mw on the stand-alone floppy. The name is changed
to micronix by the install script when the hard disk is initialized.)
The mini-wini drivers have been modified so that when a drive
is closed (or when the system is brought
down with the "down" command), the heads are sent
to the inner-most track. This is supposed to improve the
drives' survival odds during moving or shipping.
(Note that this only applies to drives that have been opened,
or accessed. Drives connected to the daisy-chain but never
accessed remain untouched.)

Also, the problem that resulted in the console warning message
"memory allocation fault" has been resolved, so that this message
should never appear again.

The djdma drivers can now distinguish between single
and double sided Morrow soft-sectocommand "help printers" for more information.

.ti -8
hddma
.br
Now runs 15% to 20% faster in heavily loaded situations.
Also, it was found that in certain cases, the hddma could hang
while waiting for data that never came. The software now prevents this.

.ti -8
hdca
.br
Due to space limitations, there are now two versions of the kernel;
one for the HDDMA controller, and one for the older HDCA.  If anyone
needs to run both in one system, he will have to stick with version
1.4.

.ti -8
mem
.br
The mem devive now reads and writes the first megabyte of
extended address memory instead of just kernel memory. Thus it can be
used to control memory-mapped devices.

.ti -8
edit
.br
Is now much faster with large files

.ti -8
diablo
.br
This program drives the diablo-standard parallel interface
on the Decision. Type the commands "help diablo" and "help ttys"
for more information.

.ti -8
form
.br
Two new commands: ".na" and ".ad".
Type the command "help form" for more information.

.ti -8
touch
.br
Make a file look nered diskettes (5 inch). This
means that the device name "/dev/mfa2" (which forces double-sided
status) is only needed for non-Morrow double sided diskettes.
In short, use "/dev/mfa" for all your operations on 5 inch diskettes,
both hard and soft sectored.

The stand-alone floppy can now be write-protected. It is shipped
write-protected, and should be left that way.

Finally, a bug has been fixed that sometimes led to crashes
on network or modem input.

.ti -8
/micronix.hd
.br
This is the corresponding micronix kernel for the HDCA controller.
It has been changed as above.

.ti -8
/bin/upm
.br
The cpm emulator.
Upm now supports "terminal emulation".
When upm powers up, it checks a system-wide data base
that describes the inner workings of your terminal.
It then intercepts terminal-control codes from your
applications program (eg WordStar) and translates them
into the codes appropriate for your terminal.
This should make application installation and terminal
reconfiguration much easier. See the Micronix Installabr
The C compiler driver. The -cpm option now works correctly to compile
a program for cpm (rather than Unix). Also, the -S option to produce
assembler source is now recognized. Type "help cc" for details.

.ti -8
/include/stdio.h
.br
This is the #include header to be used with C programs that use the
standard I/O library. The cleareof and clearerr macros have been
corrected.

.ti -8
/bin/fdj
.br
The floppy disk formatting program has had a minor menu face-lift.
Also, the ability to deal with CPM user numbers has been added.
See fdj (1) for details.

.ti -8
/bin/mkfs
.br
Mkfs has been modified so as not to write on block 0 of the new
file system. This is necessary to preserve formatting information
written there by the fdj program.

.ti -8
/bin/edit
.br
The Micronix line editor has been speeded up, and
a bug has been fixed in the global/regular-expression/delete operation.

.ti -8
/bin/fsck
.br
A bug has been fixed that sometimes led to segmentation violations
during free-list checking.

.ti -8
/etc/init
.br
tion
manual, recon (1), upm (1), terminals (5), and ttys (5).

The stack initially handed to a cpm application program
has been moved to a safer location.

When a cpm
program is run in the background, it no longer ignores
the keyboard interrupt signal (generated by hitting the
DELETE or RUBOUT key).

.ti -8
/bin/sh
.br
The full micronix shell. The built-in commands "shift" and "goto"
have been added. This allows more versatile shell scripts.
Also, the shell's automatic "sync" after each command has been
removed in favor of an update daemon that runs every 30 seconds
when the system is in multi-user mode. The advantage is that the
shell responds more quickly. The disadvantage is that when in
single user mode, the system will be less forgiving of improper
RESETs or power downs.
Finally, the shell's built-in type command now quits when it sees
a control-z in the file.
This is the CP/M end-of-text-file marker. Thus CP/M text files
now "type" properly at the terminal.
Type "help sh" for details.

.ti -8
/bin/fp
.bThe init process will now refuse to spawn login processes for
non-existent IO ports, no matter what the ttys file says.

.ti -8
/usr/man/man0/new.0
.br
This file contains the on-line documentation of new features.
It has been split into two files, new16.0 and new161.0
for versions 1.6 and 1.61.
These are viewed by typing "help new16" and "help new161".
an example, in the file.  If the file is small
.bd
(flag 010000 is 0),
.bd
b 
must be less than 
.bd
8,
and the physical block number is 
.bd
addr[b].

If th 00 nul    10 dle    20 sp     30  0     40  @     50  P     60  `     70  p
 01 soh    11 dc1    21 !      31  1     41  A     51  Q     61  a     71  q
 02 stx    12 dc2    22 "      32  2     42  B     52  R     62  b     72  r
 03 etx    13 dc3    23 #      33  3     43  C     53  S     63  c     73  s
 04 eot    14 dc4    24 $      34  4     44  D     54  T     64  d     74  t
 05 enq    15 nak    25 %      35  5     45  E     55  U     65  e     75  u
 06 ack    16 syn    26 &      36  6     46  F    r
This program corresponds to the Unix program "tp" (which does tape
backups). It is an alternative to the micronix program "td" for
doing floppy backups. It is somewhat faster, and unlike td, it is
able to split large files across floppies. It has more options
to learn than td, and it is not yet menu-driven.
It is documented on-line (type help fp).

.ti -8
/bin/tree
.br
This is a new command that draws a picture of the hierarchical file system.
Type "help tree" for details.

.ti -8
/bin/field, /bin/paste, and /bin/wc
.br
These are new utilities.
Type 'help field', 'help paste', and 'help wc' for more info.

.ti -8
/bin/chsh and /bin/newuser
.br
These programs have been eliminated in favor of the more general
account program. See account (1).

.ti -8
/bin/cmp
.br
The compare utility has a new capability: if asked to compare
two directories, it will compare each file, and tell of files
that are unique to each directory.

.ti -8
.br
/bin/cu
.br
Cu now recognizes legitimate baud rate arguments.

.ti -8
/bin/cc
. 56  V     66  f     76  v
 07 bel    17 etb    27 '      37  7     47  G     57  W     67  g     77  w
 08 bs     18 can    28 (      38  8     48  H     58  X     68  h     78  x
 09 ht     19 em     29 )      39  9     49  I     59  Y     69  i     79  y
 0a nl     1a sub    2a *      3a  :     4a  J     5a  Z     6a  j     7a  z
 0b vt     1b esc    2b +      3b  ;     4b  K     5b  [     6b  k     7b  {
 0c np     1c fs     2c ,      3c  <     4c  L     5c  \     6c  l     7c  |
 0d cr     1d gs     2d -      3d  =     4d  M     5d  ]     6d  m     7d  }
 0e so     1e rs     2e .      3e  >     4e  N     5e  ^     6e  n     7e  ~
 0f si     1f us     2f /      3f  ?     4f  O     5f  _     6f  o     7f del

000 nul   020 dle   040 sp    060  0    100  @    120  P    140  `    160  p
001 soh   021 dc1   041 !     061  1    101  A    121  Q    141  a    161  q
002 stx   022 dc2   042 "     062  2    102  B    122  R    142  b    162  r
003 etx   023 dc3   043 #     063  3    103  C    123  S    143  c    1 N#F! N#F.! ! N#F.! 9~#fo"! 9~#fo" "! 9~#fo"! 9~#fo"   "! ~#fo"! "*~#*~#fo"*~**#"*~*#"*6 *MD*##"! N#F*i`"*"! ~#fo"*MD! ~#fo"*~-*#"*! yOx#G!w#w!~#~ y!N#F!~w#~ wO!  ! N#F
i`"!~#* 	~D*~* 	! i`":!>> #* 	6 ! ~#foMD! >w>#w! #~%! ~#~ +  ! N#F!, \	"* 	~T  *MD!  !	 9~+~{!
 9N#F	!
 9~w#~w!	 9~w+~wb! 9q#p!  9!9***i`!"""! 9N#F###q#p+++q! 9N#F#q#pV2.1: copyright (c) 1979 by Whitesmiths, Ltd.             @                                                                                                                                                     @             C                                 63  s
004 eot   024 dc4   044 $     064  4    104  D    124  T    144  d    164  t
005 enq   025 nak   045 %     065  5    105  E    125  U    145  e    165  u
006 ack   026 syn   046 &     066  6    106  F    126  V    146  f    166  v
007 bel   027 etb   047 '     067  7    107  G    127  W    147  g    167  w
010 bs    030 can   050 (     070  8    110  H    130  X    150  h    170  x
011 ht    031 em    051 )     071  9    111  I    131  Y    151  i    171  y
012 nl    032 sub   052 *     072  :    112  J    132  Z    152  j    172  z
013 vt    033 esc   053 +     073  ;    113  K    133  [    153  k    173  {
014 np    034 fs    054 ,     074  <    114  L    134  \    154  l    174  |
015 cr    035 gs    055 -     075  =    115  M    135  ]    155  m    175  }
016 so    036 rs    056 .     076  >    116  N    136  ^    156  n    176  ~
017 si    037 us    057 /     077  ?    117  O    137  _    157  o    177 del
en the system is in multi-user mode. The advantage is that the
shell responds more quickly. T         C                                          C                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        tails.

.ti -8
/bin/fp
.br
This program corresponds to the Unix program "tp" (which does tape
backups). It is an alternative to the micronix program "td" for
doing floppy backups. It is somewhat faster, and unlike td, it is
able to split large files across floppies. It has more options
to learn than td, and it is not yet menu-driven.
I* 2! 9N#F#^#V#~#fo ",kb"*i`"(OGlpr: Command not found
 -i lpr /usr/bin/lpr -i lpr /bin/lpr : No such file or directory
 ! ".*.: OG	6 *.i`"0*0ty*.!w!  *0!g!j!n!
 9!  *0!S!V!Z!
 9!;! ~#fo"*~I*~
L! cL*~OGc*#"-! N#F! / : Drive not designated
 ! ~#fo"**i`"*~a*>z*~A*>Z* 	~:* 	~*~OG!	}22:222*##": 22:2OGi`)*5~#fo	~#fo"3!3~#]:2OG!A 	c!|!  *!z*3!7r!
 9*y!7MD! ~#fo"*~*> *~*i`*		"!::#*> *~*#"*MD*6 :2: 2! ~#fo"*~q**~A\*>Z\*~OG!  	MDd*~OGyw*#"-!! N#FOx   ! ~#fo"*~*> *~   *#"usage: spool file
 !!}22:222*##": 22:2OGi`)*5~#fo	~#fo"3!3~#]:2OG!A 	c!|!  *!z*3!7r!
 9*y!7MD! ~#fo"*~*> *~*i`*		"!::#*> *~*#"*MD*6 :2: 2! ~#fo"*~q**~A\*>Z\*~OG!  	MDd*~OGyw*#"-!! N#FOx   ! ~#fo"*~*> *~   *#"usage: spool file
 !! N#F! N#F.! ! N#F.! 9~#fo"! 9~#fo" "! 9~#fo"! 9~#fo"   "! ~#fo"! "*~#*~#fo"*~**#"*~*#"*6 *MD*##"! N#F*i`"*"! ~#fo"*MD! ~#fo"*~-*#"*! yOx#G!w#w!~#~ y!N#F!~w#~ wO!  ! N#F
i`"!~#* 	~D*~* 	! i`":!>> #* 	6 ! ~#foMD! >w>#w! #~%! ~#~ +  ! N#F!, \	"* 	~T  *MD!  !	 9~+~{!
 9N#F	!
 9~w#~w!	 9~w+~wb! 9q#p!  9!9***i`!"""! 9N#F###q#p+++q! 9N#F#q#pV2.1: copyright (c) 1979 by Whitesmiths, Ltd.             @                                                                                                                                                     @             C                                          C                                          C                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    bin/field and /bin/paste
.br
These are two new utilities.
Type 'help field' and 'help paste' for more info.

.ti -8
/bin/cmp
.br
The compare utility has a new capability: if asked t