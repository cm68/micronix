еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееереееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее ABOOT&  ASM  =	
     BIOS    ASM   `           BOOT    ASM                  BOOTMW  ASM   ?             CBIOS   ASM   E            CBIOS&  ASM  Ђ !"#$%&'()*+,- CBIOS&  ASM  Ђ./0123456789:;<= CBIOS&  ASM  Ђ>?@ABCDEFGHIJKLM CBIOS&  ASM  ЂNOPQRSTUVWXYZ[\] CBIOS&  ASM	  ^_`abcdef        DEBLOCK ASM   Pghijk            DUMP    ASM   !lmn              FORMATDJASM  Ђopqrstuvwxyz{|}~ FORMATDJASM                  HYTYPE  ASM  ~ЂЃ‚ѓ„…†‡€‰Љ‹ЊЌЋЏ HYTYPE  PRL   ђ               ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*****************************************************************
*								*
*	 Morrow Designs CP/M vers 2.2 Cold Boot Loader.		*
*		  Cbios revision E.2,  3/4/82.			*
*								*
* The following routines will boot CP/M from the		*
* Disk Jockey 2D Rev. B 8 inch disk controller (DJ2D/B),	*
* Disk Jockey DMA 8 + 5 1/4 inch controller (DJDMA),		*
* Hard Disk Controller revision 3 (HDC3),			*
* or the Hard Disk DMA (HDDMA) disk controllers.		*
*								*
* Provisions have been made for a Micronix boo
*	0	 7	 c00	9200	 2			*
*	0	 8	 c80	9280	13			*
*	0	 9	 d00	9300	 3			*
*	0	10	 d80	9380	14			*
*	0	11	 e00	9400	 4			*
*	0	12	 e80	9480	15			*
*	0	13	 f00	9500	 5			*
*	0	14	 f80	9580	16			*
*	0	15	1000	9600	 6			*
*	0	16	1080	9680	17			*
*	0	17	1100	9700	 7			*
*	0	18	1180	9780	18			*
*	0	19	1200	9800	 8			*
*	0	20	1280	9880	19			*
*	0	21	1300	9900	 9	BDOS		*
*	0	22	1380	9980	20			*
*	0	23	1400	9a00	10			*
*	0	24	1480	9a80	21			*
*	0	25	1500	9b00	11			*
*	0	26	1580	9b80	22			*
*						ack 0, sector 5 and		*
* continues through to track 1 sector 3.  Only the first	*
* 3/4 K bytes of track 1, sector 3 is loaded since CP/M		*
* requires that the warm boot loader load up to the start	*
* of (but not past) the Cbios jump table.			*
*								*
*								*
*	     8 inch floppy disk boot loader for the		*
*	     Morrow Designs Disk Jockey DMA (DJDMA)		*
*								*
* The loading is identical to that of of the DJ2DB except	*
* that the loader itself is loaded at 80h and the 'order'	*
* ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееt loader.		*
* This loader always gets loaded to 0100h.			*
*								*
*	     8 inch floppy disk boot loader for the		*
*            Morrow Designs Disk Jockey 2D/B (DJ2DB)		*
*								*
* The 'order' column is the interleave sequence used by the	*
* loader during the load.					*
*								*
*   track   sector    sysgen	load order	Name		*
*								*
*	0	 1	 900	ff00	 0	Boot loader	*
*	0	 2	 980			Unused		*
*	0	 3	 a00					*
*	0	 4	 a80					*
*	0	 5	 b00	9100	 1	CCP		*
*	0	 6	 b80	9180	12			*		*
* Track 1 is recorded in double density format.  There are	*
* 1024 bytes per sector.					*
*								*
*	1	 1	1600	9c00	 4			*
*	1	 2	1a00	a000	 1			*
*	1	 3	1e00	a400	 5	CBIOS (@ a700h)	*
*	1	 4	2200	a800	 2			*
*	1	 5	2600	ac00	 6			*
*	1	 6	2a00	b000	 3			*
*	1	 7	2e00	b400	 7			*
*	1	 8	3200	b800		Unused		*
*								*
* Three spare sectors (track 0, sectors 2 to 4) have been	*
* provided for a more advanced boot loader at a later date.	*
*								*
* The warm boot loader starts on trcolumn does not apply.  The DJDMA is capable of loading a	*
* complete track at a time and thus it merely zaps the		*
* tracks in all at once.					*
*								*
*								*
*	   5 1/4 inch floppy disk boot loader for the		*
*	     Morrow Designs Disk Jockey DMA (DJDMA)		*
*								*
* The cold boot loader (track 0, sector 0) is loaded into	*
* RAM at 80h.  This loader will start loading from track 0,	*
* sector 1 and stops at track 1, sector 9.  The load		*
* sequence is as follows:					*
*							ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее	*
*   track   sector    sysgen	load order	Name		*
*	0	 0	 900	  80	 0	Cold boot	*
*	0	 1	 b00	9500	 1	CCP		*
*	0	 2	 d00	9700	 2			*
*	0	 3	 f00	9900	 3			*
*	0	 4	1100	9b00	 4			*
*	0	 5	1300	9d00	 5	BDOS		*
*	0	 6	1500	9f00	 6			*
*	0	 7	1700	a100	 7			*
*	0	 8	1900	a300	 8			*
*	0	 9	1b00	a500	 9			*
*								*
*	1	 0	1d00	a700	10			*
*	1	 1	1f00	a900	11			*
*	1	 2	2100	ab00	12	CBIOS		*
*	1	 3	2300	ad00	13			*
*	1	 4	2500	af00	14			*
*	1	 5	2700	b100	15			*
*	1	 6	2900	b300	16			*
*	* for the loader.  This cold boot loader will start loading	*
* the CCP from track 0, sector 2 and will finish up with	*
* the last part of the Cbios on track 0, sector 20.		*
*								*
*   track   sector    sysgen	load order	Name		*
*	0	 1	 900	fc00	 1	Cold boot	*
*	0	 2	 b00	9500	 2	CCP		*
*	0	 3	 d00	9700	 3			*
*	0	 4	 f00	9900	 4			*
*	0	 5	1100	9b00	 5			*
*	0	 6	1300	9d00	 6	BDOS		*
*	0	 7	1500	9f00	 7			*
*	0	 8	1700	a100	 8			*
*	0	 9	1900	a300	 9			*
*	0	10	1b00	a500	10			*
*	0	11	s is hardly	*
* necessary on a hard disk.					*
*								*
*								*
*	Shugart SA1000 disk interface boot loader for the	*
*	 Morrow Designs Hard Disk DMA controller (HDDMA)	*
*								*
*   track   sector    sysgen	load order	Name		*
*	0	 1	 900	 100	 0	Cold boot + CCP	*
*	0	 2	 d00	9300	 1			*
*	0	 3	1100	9700	 2			*
*	0	 4	1500	9b00	 3	Bdos (@ 9d00)	*
*	0	 5	1900	9f00	 4			*
*	0	 6	1d00	a300	 5			*
*	0	 7	2100	a700	 6	Cbios		*
*	0	 8	2500	ab00	 7			*
*	0	 9	2900	af00	 8			*
*								*
 to where the	*
* various parts of of the operating system are in memory.	*
*								*
* The only changes to the map that I see in the future is	*
* the increasing the space for the uninitialized tables		*
* following the Cbios.  The amount of code and table space	*
* that can actually be loaded from the disk is fixed by the	*
* amount of space available on the system tracks.		*
*								*
* Our most restrictive (smallest) drive is the 5 1/4 inch	*
* 'minnie floppy'.  This drive has 20 512 byte see	*
* (lot?) of code shuffeling or in the creation of a Cbios	*
* that simply will not fit on a small disk drive.		*
*								*
*	sysgen	48k	56k	60k	62k	64k		*
*	 image	CP/M	CP/M	CP/M	CP/M	CP/M		*
*								*
*	 900	~~~~	~~~~	~~~~	~~~~	~~~~	Loader	*
*	 b00	9500	b500	c500	cd00	d500	CCP	*
*	1300	9d00	bd00	cd00	d500	dd00	BDOS	*
*	2100	ab00	cb00	db00	e300	ed00	Cbios	*
*	3100	bb00	db00	eb00	f300	fb00	Tables	*
*	35ff	bfff	dfff	efff	f7ff	ffff	The End	*
*								*
*	~~~~	8d00	ad00	bd00	c500	cd00	DDT	*1	 7	2b00	b500	17			*
*	1	 8	2d00	b700	18			*
*	1	 9	2f00	b900	19			*
*								*
* The warm boot starts from track 0 sector 1 and continues	*
* through to track 1 sector 1.					*
*								*
*								*
*	Shugart SA4000 disk interface boot loader for the	*
*	Morrow Designs Hard Disk Controller rev. 3 (HDC3)	*
*								*
* The cold boot loader (track 0, sector 1) is loaded into	*
* RAM in the very last part of the Cbios.  This area is		*
* used for uninitialized tables and thus is a safe place	*
1d00	a700	11			*
*	0	12	1f00	a900	12			*
*	0	13	2100	ab00	13	CBIOS		*
*	0	14	2300	ad00	14			*
*	0	15	2500	af00	15			*
*	0	16	2700	b100	16			*
*	0	17	2900	b300	17			*
*	0	18	2b00	b500	18			*
*	0	19	2d00	b700	19			*
*	0	20	2f00	b900	20			*
*	0	21	3100			Unused		*
*								*
* The warm boot load sequence starts at track 0, sector 2	*
* and goes straight through to sector 12.  There is still	*
* plenty of room left in this loader for more advanced		*
* things like sector interleaving although thi*	1	10	2d00	b300	 9			*
*								*
* Since 1k byte sectors were implemented on this disk;  	*
* track 0, sector 1 contains both the cold boot loader and	*
* part of the CCP.  The cold boot loader relocates this		*
* peice of the CCP to it proper resting place as part of	*
* the boot process.						*
*								*
*****************************************************************

*****************************************************************
*								*
* The following table gives a general idea asctors for	*
* a total of 10k bytes on the system tracks.  The 8 inch	*
* floppy disk drive is also very close to being filled up.	*
*								*
* Since 512 bytes are reserved for the cold boot loader we	*
* have a total of 9.5k bytes for the operating system.  Out	*
* of this 5.5k bytes are used by the (CCP + BDOS) leaving	*
* us with a total of 4k bytes of loaded code and data space	*
* to play with.  Right now we are using all of this space	*
* so any major additions will have to result in a littl
*								*
*****************************************************************
	
micron	equ	0		;Set to 1 for Micronix boot loader

	if	micron eq 0

msize	equ	48		;Memory size of target CP/M
			
biosln	equ	16h		;BIOS length
codlen	equ	11h		;Code length
	
ccpln	equ	800h
bdosln	equ	0e00h

size	equ	(msize*1024)	
ccp	equ	size-(biosln*100h+ccpln+bdosln)
bdos	equ	ccp+ccpln
bios	equ	ccp+ccpln+bdosln

cboot	equ	bios		;Cold boot address for CP/M
loaddr	equ	ccp		;Load address for floppy

	else			ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее;Micronix boot loader

cboot	equ	0100h		;Cold boot address for the loader
loaddr	equ	0100h
	
				;If the load address is moved forward from
				;0100 then the starting extended address for
				;the djdma boot loader should be adjusted.
	endif

retries	equ	10		;Maximum # of disk retries

*****************************************************************
*								*
* Only one of the following equates should be set.  The		*
* others sould be 0.  These equates define the boot loader	*
* that is t			*
*****************************************************************

	if	maxhd ne 0
hdorg	equ	50h		;Hard Disk Controller
hdstat	equ	hdorg		;Hard Disk Status
hdcntl	equ	hdorg		;Hard Disk Control
hddata	equ	hdorg+3		;Hard Disk Data
hdfunc	equ	hdorg+2		;Hard Disk Function
hdcmnd	equ	hdorg+1		;Hard Disk Command
hdreslt	equ	hdorg+1		;Hard Disk Result
retry	equ	2		;Retry bit of result
tkz	equ	1		;Track zero bit of status
opdone	equ	2		;Operaction done bit of status
complt	equ	4		;Complete bit of n
null	equ	0fch		;Null command
idbuff	equ	0		;Initialize data command
isbuff	equ	8		;Initialize header command
rsect	equ	1		;Read sector command
wsect	equ	5		;Write sector command
	endif

*****************************************************************
*								*
* The following equates are for the Hard Disk DMA.		*
*								*
*****************************************************************
	
	if	maxmw ne 0
cyl	equ	153		;Specifications for a Seagate Technology 506
heads	equ	4		;Number of hmands
dmaread	equ	0		;Read sector
dmawrit	equ	1		;Write sector
dmarhed	equ	2		;Find a sector
dmawhed	equ	3		;Write headers (format a track)
dmalcon	equ	4		;Load disk parameters
dmassta	equ	5		;Sense disk drive status
dmanoop	equ	6		;Null controller operation

reset	equ	54h		;Reset controller
attn	equ	55h		;Send a controller attention

chan	equ	50h		;Default channel address
stepout	equ	10h		;Step direction out
stepin	equ	0		;Step direction in
band1	equ	40h		;No precomp, high current
band2	equoutines
tkzero	equ	origin+9h	;Track 0 seek
trkset	equ	origin+0ch	;Set track
setsec	equ	origin+0fH	;Set sector
setdma	equ	origin+12h	;Set DMA address
dread	equ	origin+15h	;Read sector
dmast	equ	origin+24h	;Get DMA address
status	equ	origin+27h	;Disk status
dskerr	equ	origin+2ah	;Flash error light
setden	equ	origin+2dh	;Set density
	endif

*****************************************************************
*								*
* The following equates are for the Disk Jockey DMA if wanted.	*
*								*
***o be used.						*
*								*
******************************************************************

maxhd	equ	0		;Set to boot an HDC3 controller
maxmw	equ	1		;Set to boot a HDDMA controller
maxfd	equ	0		;Set to boot a DJ2D/B controller
maxdm	equ	0		;Set to boot a DJDMA controller with 8 inch
maxmf	equ	0		;Set to boot a DJDMA controller with 5 1/4 inch


*****************************************************************
*								*
* The following equates are for the Hard Disk Controller 3.	*
*					status
tmout	equ	8		;Time out bit of status
wfault	equ	10h		;Write fault bit of status
drvrdy	equ	20h		;Drive ready bit of status
indx	equ	40h		;Index bit of status
pstep	equ	4		;Step bit of function
nstep	equ	0fbh		;Step bit mask of function
hdrlen	equ	4		;Sector header length
secln	equ	512		;Sector data length
wenabl	equ	0fh		;Write enable
wreset	equ	0bh		;Write reset of function
scenbl	equ	5		;Controller control
dskclk	equ	7		;Disk clock for control
mdir	equ	0f7h		;Direction mask for functioeads per cylinder
spt	equ	9		;Sectors per track
precomp	equ	64		;Cylinder to start write precomensation
lowcurr	equ	128		;Cylinder to start low current
stepdly	equ	30		;Step delay (0-12.7 milliseconds)
headdly	equ	20		;Settle delay (0-255 milliseconds)
sectsiz	equ	7		;Sector size code (must be 3 for this Cbios)
				; 0 =  128 byte sectors
				; 1 =  256 byte sectors
				; 3 =  512 byte sectors
				; 7 = 1024 byte sectors (default for CP/M)
				; f = 2048 byte sectors

				;Define controller com	0c0h		;Precomp, high current
band3	equ	80h		;precomp, low current
track0	equ	1		;Track zero status
wfault	equ	2		;Write fault from drive
dready	equ	4		;Drive ready
	endif

*****************************************************************
*								*
* The following equates are for the Disk Jockey 2D/B.		*	
*								*
*****************************************************************

	if	maxfd ne 0
origin	equ	0f800h		;Orgin of DJ 2D Mod B PROM
djram	equ	origin+400h
				;Disk Jockey 2D Mod B r**************************************************************

	if	(maxdm ne 0) or (maxmf ne 0)

djkick	equ	0efh		;Kick port for DJDMA controller
channl	equ	50h
	
	if	maxdm ne 0	;8 inch boot loader
trkoff	equ	22*128		;Number of bytes loaded from track 0
	else			;5 1/4 inch boot loader
trkoff	equ	9*512		;Number of bytes loaded from track 0
	endif

setdma	equ	23h		;Set DMA address
djhalt	equ	25h		;Halt controller
djbran	equ	26h		;Branch controller command
redtrk	equ	29h		;Read track command
ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее
	endif

*****************************************************************
*								*
* Define the origin address for the various boot loaders.	*
*								*
*****************************************************************

	if	maxhd ne 0	;HDC3
boot	equ	bios+(biosln*100h)-512	;Very last part of CP/M system
	endif

	if	maxmw ne 0	;HDDMA
boot	equ	100h
	endif

	if	maxfd ne 0	;DJ2D/B
boot	equ	djram+300h	;Upper 3/4 of on board floppy RAM
	endif

	if	(maxdm ne 0) or (maxmf ne 0)	;DJDMA
boot	lxi	d,loaddr
	lxi	b,200h
movlop:	mov	a,m		;Get a byte
	stax	d		;Save it
	inx	h		;Bump pointers
	inx	d
	dcx	b		;Bump counter
	mov	a,b		;Test for end
	ora	c
	jnz	movlop
	lxi	b,10*100h+2	;B = sector count, C = sector #
	call	clodhd
	jmp	cboot		;Go to CP/M
	endif

clodhd	push	b		;Save sector and count
	mov	a,c		;Load sector
	sta	hdsec
	lxi	h,loaddr-200h	;Get DMA address (self modifying)
cdmahd	equ	$-2		;Storage for previous DMA address
	if	maxhd ne 0
	lxi	d,200h		;Offset to new DMA address.		*
*								*
*****************************************************************

	if	maxhd ne 0	;Low level HDC3 drivers
crdhd	lxi	b,retries*100h+1 ;Maximum # of attempts
crhd	push	b		;Save error count
	call	hdread		;Attempt the read
	pop	b		;Restore the error count
	rnc			;Return if no error
	dcr	b		;Update error count
	jnz	crhd		;Try again if not too many errors
	jmp	$		;Dynamic error halt

hdread	call	hdprep		;Prepare the sector header image
	rc			;Error exit
	mvi	a,rsect		;Read sector c for command to finish
	mov	b,a
	ani	opdone
	jz	process
	mvi	a,dskclk	;Turn on Disk Clock
	out	hdcntl
	in	hdstat
	ani	tmout		;Timed out ?
	stc
	rnz
	in	hdreslt
	ani	retry		;Any retries ?
	stc
	rnz
	xra	a		;No error exit
	ret

hdprep	in	hdstat		;Is Drive ready ?
	ani	drvrdy
	stc
	rnz
	mvi	a,isbuff	;Initialize pointer to header buffer
	out	hdcmnd
	mvi	a,null
	out	hdfunc		;Select drive A
	xra	a
	out	hddata		;Form head byte
	out	hddata		;Form track byte
	mvi	a,0		;Form sector byte
hdcr	b		;Update error count
	jnz	crhd		;Try again if not too many errors
error	jmp	$		;Dynamic error halt

hdsetup	shld	dmadma		;Set up DMA address
	call	hdreset		;Reset controller
	lda	hdsec		;Set logical sector number
	dcr	a		;Range is actaully 0-16
	call	divspt		;Figure out head number -> (c)
	adi	spt		;Make real sector number
	sta	dmarg3
	mov	a,c
	sta	dmarg2		;Save head number
	cma			;Negative logic for the controller
	ani	7		;3 bits of head select
	rlc			;Shove over to bits 2 - 4
	rlc
	equ	80h
	endif

offset	equ	900h-boot	;DDT offset

	org	boot

*****************************************************************
*								*
* Cold Boot loader for a hard disk.				*
*								*
*****************************************************************

	if	(maxhd ne 0) or (maxmw ne 0)

	lxi	sp,cstkhd	;Set up stack at end of this sector

	if	maxhd ne 0
	lxi	b,19*100h+2	;B = sector count, C = sector #
	call	clodhd
	jmp	cboot		;Go to CP/M
	else
	lxi	h,boot+200h	;Copy part of CCP up
	
	else
	lxi	d,400h
	endif
	dad	d		;Add in offset, HL = new DMA address
	shld	cdmahd		;Save new DMA address
	call	crdhd		;Attempt a read
	pop	b		;Recover sector number and count
				;	B = count, C = number
	dcr	b		;Update sector count
	rz			;All done ?
	inr	c		;Bump sector number
	jmp	clodhd		;Continue reading

*****************************************************************
*								*
* crdhd does the actual read from the controller, the DMA	*
* address and sector # have already been set upommand
	out	hdcmnd
	call	process		;Process the read
	rc			;Error exit
	xra	a		;Pointer to data buffer
	out	hdcmnd
	mvi	b,secln/4	;Number of bytes to read
	lhld	cdmahd		;Get destination of data
	in	hddata		;Two dummy data bytes
	in	hddata
rtloop	in	hddata		;Move four bytes
	mov	m,a		;Byte one
	inx	h
	in	hddata		;Byte two
	mov	m,a
	inx	h
	in	hddata		;Byte three
	mov	m,a
	inx	h
	in	hddata		;Byte four
	mov	m,a
	inx	h
	dcr	b		;Update byte count
	jnz	rtloop
	ret

process	in	hdstat		;Waitdsec	equ	$-1
	out	hddata
	mvi	a,80h		;Form Key
	out	hddata
	mvi	a,dskclk	;Turn on Disk clock
	out	hdcntl
	mvi	a,wenabl	;Write enable on
	out	hdcntl
	ret

	org	boot+200h-2	;Last word on sector is load address

cstkhd	equ	$
	dw	boot
	endif

	if	maxmw ne 0	;Low level HDDMA routines
crdhd	call	hdsetup		;Set up parameters
	lxi	b,retries*100h+1 ;Maximum # of attempts
crhd	push	b		;Save error count
	call	hdissue		;Attempt the read
	pop	b		;Restore the error count
	rnc			;Return if no error
	sta	dmasel1		;Save in command channel head select
	ret

divspt	mvi	c,0		;Clear head counter
divsptx	sui	spt		;Subtract a tracks worth of sectors
	rc			;Return if all done
	inr	c		;Bump to next head
	jmp	divsptx

hdreset	mvi	a,(ret)		;One time code
	sta	hdreset
	out	reset		;Send reset pulse to controller
	lxi	h,dmachan	;Address of command channel
	shld	chan		;Default channel address
	xra	a
	sta	chan+2		;Clear extended address byte
	xthl			;Wait for reset (around 10 uSEC's)
	xthl
	call	hdissееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееue		;Do load constants
	jc	error		;Controller not present
	mvi	a,dmassta	;Sense status command
	sta	dmaop
rdychek	call	hdissue
	ani	dready		;Check for drive ready
	jnz	rdychek		;Loop if not ready
	lxi	h,0ffffh
	shld	dmastep		;Do recalibrate
	call	hdissue
	lxi	h,0
	shld	dmastep		;Clear step counter
	shld	dmarg0		;Clear cylinder #
	shld	dmarg3		;Clear sector # + read disk command
	ret

hdissue	lxi	h,dmastat	;Status byte
	mvi	m,0
	out	attn		;Start controller
	lxi	d,0		;Time out counter
	mov select
dmadma	dw	0		;DMA address
	db	0		;Extended address
dmarg0	db	0		;First argument
dmarg1	db	stepdly		;Second argument (stepping time)
dmarg2	db	headdly		;Third argument (Settle time)
dmarg3	db	sectsiz		;Fourth argument (Sector size)
dmaop	db	dmalcon		;Operation code
dmastat	db	0		;Controller status byte
dmalnk	dw	dmachan		;Link address to next command channel
	db	0		;extended address

	org	boot+200h
cstkhd	equ	$		;Stack area at end of sector
	endif	
	endif

***************************r-80h	;Memory address of sector - 100h
nxtdma	equ	$-2
	shld	newdma
nowrap	sta	newsec		;Save the updated sector #
	mov	c,a
	call	setsec		;Set up the sector
	lxi	h,loaddr-100h	;Memory address of sector - 100h
newdma	equ	$-2
	lxi	d,100h		;Update DMA address
secsiz	equ	$-2
	dad	d
nowrp	shld	newdma		;Save the updated DMA address
	mov	b,h
	mov	c,l
	call	setdma		;Set up the new DMA address
	lxi	b,retries*100h+0;Maximum # of errors, track #
nxtrty	equ	$-2
fread	push	b
	call	trkset		;Set up the proa
	lxi	h,loaddr+0300h	;DMA start address for second revolution - 2048
	shld	nxtdma
	lxi	h,2048		;Difference between DMA addresses
	shld	secsiz
	lxi	h,retries*100h+1;Maximum # of errors, track #
	shld	nxtrty
	jmp	t0boot		;Go load in track 1
	endif

*****************************************************************
*								*
* Cold boot loader for the Disk Jockey DMA controller		*
*								*
*****************************************************************

	if	(maxdm ne 0) or (maxmf ne 0)	;Sep if load was 'ok'
	mov	m,c		;Load 'loaded' flag
	cmp	b		;Check for 'ok' status
	jz	djcont		;Skip if load ok
	inr	m		;Make flag = 0
	inr	d		;Bump error counter
djcont:	dcr	e		;Bump sector count
	inx	h		;Bump table pointer
	jnz	djloop
	mov	a,d		;Check out error counter
	ora	a
	jz	cboot		;Start CP/M if no errors
	dcr	m		;Drop retry counter
	jnz	djstrt		;Retry load operation
	jmp	$		;Dynamic error halt

commnd:	db	setdma		;Set DMA address
	dw	loaddr-512	;Start at CCP
	if	micron eq 0
	db	0		;	b,e		;Controller busy status
hdiloop	mov	a,m		;Get status
	ora	a		;Set up CPU flags
	rm			;Return no error (carry reset)
	stc
	rnz			;Return error status
	xthl			;Waste some time
	xthl
	xthl
	xthl
	dcx	d		;Bump timeout counter
	mov	a,d
	ora	e
	jnz	hdiloop		;Loop if still busy
	stc			;Set error flag
	ret

hdsec	db	0		;Currently selected sector

dmachan	equ	$		;Command channel area
dmasel0	db	10h		;Drive select (step out, drive 0)
dmastep	dw	0		;Relative step counter
dmasel1	db	0		;Head**************************************
*								*
* Cold boot loader for the Disk Jockey 2D Revision B controller	*
*								*
*****************************************************************

	if	maxfd ne 0
t0boot	mvi	a,5-2		;First sector - 2
newsec	equ	$-1
	inr	a		;Update sector #
	inr	a
	cpi	27		;Size of track in sectors + 1
trksiz	equ	$-1
	jc	nowrap		;Skip if not at end of track
	jnz	t1boot		;Done with this track
exit	equ	$-2
	sui	27-6		;Back up to sector 6
backup	equ	$-1
	lxi	h,loaddper track
	call	dread		;Read the sector
	pop	b
	jnc	t0boot		;Continue if no error
	dcr	b
	jnz	fread		;Keep trying if error
	jmp	dskerr		;Too many errors, flash the light

t1boot	lxi	h,cboot		;We jump to cboot next time
	shld	exit
	mvi	c,1		;Select double density
	call	setden
	xra	a		;First sector - 2
	sta	newsec
	mvi	a,8		;Size of (logical) track + 1
	sta	trksiz
	dcr	a		;Number of sectors to back up
	sta	backup
	lxi	h,loaddr+0700h	;DMA start address for first revolution - 2048
	shld	newdmt up DJDMA loader

	mvi	a,djbran	;Load branch channel command
	sta	channl
	lxi	h,commnd	;Load new command channel address
	shld	channl+1
	xra	a
	sta	channl+3

djstrt:	out	djkick		;Start controller
djwait:	lda	djdone		;Get final status
	ora	a		;0 = still busy
	jz	djwait		;Loop if busy
	lxi	h,sectb0	;Check for bad load
	lxi	b,40ffh		;b = ok, c = loaded
	lxi	d,endtbl-sectb0	;Error count + # of sectors
djloop:	mov	a,m		;Load sector code
	cmp	c		;Check for 0ffh (already loaded)
	jz	djcont		;SkiExtended address for CP/M
	else
	db	0ffh		;Wrap around from ffff00 to 000100
	endif

	db	redtrk		;Read track
	db	0		;Track 0
	db	0		;Side 0
	db	0		;Drive 0
	dw	sectb0		;Sector table 0
	db	0		;Extended address
	db	0		;Returned status

	db	setdma		;Set DMA address
	dw	loaddr+trkoff	;Load address for track 1
	db	0		;Extended address

	db	redtrk		;Read track
	db	1		;Track 1
	db	0		;Side 0
	db	0		;Drive 0
	dw	sectb1		;Sector table 1
	db	0		;Extended address
	db	0		;Returned status

	db	dееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееjhalt		;Halt controller
djdone:	db	0		;Returned status
	
	org	boot+5dh	;Boot + 5ch contains 'configuration byte'

	if	maxdm ne 0	;Booting from 8 inch drives
sectb0:	dw	0ffffh, 0ffffh	;Do not load boot loader
	dw	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	;22 sectors to be loaded

sectb1:	dw	0, 0, 0, 0ff00h	;First seven sectors

	db	retries		;Retry counter
	else			;Booting from 5 1/5 inch drives
sectb0:	dw	0ffh, 0, 0, 0, 0;Do not load boot loader
	
sectb1:	dw	0, 0, 0, 0, 0	;Load ten sectors

	db	retrie;	MDS-800 I/O Drivers for CP/M 2.2
;	(four drive single density version)
;
;	Version 2.2 February, 1980
;
vers	equ	22	;version 2.2
;
;	Copyright (c) 1980
;	Digital Research
;	Box 579, Pacific Grove
;	California, 93950
;
;
true	equ	0ffffh	;value of "true"
false	equ	not true	;"false"
test	equ	false	;true if test bios
;
	if	test
bias	equ	03400h	;base of CCP in test system
	endif
	if	not test
bias	equ	0000h	;generate relocatable cp/m system
	endif
;
patch	equ	1600h
;
	org	patch
cpmb	e for mds)
;	const	console status
;		reg-a = 00 if no character ready
;		reg-a = ff if character ready
;	conin	console character in (result in reg-a)
;	conout	console character out (char in reg-c)
;	list	list out (char in reg-c)
;	punch	punch out (char in reg-c)
;	reader	paper tape reader in (result to reg-a)
;	home	move to track 00
;
;	(the following calls set-up the io parameter block for the
;	mds, which is used to perform subsequent reads and writes)
;	seldsk	select disk given by reg-c (0,1,home
	jmp	seldsk
	jmp	settrk
	jmp	setsec
	jmp	setdma
	jmp	read
	jmp	write
	jmp	listst	;list status
	jmp	sectran
;
	maclib	diskdef	;load the disk definition library
	disks	4	;four disks
	diskdef	0,1,26,6,1024,243,64,64,offset
	diskdef	1,0
	diskdef	2,0
	diskdef	3,0
;	endef occurs at end of assembly
;
;	end of controller - independent code, the remaining subroutines
;	are tailored to the particular operating environment, and must
;	be altered for any system which differs from the intel mds.h	;reader in to reg-a
co	equ	0f809h	;console char from c to console out
po	equ	0f80ch	;punch char from c to punch device
lo	equ	0f80fh	;list from c to list device
csts	equ	0f812h	;console status 00/ff to register a
;
;	disk ports and commands
base	equ	78h	;base of disk command io ports
dstat	equ	base	;disk status (input)
rtype	equ	base+1	;result type (input)
rbyte	equ	base+3	;result byte (input)
;
ilow	equ	base+1	;iopb low address (output)
ihigh	equ	base+2	;iopb high address (output)
;
readf	s		;Retry counter
	endif

endtbl	equ	$-1		;end of table marker

	endif

	end
ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееqu	$-patch	;base of cpm console processor
bdos	equ	806h+cpmb	;basic dos (resident portion)
cpml	equ	$-cpmb	;length (in bytes) of cpm system
nsects	equ	cpml/128	;number of sectors to load
offset	equ	2	;number of disk tracks used by cp/m
cdisk	equ	0004h	;address of last logged disk on warm start
buff	equ	0080h	;default buffer address
retry	equ	10	;max retries on disk i/o before error
;
;	perform following functions
;	boot	cold start
;	wboot	warm start (save i/o byte)
;	(boot and wboot are the same2...)
;	settrk	set track address (0,...76) for subsequent read/write
;	setsec	set sector address (1,...,26) for subsequent read/write
;	setdma	set subsequent dma address (initially 80h)
;
;	(read and write assume previous calls to set up the io parameters)
;	read	read track/sector to preset dma address
;	write	write track/sector from preset dma address
;
;	jump vector for indiviual routines
	jmp	boot
wboote:	jmp	wboot
	jmp	const
	jmp	conin
	jmp	conout
	jmp	list
	jmp	punch
	jmp	reader
	jmp	
;
;	the following code assumes the mds monitor exists at 0f800h
;	and uses the i/o subroutines within the monitor
;
;	we also assume the mds system has four disk drives
revrt	equ	0fdh	;interrupt revert port
intc	equ	0fch	;interrupt mask port
icon	equ	0f3h	;interrupt control port
inte	equ	0111$1110b	;enable rst 0(warm boot), rst 7 (monitor)
;
;	mds monitor equates
mon80	equ	0f800h	;mds monitor
rmon80	equ	0ff0fh	;restart mon80 (boot error)
ci	equ	0f803h	;console character to reg-a
ri	equ	0f806equ	4h	;read function
writf	equ	6h	;write function
recal	equ	3h	;recalibrate drive
iordy	equ	4h	;i/o finished mask
cr	equ	0dh	;carriage return
lf	equ	0ah	;line feed
;
signon:	;signon message: xxk cp/m vers y.y
	db	cr,lf,lf
	if	test
	db	'32'	;32k example bios
	endif
	if	not test
	db	'00'	;memory size filled by relocator
	endif
	db	'k CP/M vers '
	db	vers/10+'0','.',vers mod 10+'0'
	db	cr,lf,0
;
boot:	;print signon message and go to ccp
;	(note: mds boot initialized iobyte at 0003h)
	lxi	ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееsp,buff+80h
	lxi	h,signon
	call	prmsg	;print message
	xra	a	;clear accumulator
	sta	cdisk	;set initially to disk a
	jmp	gocpm	;go to cp/m
;
;
wboot:;	loader on track 0, sector 1, which will be skipped for warm 
;	read cp/m from disk - assuming there is a 128 byte cold start
;	start.
;
	lxi	sp,buff	;using dma - thus 80 thru ff available for stack
;
	mvi	c,retry	;max retries
	push	b
wboot0:	;enter here on error retries
	lxi	b,cpmb	;set dma address to start of disk system
	call	setdma
	mvi	c6	;read last sector?
	jc	rd1
;	must be sector 26, zero and go to next track
	lda	iot	;get track to register a
	inr	a
	mov	c,a	;ready for call
	call	settrk
	xra	a	;clear sector number
rd1:	inr	a	;to next sector
	mov	c,a	;ready for call
	call	setsec
	pop	b	;recall sector count
	dcr	b	;done?
	jnz	rdsec
;
;	done with the load, reset default buffer address
gocpm:	;(enter here from cold start boot)
;	enable rst0 and rst7
	di
	mvi	a,12h	;initialize command
	out	revrt
	xra	a
	out	intc	;clearedged disk number
	mov	c,a	;send to ccp to log it in
	ei
	jmp	cpmb
;
;	error condition occurred, print message and retry
booterr:
	pop	b	;recall counts
	dcr	c
	jz	booter0
;	try again
	push	b
	jmp	wboot0
;
booter0:
;	otherwise too many retries
	lxi	h,bootmsg
	call	prmsg
	jmp	rmon80	;mds hardware monitor
;
bootmsg:
	db	'?boot',0
;
;
const:	;console status to reg-a
;	(exactly the same as mds call)
	jmp	csts
;
conin:	;console character to reg-a
	call	ci
	ani	7fh	;remove parity bit
	0 if error
	mov	a,c
	cpi	ndisks	;too large?
	rnc		;leave HL = 0000
;
	ani	10b	;00 00 for drive 0,1 and 10 10 for drive 2,3
	sta	dbank	;to select drive bank
	mov	a,c	;00, 01, 10, 11
	ani	1b	;mds has 0,1 at 78, 2,3 at 88
	ora	a	;result 00?
	jz	setdrive
	mvi	a,00110000b	;selects drive 1 in bank
setdrive:
	mov	b,a	;save the function
	lxi	h,iof	;io function
	mov	a,m
	ani	11001111b	;mask out disk number
	ora	b	;mask in new disk number
	mov	m,a	;save it in iopb
	mov	l,c
	mvi	h,0	;HL=disk numberL
	ret
;
setdma:	;set dma address given by regs b,c
	mov	l,c
	mov	h,b
	shld	iod
	ret
;
read:	;read next disk record (assuming disk/trk/sec/dma set)
	mvi	c,readf	;set to read function
	call	setfunc
	call	waitio	;perform read function
	ret		;may have error set in reg-a
;
;
write:	;disk write function
	mvi	c,writf
	call	setfunc	;set to write function
	call	waitio
	ret		;may have error set
;
;
;	utility subroutines
prmsg:	;print message at h,l to 0
	mov	a,m
	ora	a	;zero?
	rz
;	more t,0	;boot from drive 0
	call	seldsk
	mvi	c,0
	call	settrk	;start with track 0
	mvi	c,2	;start reading sector 2
	call	setsec
;
;	read sectors, count nsects to zero
	pop	b	;10-error count
	mvi	b,nsects
rdsec:	;read next sector
	push	b	;save sector count
	call	read
	jnz	booterr	;retry if errors occur
	lhld	iod	;increment dma address
	lxi	d,128	;sector size
	dad	d	;incremented dma address in hl
	mov	b,h
	mov	c,l	;ready for call to set dma
	call	setdma
	lda	ios	;sector number just read
	cpi	2
	mvi	a,inte	;rst0 and rst7 bits on
	out	intc
	xra	a
	out	icon	;interrupt control
;
;	set default buffer address to 80h
	lxi	b,buff
	call	setdma
;
;	reset monitor entry points
	mvi	a,jmp
	sta	0
	lxi	h,wboote
	shld	1	;jmp wboot at location 00
	sta	5
	lxi	h,bdos
	shld	6	;jmp bdos at location 5
	if	not test
	sta	7*8	;jmp to mon80 (may have been changed by ddt)
	lxi	h,mon80
	shld	7*8+1
	endif
;	leave iobyte set
;	previously selected disk was b, send parameter to cpm
	lda	cdisk	;last logret
;
conout:	;console character from c to console out
	jmp	co
;
list:	;list device out
;	(exactly the same as mds call)
	jmp	lo
;
listst:
	;return list status
	xra	a
	ret		;always not ready
;
punch:	;punch device out
;	(exactly the same as mds call)
	jmp	po
;
reader:	;reader character in to reg-a
;	(exactly the same as mds call)
	jmp	ri
;
home:	;move to home position
;	treat as track 00 seek
	mvi	c,0
	jmp	settrk
;
seldsk:	;select disk given by register c
	lxi	h,0000h	;return 000
	dad	h	;*2
	dad	h	;*4
	dad	h	;*8
	dad	h	;*16
	lxi	d,dpbase
	dad	d	;HL=disk header table address
	ret
;
;
settrk:	;set track address given by c
	lxi	h,iot
	mov	m,c
	ret
;
setsec:	;set sector number given by c
	lxi	h,ios
	mov	m,c
	ret
sectran:
		;translate sector bc using table at de
	mvi	b,0	;double precision sector number in BC
	xchg		;translate table address to HL
	dad	b	;translate(sector) address
	mov	a,m	;translated sector number to A
	sta	ios
	mov	l,a	;return sector number in o print
	push	h
	mov	c,a
	call	conout
	pop	h
	inx	h
	jmp	prmsg
;
setfunc:
;	set function for next i/o (command in reg-c)
	lxi	h,iof	;io function address
	mov	a,m	;get it to accumulator for masking
	ani	11111000b	;remove previous command
	ora	c	;set to new command
	mov	m,a	;replaced in iopb
;	the mds-800 controller requires disk bank bit in sector byte
;	mask the bit from the current i/o function
	ani	00100000b	;mask the disk select bit
	lxi	h,ios		;address the sector select byte
	ora	m		;ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееselect proper disk bank
	mov	m,a		;set disk select bit on/off
	ret
;
waitio:
	mvi	c,retry	;max retries before perm error
rewait:
;	start the i/o function and wait for completion
	call	intype	;in rtype
	call	inbyte	;clears the controller
;
	lda	dbank		;set bank flags
	ora	a		;zero if drive 0,1 and nz if 2,3
	mvi	a,iopb and 0ffh	;low address for iopb
	mvi	b,iopb shr 8	;high address for iopb
	jnz	iodr1	;drive bank 1?
	out	ilow		;low address to controller
	mov	a,b
	out	ihigh	;high address
	jm retry
;
;	check i/o error bits
	call	inbyte
	ral
	jc	wready		;unit not ready
	rar
	ani	11111110b	;any other errors?  (deleted data ok)
	jnz	werror
;
;	read or write is ok, accumulator contains zero
	ret
;
wready:	;not ready, treat as error for now
	call	inbyte		;clear result byte
	jmp	trycount
;
werror:	;return hardware malfunction (crc, track, seek, etc.)
;	the mds controller has returned a bit in each position
;	of the accumulator, corresponding to the conditions:
;	0	- deleted data (tion for later improvement
trycount:
;	register c contains retry count, decrement 'til zero
	dcr	c
	jnz	rewait	;for another try
;
;	cannot recover from error
	mvi	a,1	;error code
	ret
;
;	intype, inbyte, instat read drive bank 00 or 10
intype:	lda	dbank
	ora	a
	jnz	intyp1	;skip to bank 10
	in	rtype
	ret
intyp1:	in	rtype+10h	;78 for 0,1  88 for 2,3
	ret
;
inbyte:	lda	dbank
	ora	a
	jnz	inbyt1
	in	rbyte
	ret
inbyt1:	in	rbyte+10h
	ret
;
instat:	lda	dbank
	ora	a
	jnz	insta1
	in	dsta	title	'mds cold start loader at 3000h'
;
;	MDS-800 Cold Start Loader for CP/M 2.0
;
;	Version 2.0 August, 1979
;
false	equ	0
true	equ	not false
testing	equ	false	;if true, then go to mon80 on errors
;
	if	testing
bias	equ	03400h
	endif
	if	not testing
bias	equ	0000h
	endif
cpmb	equ	bias		;base of dos load
bdos	equ	806h+bias	;entry to dos for calls
bdose	equ	1880h+bias	;end of dos load
boot	equ	1600h+bias	;cold start entry point
rboot	equ	boot+3		;warm start entry point
;
	org	03000h	; port
ilow	equ	base+1	;low iopb address
ihigh	equ	base+2	;high iopb address
bsw	equ	0ffh	;boot switch
recal	equ	3h	;recalibrate selected drive
readf	equ	4h	;disk read function
stack	equ	100h	;use end of boot for stack
;
rstart:
	lxi	sp,stack;in case of call to mon80
;	clear disk status
	in	rtype
	in	rbyte
;	check if boot switch is off
coldstart:
	in	bsw
	ani	02h	;switch on?
	jnz	coldstart
;	clear the controller
	out	reset	;logic cleared
;
;
	mvi	b,ntrks	;number of tracks to read
	lxi	p	wait0		;to wait for complete
;
iodr1:	;drive bank 1
	out	ilow+10h	;88 for drive bank 10
	mov	a,b
	out	ihigh+10h
;
wait0:	call	instat		;wait for completion
	ani	iordy		;ready?
	jz	wait0
;
;	check io completion ok
	call	intype		;must be io complete (00) unlinked
;	00 unlinked i/o complete,    01 linked i/o complete (not used)
;	10 disk status changed       11 (not used)
	cpi	10b		;ready status change?
	jz	wready
;
;	must be 00 in the accumulator
	ora	a
	jnz	werror		;some other condition,accepted as ok above)
;	1	- crc error
;	2	- seek error
;	3	- address error (hardware malfunction)
;	4	- data over/under flow (hardware malfunction)
;	5	- write protect (treated as not ready)
;	6	- write error (hardware malfunction)
;	7	- not ready
;	(accumulator bits are numbered 7 6 5 4 3 2 1 0)
;
;	it may be useful to filter out the various conditions,
;	but we will get a permanent error message if it is not
;	recoverable.  in any case, the not ready condition is
;	treated as a separate condit
	ret
insta1:	in	dstat+10h
	ret
;
;
;
;	data areas (must be in ram)
dbank:	db	0	;disk bank 00 if drive 0,1
			;	   10 if drive 2,3
iopb:	;io parameter block
	db	80h	;normal i/o operation
iof:	db	readf	;io function, initial read
ion:	db	1	;number of sectors to read
iot:	db	offset	;track number
ios:	db	1	;sector number
iod:	dw	buff	;io address
;
;
;	define ram areas for bdos operation
	endef
	end
loaded down from hardware boot at 3000h
;
bdosl	equ	bdose-cpmb
ntrks	equ	2	;number of tracks to read
bdoss	equ	bdosl/128	;number of sectors in dos
bdos0	equ	25	;number of bdos sectors on track 0
bdos1	equ	bdoss-bdos0	;number of sectors on track 1
;
mon80	equ	0f800h	;intel monitor base
rmon80	equ	0ff0fh	;restart location for mon80
base	equ	078h	;'base' used by controller
rtype	equ	base+1	;result type
rbyte	equ	base+3	;result byte
reset	equ	base+7	;reset controller
;
dstat	equ	base	;disk statush,iopb0
;
start:
;
;	read first/next track into cpmb
	mov	a,l
	out	ilow
	mov	a,h
	out	ihigh
wait0:	in	dstat
	ani	4
	jz	wait0
;
;	check disk status
	in	rtype
	ani	11b
	cpi	2
;
	if	testing
	cnc	rmon80	;go to monitor if 11 or 10
	endif
	if	not testing
	jnc	rstart	;retry the load
	endif
;
	in	rbyte	;i/o complete, check status
;	if not ready, then go to mon80
	ral
	cc	rmon80	;not ready bit set
	rar		;restore
	ani	11110b	;overrun/addr err/seek/crc/xxxx
;
	if	testing
	cnz	rmon80	;gееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееo to monitor
	endif
	if	not testing
	jnz	rstart	;retry the load
	endif
;
;
	lxi	d,iopbl	;length of iopb
	dad	d	;addressing next iopb
	dcr	b	;count down tracks
	jnz	start
;
;
;	jmp to boot to print initial message, and set up jmps
	jmp	boot
;
;	parameter blocks
iopb0:	db	80h	;iocw, no update
	db	readf	;read function
	db	bdos0	;# sectors to read on track 0
	db	0	;track 0
	db	2	;start with sector 2 on track 0
	dw	cpmb	;start at base of bdos
iopbl	equ	$-iopb0
;
iopb1:	db	80h
	db	readfееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее
*****************************************************************
*								*
* Boot program for HDDMA controller.				*
*								*
*****************************************************************

;
;	Define normal Cbios stuff
;

alf	equ	'J'-64		;A line feed
acr	equ	'M'-64		;A carraige return

mwspt	equ	9		;Number of sectors per track
retries	equ	10		;Number of disk retries before error

bdos	equ	5		;Bdos entry point
wmess	equ	9		;Write a message

	org	0100h
	
buffer:	jmp	start

	dsjnc	buffer		;Jump to boot loader if no error
	dcr	c		;Bump retry count
	jnz	retry
	lxi	d,nosec		;Return sad news

errpr	mvi	c,wmess		;Print string command
	call	bdos
	jmp	0		;Return to CP/M

bfail:	db	acr, alf, 'HDDMA controller or drive failure.', acr, alf, '$'
nosec	db	acr, alf, 'Read error, track 0 sector 0.', acr, alf, '$'

*****************************************************************
*								*
* The follwing equates are for the HDDMA hard disk controller	*
*								*
**************; 1 =  256 byte sectors
				; 3 =  512 byte sectors (default)
				; 7 = 1024 byte sectors
				; f = 2048 byte sectors

				;Define controller commands
dmaread	equ	0		;Read sector
dmawrit	equ	1		;Write sector
dmarhed	equ	2		;Find a sector
dmawhed	equ	3		;Write headers (format a track)
dmalcon	equ	4		;Load disk parameters
dmassta	equ	5		;Sense disk drive status
dmanoop	equ	6		;Null controller operation

reset	equ	54h		;Reset controller
attn	equ	55h		;Send a controller attention

chan	equ	50h	
	db	bdos1	;sectors to read on track 1
	db	1	;track 1
	db	1	;sector 1
	dw	cpmb+bdos0*128	;base of second read
;
	end
ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее	1021		;Space for boot loader

start:	mvi	c,retries	;Set up retry count
again:	push	b
	xra	a		;Drive 0
	call	mwldrv		;Test controller and login drive
	pop	b
	ora	a
	jnz	ready		;The controller has responded
	dcr	c		;Bump retry count
	jnz	again
	lxi	d,bfail		;Missing controller message
	jmp	errpr

ready:	call	mwhome		;Track 0
	mvi	c,1		;Sector 1
	call	mwsec
	lxi	b,buffer	;DMA address
	call	mwdma
	mvi	c,retries	;Number of read retries
retry:	push	b
	call	mwread		;Read the sector
	pop	b
	***************************************************

				;Specifications for a hard disk
cyl	equ	1		;Number of cylinders
heads	equ	1		;Number of heads per cylinder
precomp	equ	1		;Cylinder to start write precomensation
lowcurr	equ	1		;Cylinder to start low current
stepdly	equ	30		;Step delay (0-12.7 milliseconds)
steprcl	equ	30		;Recalibrate step delay
headdly	equ	0		;Settle delay (0-25.5 milliseconds)

sectsiz	equ	7		;Sector size code (must be 7 for this Cbios)
				; 0 =  128 byte sectors
					;Default channel address
stepout	equ	10h		;Step direction out
stepin	equ	0		;Step direction in
band1	equ	40h		;No precomp, high current
band2	equ	0c0h		;Precomp, high current
band3	equ	80h		;precomp, low current
track0	equ	1		;Track zero status
wflt	equ	2		;Write fault from drive
dready	equ	4		;Drive ready
sekcmp	equ	8		;Seek complete

*****************************************************************
*								*
* The following are the lowest level drivers for the Morrow	*
* Designs Hard Disk ess divisor latch
	in	dll		;Get lower divisor value
	mov	e,a
	in	dlm		;Get upper divisor value
	mov	d,a
	mvi	a,wls1+wls0+stb
	out	lcr
	lxi	h,vtab		;Valid baud rate table
	mvi	c,svtab		;Length of the baud rate table
vloop:	mov	a,e
	cmp	m		;Check low byte
	jnz	vskip		;First byte is bad
	inx	h
	mov	a,d
	cmp	m		;Check high byte
	jz	done		;Baud rate is OK...  Do cleanup
	dcx	h
vskip:	inx	h		;Skip to next entry
	inx	h
	dcr	c		;Bump entry counter
	jnz	vloop

nvalid:	lhld	defcon		;Get default elect group 0
	in	sensesw		;Get sense switches
	xri	0ffh		;Test for multio board
	sta	mother		;Save motherboard flag 
	jnz	mthrin
				;Initialize a Multio
	lda	group		;Get group byte
	ani	0ffh-(denable+restor)	;Clear driver enable + restore
	sta	group
	ori	denable+restor	;Enable output drivers and pull restore down
	out	grpsel
	mvi	c,10		;Hold restore line down for 50uS
delop:	dcr	c
	jnz	delop
	ani	0ffh-(denable+restor)	;Clear driver enable + restore
	out	grpsel
	xra	a
	out	daisy0		;Clear dk

hydone:	lxi	h,hinc/cperi
	shld	hmi		;Save hmi = 120/(characters per inch)

	lxi	h,vinc/lperi
	shld	vmi		;Save vmi = 48/(lines per inch)

	lxi	h,0		;Other variables default to zero
	shld	vpos
	shld	dlvpos
	shld	hpos
	shld	dlhpos
	shld	lmar

	call	clrall		;Clear the TAB array

	xra	a
	sta	kludge		;Reset TAB clear byte
	sta	dirflg
	sta	grhflg

	ret

selg0:	lda	group		;Select group zero
	out	grpsel
	ret

selcon:	lda	group		;Select console group
	ori	congrp
	out	grpsel
	ret

sэз                                                                                                                                                                                                                                                             Г  Г: ГO ГT ГY Г? Г Г Г Г Г Г! Г$ Г' Г* ГD Г0 Г3    Г_  Г µ Г- t ГЊ ®Г Є Г	 Ќ Г њ  !: Нx :Ђ ·!J Мx НJ НSГ ~·И#T]w#w###Гx ЙНЦЫMжКђ ЫHжЙНЦЫMж Кџ yУHЙНЦЫMжИ>яЙ:8 ц 28 yжИюИO:!ч §yКв :!юyКв !Q:54Кс ѕКс ###Гв #~#foй`тeе*Њл*ЋСХН5лСлН(л*Ћ"ЋГл|/g}/o#ЙлН лЙ|єА}»Йz/G{/O>  =ш)лх)сТL#е	ТXл#гбГAблГAMD!  x±Иx·GyOЬuл)лГbЙ*’|µИ*ђл*’|§т“*ђН "’*ђл*’0Н/Ъ±*ђл!0Н("’*ђл*’"ђ*’|§ тЛН л!  "’л}жКЭyцOНL|ж±g Г<*Ћ|µИ|§ тэН |ж±gе*Њл*Ће!n 0 Н]
 Н5СлН5л"Њ!  "ЋбГ<еНwНлб@ НРЫHўК?}/o|ж/х:9 ·Кcсg}УI|УH«УH|УHЙсжg}УH|УI«УI|УIЙ:8 ж ИНР@ ЫHў> И/Й                 жЙНЦЫMж Кџ yУHЙНЦЫНЦ>УLЫHЫHЇУMУIНРЫIоя29 КояжаюхНЦсК!к‡_ ^#VГAЂ` 0     	 Ybaud rate
	xchg

setit:	mvi	a,dlab+wls1+wls0+stb	;Enable divisor access latch
	out	lcr		;Set the baud rate in (de)
	mov	a,d
	out	dlm		;Set upper divisor
	mov	a,e
	out	dll		;Set lower divisor
	mvi	a,wls1+wls0+stb
	out	lcr

done:	xra	a		;Clear status register
	out	lsr
	ret

*****************************************************************
*								*
* Initialize Diablo HyType printer.				*
*								*
*****************************************************************

linit:	call	selg0		;Sata buffers
	lda	group
	ori	denable
	out	grpsel		;Re-enable the drivers
	mvi	a,0ffh-rest	;Lift ribbon
	out	daisy1
	jmp	hydone
				;Mother board initialization
mthrin:	mvi	a,pselect+rlift	;Set select line active, rlift not active
	out	clk
	mvi	a,0ffh
	out	daisy0
	mvi	a,0ffh-rest	;Strobe restore bit low
	out	daisy0
	mvi	a,10		;Wait about 50uS
dloop:	dcr	a
	jnz	dloop
	mvi	a,0ffh		;Raise restore back up
	out	daisy0
	xra	a
	out	daisy1		;Clear data buffers
	mvi	a,pselect	;Lift ribbon
	out	clellst:	lda	group		;Select printer group
	ori	lstgrp
	out	grpsel
	ret

	db	0		;Ensure generation of a complete hex file

	end
ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее	Ѕ
f Љ©І Н1€2г3ф4ь56
8ґ90пAпBпaпbпD=U4
~	```` п	Tp * пy2ЙЙНrл*Ћ"ЋЙ:—§! А*ЉЙНrН НiГпНќ:–§Д л*’"’Й:—§! А*€ЙНќН ГЌЇ2–2—*ђл*”Н("’> §ВfЙi& Н1:—§!  ВЌ*€ГЌ!™6Ђ#ВиЇ2Й>2—ГпЇ2—ГпЇ2–Гп>2–Гп*ђл*’"”Гпi& +"ЉГпi& +"€ГпНIНiГпНIН НiГп*Љ|·g}oЙY Н^Гп*€Н]л*ђлН("’ЙY *ЉН]л*ЊлН("ЋГпНђ¶wГп*ђл*’л*€лН5 Н5K™Ї7В®ЙНђ/¦wГп*ђл*’л*€лН5  #Н/ТдеН ¦бКНлГ^*ђл!0Н("’Й!n 0 Н]
 Н5 ЂА ` @ : 0       >‡УKЫH_ЫIW>УK!ш{ѕВ7#zѕКO+##В+*6 л>‡УKzУI{УH>УKЇУMЙНРЫIоя29 В‡:8 жП28 ц0УO
ВnжПУOЇУH:8 ц УO>УIГ¤>АУJ>яУH>УH>
=В•>яУHЇУI>ЂУJ! "€! "Љ!  "Њ"Ћ"ђ"’"”НгЇ2й2–2—Й:8 УOЙ:8 цУOЙ:8 цУOЙ $’I$’I$
RЉR”HI  !$B ЂI$’I$’I$’I$’I€€’ID‘$$	$ ‘"BH‰@’I$ђ $‘DI!" "	€!Ђ €‚‰     Ѓ AI$@’‘Ђ@Ѓ $ @!@‰         Ђ Ѓ  @       Ѓ	  	! @  Ђ A’H’ ЂЂ                                                                                            DMA controller.				*
*								*
*****************************************************************

mwldrv:	sta	mwcurl		;Save current logical drive
	call	mwreset		;Reset controller card
	jc	zret		;Controller failure

	lda	mwcurl
	call	mwdrv		;Select drive
	jc	zret		;Select error

	call	mwstat		;Get drive status
	ani	dready		;Check if drive ready
	jnz	zret

	call	mwhome		;Home drive
	ret

zret:	xra	a		;Return error status
	ret

mwdrv:	sta	mwdrive		;Save new selected drive
mwsel:	mvi	a,dslowly
	call	mwreset		;Back to fast stepping mode
	ret

mwseek	call	mwptr		;Get track pointer
	mov	e,m		;Get old track number
	inx	h
	mov	d,m
	dcx	h
	mov	m,c		;Store new track number
	inx	h
	mov	m,b
	mov	l,c		;Build cylinder word
	mov	h,b
	shld	dmarg0		;Set command channel cylinder number
	mov	a,d
	inr	a
	lxi	h,0ffffh
	jnz	mwskip0
	mvi	c,stepout
	jmp	mwskip

mwskip0:mov	h,b		;(hl) = new track, (de) = old track
	mov	l,c
	call	mwhlmde
	mvi	c,stepout
	mov	a,h
	ani	80h		;Check hit bitsta	mwsectr
	mov	a,c
	sta	mwhead		;Save head number
	ret

mwdspt	mvi	c,0		;Clear head counter
mwdsptx	sui	mwspt		;Subtract a tracks worth of sectors
	rc			;Return if all done
	inr	c		;Bump to next head
	jmp	mwdsptx

mwreset	out	reset		;Send reset pulse to controller
	lxi	h,dmachan	;Address of command channel
	shld	chan		;Default channel address
	xra	a
	sta	chan+2		;Clear extended address byte
	lhld	dmarg0		;Save the track number
	push	h
	lxi	h,dmarg1	;Load arguments
	mvi	m,stepdly	;Load sreps	lda	mwhead		;Load head address
	sta	dmarg2
	cma			;Negative logic for the controller
	ani	7		;3 bits of head select
	rlc			;Shove over to bits 2 - 4
	rlc
	ora	c		;Add on low current and precomp bits
	mov	c,a
	lda	mwdrive		;Load drive address
	ora	c		;Slap in drive bits
	sta	dmasel1		;Save in command channel head select
	lda	mwsectr		;Load sector address
	sta	dmarg3

mwissue	lxi	h,dmastat	;Clear status byte
	mvi	m,0
	out	attn		;Start the controller
	lxi	d,0		;Time out counter (65536 ret	ret

mwhlmde:xchg
	call	mwneghl
	xchg
	dad	d
	ret

mwhlcde:mov	a,h
	cmp	d
	rnz
	mov	a,l
	cmp	e
	ret

mwtab:	dw	-1		;Collection of track addresses
	dw	-1		;Initialize to (way out on the end of the disk)
	dw	-1		
	dw	-1		

mwcurl	db	0		;Current logical drive
mwdrive	db	0ffh		;Currently selected drive
mwhead	db	0		;Currently selected head
mwsectr	db	0		;Currently selected sector

dmachan	equ	$		;Command channel area
dmasel0	db	0		;Drive select
dmastep	dw	0		;Relative step counter
dmanoop
	jmp	mwprep		;Execute disk command

mwstat:	mvi	a,dmassta	;Sense status operation code
	jmp	mwprep		;Execute disk command

mwhome:	call	mwreset		;Reset controller
	lxi	h,dmarg1	;Load arguments
	mvi	m,steprcl	;Load step delay (slow)
	inx	h
	mvi	m,headdly	;Head settle delay
	call	mwissue		;Do load constants again
	call	mwptr		;Get pointer to current cylinder number
	mvi	m,0ffh		;Fake at cyl 65535 for max head travel
	inx	h
	mvi	m,0ffh
	lxi	b,0		;Seek to cylinder 0
	call	mwseek		;Recal  for negitive direction
	jnz	mwsout		;Step in
	mvi	c,0
	jmp	mwskip
mwsout:	call	mwneghl
mwskip:	shld	dmastep
	lda	mwdrive
	ora	c
	sta	dmasel0

	mvi	a,dmanoop	;No-operation command for the channel
	call	mwprep		;Step to proper track
	lxi	h,0		;Clear step counter
	shld	dmastep
	ret

mwdma	mov	h,b		;Set DMA address
	mov	l,c
	shld	dmadma
	ret

mwsec	mov	a,c		;Load sector number
	dcr	a		;Range is actaully 0-16
	call	mwdspt		;Figure out head number -> (c)
	adi	mwspt		;Make sector number
	tep delay
	inx	h
	mvi	m,headdly	;Head settle delay
	inx	h
	mvi	m,sectsiz	;Sector size code
	inx	h
	mvi	m,dmalcon	;Load constants command
	call	mwissue		;Do load constants
	pop	h		;Restore the track number
	shld	dmarg0
	ret

mwread	mvi	a,dmaread	;Load disk read command

mwprep:	sta	dmaop		;Save command channel op code

	mvi	c,band1
	lhld	dmarg0
	lxi	d,precomp
	call	mwhlcde
	jc	mwpreps

	mvi	c,band2
	lxi	d,lowcurr
	call	mwhlcde
	jc	mwpreps

	mvi	c,band3		;cylinder > low_current
mwpries)
mwiloop	mov	a,m		;Get status
	ora	a		;Set up CPU flags
	rm			;Return no error (carry reset)
	stc
	rnz			;Return error status
	xthl			;Waste some time
	xthl
	xthl
	xthl
	dcx	d		;Bump timeout counter
	mov	a,d
	ora	e
	jnz	mwiloop		;Loop if still busy
	stc			;Set error flag
	ret

mwptr	lda	mwdrive		;Get currently select drives track address
	rlc
	mov	e,a
	mvi	d,0
	lxi	h,mwtab
	dad	d		;Offset into track table
	ret

mwneghl:mov	a,h
	cma
	mov	h,a
	mov	a,l
	cma
	mov	l,a
	inx	h
masel1	db	0		;Head select
dmadma	dw	0		;DMA address
	db	0		;Extended address
dmarg0	db	0		;First argument
dmarg1	db	0		;Second argument
dmarg2	db	0		;Third argument
dmarg3	db	0		;Fourth argument
dmaop	db	0		;Operation code
dmastat	db	0		;Controller status byte
dmalnk	dw	dmachan		;Link address to next command channel
	db	0		;extended address

	end
ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееsition
	lxi	h,0
	shld	dlvpos		;Reset vertical motion
	pop	h
	lxi	d,pfstrd	;Paper feed strobe
	jmp	cmnd

wheel:	push	h
	call	carrg		;Position the carriage first
	call	papr
	pop	h
	lxi	d,pwstrd

cmnd:	call	selg0		;Select group 0

cmnd0:	in	daisy0
	ana	d
	jz	cmnd0
	mov	a,l		;Negate low data bits
	cma
	mov	l,a
	mov	a,h
	ani	d9+d10+d11+d12	;Mask in data bits only
	cma
	push	psw
	lda	mother
	ora	a
	jz	cmndmt
	pop	psw		;Toggle lines on a motherboard
	mov	h,a
	mov	a,l
	out	daisy1		;Ou								*
* New list device status routine. Returns 0ffh if the printer	*
* can except another character, otherwise it returns 0.		*
*								*
*****************************************************************

stlst:	lda	group		;Check printer initialized flag
	ani	denable
	rz			;0 = printer not initialized
	call	selg0		;Select group 0
	lxi	d,pwstrd
	in	daisy0
	ana	d
	mvi	a,0
	rz
	cma
	ret

*****************************************************************
*								*
* Dynamic data locatiflg:	db	0		;Direction flag
grhflg:	db	0		;Graphics mode flag
escflg:	db	0		;Escape sequence in progress flag

tabstp:	ds	numtabs/8+1	;Tab stops bit array
tablen	equ	numtabs/8+1	;Length of tabs array

*****************************************************************
*								*
* Console and list device initialization routines follow.	*
*								*
*****************************************************************

*****************************************************************
*								*
* Terboard
	sta	mother		;Save motherboard flag
	jz	valid		;Skip switch checkout for multio's
	xri	0ffh
	ani	0e0h		;Mask in upper three bits
	rlc
	rlc
	rlc			;Move into lower 3 bits
	cpi	7		;check for sense = 7
	push	psw		;Save value
	call	selcon		;Re-select console
	pop	psw

	jz	valid		;Do default rate

	lxi	h,btab		;Pointer to baud rate table
	add	a		;Table of words so double
	mov	e,a		;Make a 16 bit number into (de)
	mvi	d,0
	dad	d		;Get a pointer into baud rate table
	mov	e,m		;Get lower brate will be set from the defcon	*
* word found below the Cbios jump table.  If the user		*
* happens to have a weird baud rate that is not in this		*
* table or is looking for a way to save space then entries	*
* can be added or deleted from the table.			*
*								*
*****************************************************************

vtab:	dw	2304		;50 baud
	dw	1536		;75
	dw	1047		;110
	dw	857		;134.5
	dw	768		;150
	dw	384		;300
	dw	192		;600
	dw	96		;1200
	dw	64		;1800
	dw	58		;2000
	dw	4tput low bits
	mov	a,h
	out	daisy0		;Output high bits
	xra	e		;Slap strobe bits in
	out	daisy0
	mov	a,h		;And drop strobes back down
	out	daisy0
	ret

cmndmtє	poр	psч		;Togglе lineу oо б Multio
	ani	0ffh-rest	;Keep ribbon up on a Multio
	mov	h,a
	mov	a,l
	out	daisy0		;Output low bits
	mov	a,h
	out	daisy1		;Output high bits
	xra	e		;Slap strobe bits in
	out	daisy1
	mov	a,h		;And drop strobes back down
	out	daisy1
	ret

*****************************************************************
*ons used by the simulator.			*
*								*
*****************************************************************

hmi:	dw	0		;Horizontal motion index. Set by linit
				;	and escape sequences.
vmi:	dw	0		;Vertical motion index. Set by linit
				;	and escape sequences.
vpos:	dw	0		;Vertical position. Set by platen motion
dlvpos:	dw	0		;Delta vpos. Set by platen motion
hpos:	dw	0		;Horizontal position. Set by carriage motion
dlhpos:	dw	0		;Delta hpos. Set by carriage motion
lmar:	dw	0		;Left margin
dirminal initilization routine.  This routine reads the sense	*
* switch on the WB-14 and sets the speed accordingly.		*
*								*
*****************************************************************

cinit:	call	selcon		;Select console

	mvi	a,dtrenb+rtsenb	;Enable DTR and RTS outputs to terminal
	out	mcr
	in	rbr		;Clear reciever buffers
	in	rbr
	xra	a
	out	lsr		;Clear status
	out	ier		;Set no interrupts

	call	selg0		;Select group 0
	in	sensesw		;Get sense switches
	xri	0ffh		;Test for multio yte of word
	inx	h		;Point to high byte of word
	mov	d,m		;Get upper byte. (de) now has divisor
	jmp	setit		;Set baud rate.

btab:	dw	1047		;110 Baud	000
	dw	384		;300		001
	dw	96		;1200		010
	dw	48		;2400		011
	dw	24		;4800		100
	dw	12		;9600		101
	dw	6		;19200		110

*****************************************************************
*								*
* The following is a list of valid baud rates.  The current	*
* baud rate is checked on cold boot.  If it is not in the	*
* vtab table then the baud 8		;2400
	dw	32		;3600
	dw	24		;4800
	dw	16		;7200
	dw	12		;9600
	dw	6		;19200

svtab	equ	($-vtab)/2	;Length of the vtab table

*****************************************************************
*								*
* Valid checks if the divisor latch is a reasonable value.	*
* If the value seems off then it will get the default baud	*
* rate from defcon and jump to setit.				*
*								*
*****************************************************************

valid:	mvi	a,dlab+wls0+wls1+stb
	out	lcr		;Acc;	Skeletal CBIOS for first level of CP/M 2.0 alteration
;
msize	equ	20	;cp/m version memory size in kilobytes
;
;	"bias" is address offset from 3400H for memory systems
;	than 16K (referred to as "b" throughout the text).
;
bias	equ	(msize-20)*1024
ccp	equ	3400H+bias	;base of ccp
bdos	equ	ccp+806h	;base of bdos
bios	equ	ccp+1600h	;base of bios
cdisk	equ	0004H	;current disk number 0=A,...,15=P
iobyte	equ	0003h	;intel i/o byte
;
	org	bios	;origin of this program
nsects	equ	($-ccp)/128	;warm stawrite		;write disk
	jmp	listst		;return list status
	jmp	sectran		;sector translate
;
;	fixed data tables for four-drive standard
;	IBM-compatible 8" disks
;	disk parameter header for disk 00
dpbase:	dw	trans,0000H
	dw	0000H,0000H
	dw	dirbf,dpblk
	dw	chk00,all00
;	disk parameter header for disk 01
	dw	trans,0000H
	dw	0000H,0000H
	dw	dirbf,dpblk
	dw	chk01,all01
;	disk parameter header for disk 02
	dw	trans,0000H
	dw	0000H,0000H
	dw	dirbf,dpblk
	dw	chk02,all02
;	disk parameter header for k size-1
	dw	63		;directory max
	db	192		;alloc 0
	db	0		;alloc 1
	dw	16		;check size
	dw	2		;track offset
;
;	end of fixed tables
;
;	individual subroutines to perform each function
boot:	;simplest case is to just perform parameter initialization
	xra	a		;zero in the accum
	sta	iobyte		;clear the iobyte
	sta	cdisk		;select disk zero
	jmp	gocpm		;initialize and go to cp/m
;
wboot:	;simplest case is to read the disk until all sectors loaded
	lxi	sp,80h		;use space below buffer for stack
	mvess
	mov	c,d	;get sector address to register c
	call	setsec	;set sector address from register c
	pop	b	;recall dma address to b,c
	push	b	;replace on stack for later recall
	call	setdma	;set dma address from b,c
;
;	drive set to 0, track set, sector set, dma address set
	call	read
	cpi	00h	;any errors?
	jnz	wboot	;retry the entire boot if an error occurs
;
;	no error, move to next sector
	pop	h	;recall dma address
	lxi	d,128	;dma=dma+128
	dad	d	;new dma address is in h,l
	pop	d	;recall sectok	;track address set from register c
	pop	h
	pop	d
	pop	b
	jmp	load1	;for another sector
;
;	end of load operation, set parameters and go to cp/m
gocpm:
	mvi	a,0c3h	;c3 is a jmp instruction
	sta	0	;for jmp to wboot
	lxi	h,wboote	;wboot entry point
	shld	1	;set address field for jmp at 0
;
	sta	5	;for jmp to bdos
	lxi	h,bdos	;bdos entry point
	shld	6	;address field of jump at 5 to bdos
;
	lxi	b,80h	;default dma address is 80h
	call	setdma
;
	ei		;enable the interrupt system
	lda	cdisk	;grt sector count
;
;	jump vector for individual subroutines
	jmp	boot		;cold start
wboote:	jmp	wboot		;warm start
	jmp	const		;console status
	jmp	conin		;console character in
	jmp	conout		;console character out
	jmp	list		;list character out
	jmp	punch		;punch character out
	jmp	reader		;reader character out
	jmp	home		;move head to home position
	jmp	seldsk		;select disk
	jmp	settrk		;set track number
	jmp	setsec		;set sector number
	jmp	setdma		;set dma address
	jmp	read		;read disk
	jmp	disk 03
	dw	trans,0000H
	dw	0000H,0000H
	dw	dirbf,dpblk
	dw	chk03,all03
;
;	sector translate vector
trans:	db	1,7,13,19	;sectors 1,2,3,4
	db	25,5,11,17	;sectors 5,6,7,8
	db	23,3,9,15	;sectors 9,10,11,12
	db	21,2,8,14	;sectors 13,14,15,16
	db	20,26,6,12	;sectors 17,18,19,20
	db	18,24,4,10	;sectors 21,22,23,24
	db	16,22		;sectors 25,26
;
dpblk:	;disk parameter block, common to all disks
	dw	26		;sectors per track
	db	3		;block shift factor
	db	7		;block mask
	db	0		;null mask
	dw	242		;disi	c,0		;select disk 0
	call	seldsk
	call	home		;go to track 00
;
	mvi	b,nsects	;b counts # of sectors to load
	mvi	c,0		;c has the current track number
	mvi	d,2		;d has the next sector to read
;	note that we begin by reading track 0, sector 2 since sector 1
;	contains the cold start loader, which is skipped in a warm start
	lxi	h,ccp		;base of cp/m (initial load point)
load1:	;load one more sector
	push	b	;save sector count, current track
	push	d	;save next sector to read
	push	h	;save dma addrr address
	pop	b	;recall number of sectors remaining, and current trk
	dcr	b	;sectors=sectors-1
	jz	gocpm	;transfer to cp/m if all have been loaded
;
;	more sectors remain to load, check for track change
	inr	d
	mov	a,d	;sector=27?, if so, change tracks
	cpi	27
	jc	load1	;carry generated if sector<27
;
;	end of current track, go to next track
	mvi	d,1	;begin with first sector of next track
	inr	c	;track=track+1
;
;	save register state, and change tracks
	push	b
	push	d
	push	h
	call	settret current disk number
	mov	c,a	;send to the ccp
	jmp	ccp	;go to cp/m for further processing
;
;
;	simple i/o handlers (must be filled in by user)
;	in each case, the entry point is provided, with space reserved
;	to insert your own code
;
const:	;console status, return 0ffh if character ready, 00h if not
	ds	10h	;space for status subroutine
	mvi	a,00h
	ret
;
conin:	;console character into register a
	ds	10h	;space for input routine
	ani	7fh	;strip parity bit
	ret
;
conout: ;console charak for tab stop
	lxi	d,8		;Number of stops per byte
	call	hldde		;HL/DE -> HL, HL mod DE -> DE
	mov	c,e		;Save
	inr	c		;Make range (1-8)
	lxi	d,tabstp	;Tab array
	dad	d		;Make array pointer
	xra	a
	stc
mtab0:	rar
	dcr	c		;Bump bit counter
	jnz	mtab0
	ret

clrhtab:call	tabcol		;Clear horizontal tab
	cma
	ana	m		;Mask out tab stop
	mov	m,a
	jmp	func1

doaht:	lhld	hpos		;Compute address of current character col
	xchg
	lhld	dlhpos
	dad	d		;Get logical position
	xchg
	lhld	hmi		;And dividff:	lxi	h,dfrmln	;Multiply forms length by 48
	lxi	d,48
	call	hltde
	lxi	d,10
	call	hldde		;And divide it by 10
	push	h		;Save this result
	lhld	vpos		;Get logical vertical position
	xchg
	lhld	dlvpos
	dad	d
	pop	d
	push	d		;Get copy of forms length
	call	hldde		;HL mod DE
	xchg
	pop	d
	xchg
	call	hlmde
	xchg
	lhld	dlvpos
	dad	d
	shld	dlvpos
	jmp	papr

*****************************************************************
*								*
* Neghl forms the twos complement of HL.			*
*								 return the Z flag is set if	*
* they are equal, the Carry flag is set if HL is less than DE.	*
*								*
*****************************************************************

hlcde:	mov	a,h
	cmp	d
	rnz
	mov	a,l
	cmp	e
	ret

*****************************************************************
*								*
* Divide the number in HL by the number in DE.	Return the 	*
* quotient in HL and the remainder in DE.			*
*								*
*****************************************************************

hldde:	m**********************************************************
*								*
* Multiply the contents of HL by the contents of DE.		*
*								*
*****************************************************************

hltde:	mov	c,l
	mov	b,h
	lxi	h,0
mult:	mov	a,b
	ora	c
	rz
	mov	a,b
	ora	a
	rar
	mov	b,a
	mov	a,c
	rar
	mov	c,a
	cc	dadde
	xchg
	dad	h
	xchg
	jmp	mult
dadde:	dad	d
	ret

*****************************************************************
*								*
* The routines below actually intt
	xchg
	lxi	h,maxrgt
	call	hlmde
	shld	dlhpos
rgtok:	lhld	hpos		;Update the horizontal position
	xchg
	lhld	dlhpos
	dad	d
	shld	hpos
	lhld	dlhpos		;check if required motion is to the left
	mov	a,h
	ana	a
	mvi	c,0
	jp	posh
	call	neghl
	mvi	c,d11
posh:	xchg
	lxi	h,0
	shld	dlhpos		;Reset the horizontal increment
	xchg
	mov	a,l
	ani	1
	jz	nohhlf		;No half spaces
	mov	a,c
	ori	d12
	mov	c,a
nohhlf:	call	divid2
	mov	a,h
	ani	d9+d10
	ora	c
	mov	h,a
	lxi	d,crstrd
	jmp	cmnd

papr:	e by hmi to get character column
	xchg
	call	hldde
tablop:	lxi	d,numtabs
	inx	h		;Start with next position
	call	hlcde		;Compare position with number of tabs
	jnc	tofar		;Past last tab
	push	h		;Save col pointer
	call	mtabp		;Generate tab pointer
	ana	m		;Check out tab stop
	pop	h		;Restore col pointer
	jz	tablop		;Loop if stop not set
	xchg
	jmp	newdlh		;Set new col position and return
tofar:	lhld	hpos		;Go all the way to the right
	xchg
	lxi	h,maxrgt
	call	hlmde
	shld	dlhpos
	ret

doa*
*****************************************************************

neghl:	mov	a,h
	cma
	mov	h,a
	mov	a,l
	cma
	mov	l,a
	inx	h
	ret

*****************************************************************
*								*
* Hlmde subtracts DE from HL and returns.			*
*								*
*****************************************************************

hlmde:	xchg
	call	neghl
	xchg
	dad	d
	ret

*****************************************************************
*								*
* Hlcde compares HL with DE. Onov	a,d		;Start by negating DE and
	cma			;	moving the left operand to BC
	mov	b,a
	mov	a,e
	cma
	mov	c,a
	inx	b
	mvi	a,16		;Repeat count in reg A
	lxi	d,0		;Initial remainder is zero
div3:	dcr	a		;Test if done
	rm			;All done ?
	dad	h		;Shift right operand to the left
	xchg
	push	psw		;Save carry
	dad	h		;Shift left operand to the left
	pop	psw
	jnc	div1		;Does it fit ?
	inx	h
div1:	push	h
	dad	b
	jnc	div2
	xchg
	inx	h
	xthl
	pop	h
	jmp	div3
div2:	pop	h
	xchg
	jmp	div3

*******erface to the printer,		*
* causing paper feed, carriage, and print wheel motion.		*
*								*
*****************************************************************

carrg:	lhld	dlhpos		;Check for any accumulated motion
	mov	a,h
	ora	l
	rz
	lhld	hpos		;Check for too much motion
	xchg
	lhld	dlhpos
	dad	d
	mov	a,h
	ana	a
	jp	lftok
	lhld	hpos
	call	neghl
	shld	dlhpos
lftok:	lhld	hpos
	xchg
	lhld	dlhpos
	dad	d
	lxi	d,maxrgt
	call	hlcde
	jc	rgtok
	lhld	hpos		;Otherwise move only to maxrighlhld	dlvpos		;Check for any paper motion
	mov	a,h
	ora	l
	rz			;No motion
	mov	a,h
	ana	a
	mvi	c,0
	jp	posv
	call	neghl
	mvi	c,d11
posv:	mov	a,h
	ani	d9+d10
	ora	c
	mov	h,a
	push	h		;Save paper motion
	lhld	vpos
	xchg
	lhld	dlvpos		;Get logical position
	dad	d
	push	h		;Save for now
	lxi	h,dfrmln	;Get default form length
	lxi	d,48
	call	hltde		;Multiply by 48
	lxi	d,10
	call	hldde		;Divide by 10
	pop	d
	xchg
	call	hldde		;Compute HL mod DE
	xchg
	shld	vpos		;Save new vertical pocter output from register c
	mov	a,c	;get to accumulator
	ds	10h	;space for output routine
	ret
;
list:	;list character from register c
	mov	a,c	;character to register a
	ret		;null subroutine
;
listst:	;return list status (0 if not ready, 1 if ready)
	xra	a	;0 is always ok to return
	ret
;
punch:	;punch character from register c
	mov	a,c	;character to register a
	ret		;null subroutine
;
;
reader: ;read character into register a from reader device
	mvi	a,1ah	;enter end of file for now (re;must be between 0 and 3
	rnc		;no carry if 4,5,...
;	disk number is in the proper range
	ds	10	;space for disk select
;	compute proper disk parameter header address
	lda	diskno
	mov	l,a	;L=disk number 0,1,2,3
	mvi	h,0	;high order zero
	dad	h	;*2
	dad	h	;*4
	dad	h	;*8
	dad	h	;*16 (size of each header)
	lxi	d,dpbase
	dad	d	;HL=.dpbase(diskno*16)
	ret
;
settrk:	;set track given by register c
	mov	a,c
	sta	track
	ds	10h	;space for track select
	ret
;
setsec:	;set sector given by register n (usually this is similar to write
;	so we will allow space to set up read command, then use
;	common code in write)
	ds	10h	;set up read command
	jmp	waitio	;to perform the actual i/o
;
write:	;perform a write operation
	ds	10h	;set up write command
;
waitio:	;enter here from read and write to perform the actual i/o 
;	operation.  return a 00h in register a if the operation completes
;	properly, and 01h if an error occurs during the read or write
;
;	in this case, we have saved the disk numbebytes for expansion
dmaad:	ds	2	;direct memory address
diskno:	ds	1	;disk number 0-15
;
;	scratch ram area for BDOS use
begdat	equ	$	;beginning of data area
dirbf:	ds	128	;scratch directory area
all00:	ds	31	;allocation vector 0
all01:	ds	31	;allocation vector 1
all02:	ds	31	;allocation vector 2
all03:	ds	31	;allocation vector 3
chk00:	ds	16	;check vector 0
chk01:	ds	16	;check vector 1
chk02:	ds	16	;check vector 2
chk03:	ds	16	;check vector 3
;
enddat	equ	$	;end of data area
datsiz	equ	$-beееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееplace later)
	ani	7fh	;remember to strip parity bit
	ret
;
;
;	i/o drivers for the disk follow
;	for now, we will simply store the parameters away for use
;	in the read and write subroutines
;
home:	;move to the track 00 position of current drive
;	translate this call into a settrk call with parameter 00
	mvi	c,0	;select track 0
	call	settrk
	ret		;we will move to 00 on first read/write
;
seldsk:	;select disk given by register C
	lxi	h,0000h	;error return code
	mov	a,c
	sta	diskno
	cpi	4	c
	mov	a,c
	sta	sector
	ds	10h	;space for sector select
	ret
;
sectran:
	;translate the sector given by BC using the
	;translate table given by DE
	xchg		;HL=.trans
	dad	b	;HL=.trans(sector)
	mov	l,m	;L = trans(sector)
	mvi	h,0	;HL= trans(sector)
	ret		;with value in HL
;
setdma:	;set dma address given by registers b and c
	mov	l,c	;low order address
	mov	h,b	;high order address
	shld	dmaad	;save the address
	ds	10h	;space for setting the dma address
	ret
;
read:	;perform read operatior in 'diskno' (0,1)
;			the track number in 'track' (0-76)
;			the sector number in 'sector' (1-26)
;			the dma address in 'dmaad' (0-65535)
	ds	256	;space reserved for I/O drivers
	mvi	a,1	;error condition
	ret		;replaced when filled-in
;
;	the remainder of the CBIOS is reserved uninitialized
;	data area, and does not need to be a part of the
;	system memory image (the space must be available,
;	however, between "begdat" and "enddat").
;
track:	ds	2	;two bytes for expansion
sector:	ds	2	;two gdat;size of data area
	end
ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее byte character to match				*
*	2 bytes of address to execute				*
* terminated by a first byte of 0.				*
*								*
*****************************************************************

level0:	db	aesc
	dw	doaesc		;Beginning of an escape sequence
	db	aff
	dw	doaff		;Form feed
	db	aetx
	dw	doaetx
	db	aht
	dw	doaht		;horizontal tab
	db	alf
	dw	doalf		;Line feed
	db	asp
	dw	doasp		;Space
	db	abs
	dw	doabs		;Back space
	db	acr
	dw	doacr		;Carriage return
	db	0
	dw	dochar		;Any other characine feed
	db	'U'
	dw	poshlf		;Half line feed
	db	alf
	dw	neglf		;Negative line feed
	db	aht
	dw	settwo		;Two character escape sequence
	db	avt
	dw	settwo
	db	ars
	dw	settwo
	db	aus
	dw	settwo
	db	0
	dw	func1

level2:	db	aht
	dw	abshtab		;Absolute horizontal tab
	db	avt
	dw	absvtab		;Absolute vertical tab
	db	ars
	dw	setvmi
	db	aus
	dw	sethmi
	db	0
	dw	func2

*****************************************************************
*								*
* The following routines execute escape sequep	func1

doasp:	call	sphmi		;Get space horizontal motion
spdir:	lda	dirflg		;Forward or backwards ?
	ana	a
	cnz	neghl		;Negate HL
adjhp:	xchg			;Adjust Horizontal position
	lhld	dlhpos		;Get current adjustment
	dad	d		;Update it
	shld	dlhpos		;And save
	ret

sphmi:	lda	grhflg		;In graphics mode ?
	ana	a
	lxi	h,2		;Only 1/60 if in graphics mode
	rnz
	lhld	hmi
	ret

doabs:	call	sphmi		;Space increment
	call	neghl		;Negative to start with
	jmp	spdir		;Adjust backwards

doacr:	xra	a
	stag of tab stop array
	mvi	d,tablen	;Size of tab array (bytes)
notblp:	mvi	m,80h		;Reset tabs (reset to 0 later)
kludge	equ	$-1		;Used on first reset (warmboot)
	inx	h		;Next tab stop
	dcr	d		;Update repeat count
	jnz	notblp		;Continue zeroing
func2	equ	$
func1:	xra	a		;Clear escape sequence flag
	sta	escflg
	ret

setgrp:	mvi	a,1		;Set graphics mode on
	sta	grhflg
	jmp	func1

clrgrp:	xra	a		;Turn graphics mode off
	sta	grhflg
	jmp	func1

clrdir:	xra	a		;Forward print mode
	sta	dirflg
	jmGet vmi for full line feed
divid2:	mov	a,h		;High byte
	ora	a		;Clear the carry
	rar
	mov	h,a
	mov	a,l
	rar
	mov	l,a
	ret

abshtab:mov	e,c		;Absolute horizontal tab
	mvi	d,0
	dcx	d		;Form 16 bit tab column
	call	newdlh
	jmp	func2

newdlh:	lhld	hmi
	call	hltde		;Multiply by hmi
	xchg
	lhld	hpos		;And subtract current horizontal position
	xchg
	call	hlmde
	shld	dlhpos
	ret

absvtab:mov	e,c		;Absolute vertical tab
	mvi	d,0
	dcx	d
	lhld	vmi
	call	hltde		;Multiply by vmi
	xchg
	lhlter

level1:	db	'1'
	dw	sethtab		;Set horizontal tab
	db	'2'
	dw	clrall		;Clear all horizontal tabs
	db	'3'
	dw	setgrp		;Graphics mode
	db	'4'
	dw	clrgrp		;Clear graphics mode
	db	'5'
	dw	clrdir		;Forward printing
	db	'6'
	dw	setdir		;Backward printing
	db	'8'
	dw	clrhtab		;Clear horizontal tab
	db	'9'
	dw	setlmar		;Set left margin
	db	'0'
	dw	func1		;No operation level 1
	db	'A'
	dw	func1
	db	'B'
	dw	func1
	db	'a'
	dw	func1
	db	'b'
	dw	func1
	db	'D'
	dw	neghlf		;Negative half lnces, etc.		*
*								*
*****************************************************************

settwo:
doaesc:	mov	a,c		;Get the escape character
	sta	escflg
func0:	ret

doaetx:	ret

doalf:	call	lfvmi		;Get line feed vmi
adjvp:	xchg
	lhld	dlvpos		;Get vertical motion displacement
	dad	d
	shld	dlvpos
	ret

lfvmi:	lda	grhflg
	ana	a
	lxi	h,1		;Only 1/48 if in graphics mode
	rnz
	lhld	vmi		;Get vertical motion index
	ret

neglf:	call	lfvmi		;Get line feed vmi
	call	neghl
	call	adjvp
	jm	dirflg		;Forward printing
	sta	grhflg		;No graphics mode
	lhld	hpos		;Get current offset
	xchg
	lhld	lmar		;Get left margin
	call	hlmde
	shld	dlhpos		;Don't move yet though
	mvi	a,autolf	;In Auto line feed mode ?
	ana	a
	jnz	doalf		;Do line feed also
	ret

dochar:	mov	l,c
	mvi	h,0
	call	wheel		;Print the character in register C
	lda	grhflg
	ana	a
	lxi	h,0		;Don't move if in graphics mode
	jnz	spdir
	lhld	hmi
	jmp	spdir

clrall	equ	$		;Clear all horizontal tabs
	lxi	h,tabstp	;Beginninp	func1

setdir:	mvi	a,a		;Set backward printing mode
	sta	dirflg
	jmp	func1

setlmar:lhld	hpos		;Get current position
	xchg
	lhld	dlhpos		;Get offset
	dad	d
	shld	lmar
	jmp	func1

setvmi:	mov	l,c		;Set the motion index
	mvi	h,0
	dcx	h
	shld	vmi
	jmp	func2

sethmi:	mov	l,c
	mvi	h,0
	dcx	h
	shld	hmi
	jmp	func2

poshlf:	call	hlfvmi		;Half line feed vmi
	call	adjvp
	jmp	func1

neghlf:	call	hlfvmi		;Negative half line feed
	call	neghl
	call	adjvp
	jmp	func1

hlfvmi:	lhld	vmi		;d	vpos		;And subtract the current vertical position
	xchg
	call	hlmde
	shld	dlvpos
	jmp	func2

sethtab:call	tabcol		;Set horizontal tab
	ora	m		;OR in tab stop
	mov	m,a		;   and save
	jmp	func1

tabcol:	lhld	hpos		;Compute address of current character col
	xchg
	lhld	dlhpos
	dad	d		;Get logical position
	xchg
	lhld	hmi		;And divide by hmi to get character column
	xchg
	call	hldde

mtabp:	;Make a tab pointer
	;HL -> Tab column desired (1-160)
	;HL <- address of tab stop
	; A <- bit mas*************************************************************************
*									*
* Morrow Designs CBIOS for CP/M Version 2.2.				*
*									*
* This CBIOS can be configured to run with the following devices. 	*
* The disks may be configured to run with any or all of the disk	*
* systems.  The logical order of the disks can be set to any order.	*
*									*
* Disk systems:								*
*	HDCA 10, 20 and 26 megabyte hard disks.				*
*	HDDMA 5, 10, 16, megabyte hard disk systems.			*
*	DJDMA flop the cold and warm boot loaders to		*
*	work.  Be sure to format all new system diskettes with		*
*	1024 byte sectors.  The system diskette can be either		*
*	single or double sided.  The sector size on normal (non		*
*	A: drive) diskettes is not restricted.  Thus if you have	*
*	a diskette with software that is supposed to run on the		*
*	A: drive then you should mount the diskette in the B:		*
*	drive and then PIP it over to a 1024 byte sector		*
*	system diskette.						*
*									*
* Written b* 11  3 82 Marc		Added the North Star character I/O system	*
* 11  2 82 Marc		Added character redirection code for the IOBYTE	*
* 11  1 82 Marc		Changed serial i/o entry names to IOBYTE names	*
* 10 18 82 Marc		Fixed SETHIGH for 2 sided DJDMA 8 inch disks	*
* 10 18 82 Marc		Deleted the HyType drivers			*
**10  1 82 Marc		Public release of revision E.3			*
*  9 29 82 Marc		40H now points to the HDDMA command channel	*
*  9 28 82 Marc		MW's now have 1024 directory entries		*
*  9 28 82 Marc		Deleted t4K systems	*
*  9  9 82 Marc		SETHIGH was botching 2 sided DPB pointers	*
*  8 31 82 Marc		Changed TRACKS in HD driver to HDTRAK		*
*  8 27 82 Marc		Added code/system length checker		*
*  8 27 82 Marc		mwreset save/restores the track number		*
*  8 26 82 Marc		mwreset now sets *step and *dir	for CMI		*
*  8 20 82 Marc		Added 'equ'ed handshaking to the serial LST:	*
*  8 19 82 Marc		Removed clock switching code from HDCA driver	*
*  8 18 82 Marc		Added handshake configuration code		*
*  8 18 82 Marc	Fixed 8250 UART initialization sequence		*
*  8  6 82 Marc		Strip parity on conout to clear up glitches	*
*  8  6 82 Marc		Fixed the 8 inch dpb256ss DPB's EXM		*
*  8  6 82 Marc		Increased the HD capacities slightly		*
*  8  6 82 Marc		Deleted all non-supported MW drives		*
*  8  6 82 Marc		Deleted call to flush in conout			*
*  8  6 82 Marc		Moved printer back to port 3			*
*  7 28 82 Marc		Moved conin flush call to conout		*
*  7 27 82 Marc		Fixed double sided head settle time		*
*  7 14 82 Marcpy disk controller with 8 and 5 1/4 inch disks.	*
*	DJ 2D/B floppy disk controller with 8 inch disks.		*
*									*
* Console I/O:								*
*	Disk Jockey 2D/B serial.					*
*	Disk Jockey DMA serial.						*
*	Multi I/O serial.						*
*	Decision I serial.						*
*									*
* Printer I/O:								*
* 	Multi I/O serial with handshaking.				*
*	Multi I/O Diablo 1620 simulator for the Hytype II.		*
*									*
* Note:	Floppy systems diskette (drive A:) has to have 1024 byte	*
*	sectors in order fory Les Kent and Marc Kupper  		3/4/82			*
*									*
*  Date    Programmer	Description					*
*									*
**11 20 82 Marc		Public release of revision E.31			*
* 11 19 82 Marc		Changed HDC3 equate to HDCA			*
* 11 19 82 Marc		Changed blank IO routines from RET to JMP $	*
* 11 19 82 Marc		Converted BIOSLN to a byte value		*
* 11  9 82 Marc		Reduced bad map size to 1 for non MW systems	*
* 11  8 82 Marc		Deleted baud rate test from Multio drivers	*
* 11  4 82 Marc		Added initial IOBYTE to IOCONF			*
he Centronics drivers			*
*  9 27 82 Marc		Changed login message to look like a label	*
*  9 27 82 Marc		Changed the login messages to say M5, M10, ...	*
*  9 27 82 Marc		Redefined the dparam table structure		*
*  9 22 82 Marc		Added a serial console for the Switchboard	*
*  9 22 82 Marc		Added initialization code for serial group 2	*
*  9 22 82 Marc		Added sector size byte to the HDCA DPB's	*
*  9 22 82 Marc		Added sector size parameter to DPBGEN		*
*  9  9 82 Marc		Fixed system length checks for 6		Added handshake configuration bytes		*
*  8 18 82 Marc		Removed 'equ'ed handshaking from LST:		*
*  8 12 82 Marc		Added configuration entries for a0 & d0		*
*  8 11 82 Marc		Added the autostart command structure		*
*  8 11 82 Marc		Redefined the configuration table		*
*  8 11 82 Marc		Added DJDMA drive parameter table		*
*  8  9 82 Marc		Added clock switching to HDCA code		*
*  8  9 82 Marc		Added seek complete clearing in HDCA		*
*  8  6 82 Marc		Added buffer disable on home			*
*  8  6 82 Marc			Optimized MWissue				*
*  7 14 82 Marc		Clean up login message for HD a bit		*
*  6 30 82 Marc		Fixed MF multi density problems			*
*  6 29 82 Marc		Added Olivetti HD561/1 HD561/2 drives		*
*  6 28 82 Marc		Added a MW error reporter			*
*  6 18 82 Marc		Added nonstandard system mode flag		*
*  6 17 82 Marc		Added a buffer error flag			*
*  6 17 82 Marc		Added save/restore of 50-52 to MW driver	*
*  6 17 82 Marc		Fixed Centronics drivers			*
*  6  7 82 Marc		Fixed allocation map sizes			*
*  6  7 switches.  If the value found is in the range 0-6 then the	*
* console baud rate will be taken from the rate table.		*
* Otherwise the current divisor latch value will be checked.	*
* If the divisor seems to be ok then no action will be taken	*
* as far as the baud rate setting goes.  If the divisor is not	*
* ok then the baud rate will be set from the DEFCON word	*
* which is found just below the regular Cbios jump table.  The	*
* standard divisor table is given below.			*
*								*
* Sense swit*******************

*****************************************************************
*								*
* Read a character from the serial port.			*
*								*
*****************************************************************

citty:	call	selcon		;Select console group

conin1:	in	lsr		;Read status register
	ani	dr		;Wait till character ready
	jz	conin1
	in	rbr		;Read character
	ani	7fh		;Strip parity
	ret

*****************************************************************
*								*
* Output a cdy.			*
*								*
*****************************************************************

cstty:	call	selcon		;Select console

	in	lsr		;Read status register
	ani	dr
	rz			;No charactter ready
	mvi	a,0ffh		;Character ready
	ret

*****************************************************************
*								*
* Diablo 1620 simulator for the Diablo Hytype II.		*
*								*
*****************************************************************

*************************************************************
*	aesc 1		set tab stop at current print position	*
*	aesc 2		clear all tab stops			*
*	aesc 3		graphics mode on			*
*	aesc 4		graphics mode off			*
*	aesc 5		forward print				*
*	aesc 6		backward print				*
*	aesc 8		clear tab stop				*
*	aesc 9		set left margin				*
*	aesc A		ignored					*
*	aesc B		ignored					*
*	aesc D		negative half line feed			*
*	aesc U		half line feed				*
*	aesc alf	negative line feed			*
*	aesc aht c	absolute horizontal tab			*
*	aesc avt c	absolute vertical tab			*	;Single character escape sequences
	cpi	aesc
	mov	a,c		;Scan for char in A
	jz	lookup		;Execute single level escape sequence
	lxi	h,level2	;Two character escape sequence
	lda	escflg

*****************************************************************
*								*
* Lookup scans the table pointed at by HL looking for a match	*
* of the character in register A.				*
*								*
*****************************************************************

lookup:	dcr	m		;Test if end of table
	inr	m
	jz	gotherch: 123  (0 = off, 1 = on)				*
*		000 = 110					*
*		001 = 300					*
*		010 = 1200					*
*		011 = 2400					*
*		100 = 4800					*
*		101 = 9600					*
*		110 = 19200					*
*	     defcon = 9600					*
*								*
*****************************************************************

*****************************************************************
*								*
* Due to its length, the tinit routine driver is below the	*
* cboot routine.						*
*								*
**********************************************haracter to serial port.				*
*								*
*****************************************************************

cotty:	call	selcon		;Select console

conout1:in	lsr		;Read status
	ani	thre		;Wait till transmitter buffer empty
	jz	conout1
	mov	a,c		;Character is in (c)
	out	thr		;Output to transmitter buffer
	ret

*****************************************************************
*								*
* Return serial port status.  Returns zero if character is not	*
* ready to be read.  Else returns 255 if rea****
*								*
* This routine does all of the character decoding, escape	*
* sequences forward, backward, etc. The list of escape		*
* sequences, and special characters recognized is:		*
*								*
*	adel		ignored					*
*	anul		ignored					*
*	aack		ignored	(when received)			*
*	abel		ignored					*
*	aff		form feed				*
*	aetx		etx/ack handshake			*
*	aht		horizontal tab				*
*	alf		line feed				*
*	asp		space					*
*	abs		backspace				*
*	acr		carriage return				*
*	aesc 0		ignored					*
*	aesc ars c	set vmi					*
*	aesc aus c	set hmi					*
*								*
*****************************************************************

otlst:	lda	group		;Set printer initialized flag
	ori	denable
	sta	group
	mov	a,c		;Get the character to print
	ani	7fh		;Strip off parity
	rz
	cpi	adel		;Ignore delete
	rz
	mov	c,a		;Save character
	lda	escflg
	lxi	h,level0	;Level zero characters
	ana	a
	mov	a,c		;Scan for char in A
	jz	lookup		;Look up activity for this character
	lda	escflg
	lxi	h,level1		;Execute the default function
	cmp	m		;Otherwise test for a match
	jz	gother
	inx	h		;Bump over character
	inx	h		;Bump over function address
	inx	h
	jmp	lookup
gother:	inx	h		;Bump over character
	mov	a,m		;Get low byte of function address
	inx	h
	mov	h,m		;Get high byte of function address
	mov	l,a		;Form Address of function
	pchl			;Execute it

*****************************************************************
*								*
* Each of the following tables contains entries of the form:	*
*	1 82 Marc		Fixed MW partitioning				*
*  6  7 82 Marc		Fixed HD partitioning (again)			*
*  5 13 82 Marc		Fixed illegal MAC labels			*
*  5 11 82 Marc		Fixed North Star drive configurations		*
*  4 30 82 Marc		Fixed Quantum Q2040 tracks to 512		*
*  4 29 82 Marc		Fixed ST412 step constant to 0			*
*  4 26 82 Marc		Added unallocated writing			*
*  4 22 82 Marc		Fixed HD partition overlap			*
*  4 20 82 Marc		Started testing and debugging of E.3		*
*  4 19 82 Marc		Added 1 sector to HD warm boot loaderc		Use 'part number' equates for MW drives		*
*  3 15 82 Marc		Dropped hdrev and mwrev equates			*
*  3 15 82 Marc		Seagate ST506 head settle is 0 ms.		*
*  3 15 82 Marc		Added MiniScribe 1006 and 1012 drives		*
* *3  1 82 Marc		Public release of revision E.2			*
*  2 -- 82 Marc		Pre-release testing and debugging		*
*  2  1 82 Les + Marc	Initial coding of revision E			*
*									*
*************************************************************************

	title	'CBIOS Revision E for CP/M Versionnside of	*
* the CP/M 2.2 BDOS.  If the CBIOS is used with a different		*
* operating system then NOSTAND should be set to 0.			*
*									*
* The DEBUG flag merely causes various internal values and		*
* addresses to be printed during the assembly process.  This		*
* printing is forced via assembly errors and thus should not		*
* affect the resulting code in any way.					*
*									*
*************************************************************************

nostand	equ	1		;Set to 1 for non-sta						*
* The following equates set up the disk systems to be included		*
* along with the types of drives and the logical order of the		*
* drives.								*
*									*
*************************************************************************

maxhd	equ	0		;Set to number of HDCA hard disk drives
maxmw	equ	1		;Set to number of HDDMA hard disks
maxfd	equ	0		;Set to number of 2D/B floppies
maxdm	equ	2		;Set to number of DJ DMA floppies 8 inch
maxmf	equ	2		;Set to number of DJ DMA floppies 5 1/4 inco warm boot from.  This is the
				; CP/M logical drive number.

	if	maxmw ne 0	;Only HDDMA drives use the bad map
badsiz	equ	32		;Number of badmap entries
	else
badsiz	equ	1		;Leave one entry as filler
	endif

*************************************************************************
*									*
* Since most hard disk drives hold more than 8 megabytes we		*
* partition the drive.  We partition our drives using two different	*
* formulas.								*
*									*
* One is the so called 'standard pr		*
*  4 19 82 Marc		Added mod. number to CBIOS rev. number		*
*  4 19 82 Marc		Clean up login message 'if's			*
*  4 15 82 Marc		Fixed MCR Initialization for LST:		*
*  4 15 82 Marc		Added Seagate ST412 drive			*
*  4  6 82 Marc		Moved serial LST: device to port 2		*
*  4  1 82 Marc		Added common group select routines		*
*  4  1 82 Marc		Fixed Diablo HyType II initialization		*
*  4  1 82 Marc		Fixed LISTST for PROM driver			*
*  3 16 82 Marc		Added Tandon TM602 and TM603 drives		*
*  3 16 82 Ma 2.2 - March 4, 1982'

revnum	equ	53		;CBIOS revision number 5.x = E
cpmrev	equ	22		;CP/M revision number 2.2

*************************************************************************
*									*
* The following flags set a 'non-standard' system mode and an		*
* assembly time debugger.						*
*									*
* If this CBIOS is used with the CP/M 2.2 system that is shipped on	*
* a Morrow Designs diskette then NOSTAND can be set to 1.  This		*
* will allow the CBIOS to use various data areas found indard mode
debug	equ	0		;Set to 1 for debugging mode

*************************************************************************
*									*
* The following is set to the memory size of the CP/M the CBIOS is	*
* being created for.							*
*									*
*************************************************************************

msize	equ	48		;Memory size of target CP/M

biosln	equ	16h		;BIOS length.  Also in ABOOT&.ASM

*************************************************************************
*			h

hdorder	equ	0		;Set the order of logical drives ELSE 0 if
mworder	equ	1		; not included.
fdorder	equ	0
dmorder	equ	3
mforder	equ	2
				;HDCA controller disk drives. Set only one
m10f	equ	0		;Fujitsu M2301B
m20	equ	0		;Fujitsu M2302B
m26	equ	0		;Shugart SA4000
m10m	equ	0		;Memorex

				;HDDMA controller disk drives. Set only one
mwquiet	equ	0		;Set for no names printed on login
st506	equ	1		;Seagate ST-506
st412	equ	0		;Seagate ST-412
cm5619	equ	0		;CMI CM-5619

wmdrive	equ	0		;Device tartitioning' where we try to		*
* create as many 8 megabyte partitions as possible plus a small		*
* partition to take up the slack on the end of the drive.		*
*									*
* Another way the drives are partitioned is the so called 'even		*
* partition' formula.  This means that the drive is split into		*
* equale sized partitions with the only restriction being that no	*
* partition be over 8 megabytes in length.				*
*									*
* All hard disk drives shipped from Morrow Designs are partitioned	*
ff	equ	'S'-64		;Xoff character
aesc	equ	1bh		;Escape character
ars	equ	1eh		;RS character
aus	equ	1fh		;US character
asp	equ	' '		;Space
adel	equ	7fh		;Delete

*****************************************************************
*								*
* The jump table below must remain in the same order, the	*
* routines may be changed, but the function executed must be	*
* the same.							*
*								*
*****************************************************************

	jmp	$		;Cold boot entry point
owboot:**************************************************************
*								*
* The following word defines the default baud rate for the	*
* console device.						*
*								*
* The following is a list of possible baud rates and the	*
* value needed for the defcon word.				*
*								*
* Baud rate    defcon		Baud rate     defcon		*
*      	 50	2304		     2000	58		*
*	 75	1536		     2400	48		*
*	110	1047		     3600	32		*
*	134.5	 857		     4800	24		*
*	150	 768		     7200	16		*
*	300	 384		     9600changed as you output to the group port.  If	*
* you modify one of the other bits (such a driver-enable)	*
* then you should modify the same bit in the group byte		*
* provided.  Example:						*
*								*
*				;Select console group		*
*	lda	group		;Get group byte			*
*	ori	congrp		;Select the console port	*
*	out	grpsel		;Select the group		*
*								*
*				;Modify a bit in the group byte	*
*	lda	group		;Get group byte			*
*	ori	bank		;Set the bank bit		*
*	sta	group		;Save new group setting		hiу flaз iу useд primarilщ bщ thе paralleм		*
* driverу sincе thе paralleм porф assignmentу diffeт foт	*
* thе twп boards.						*
*								*
*****************************************************************

mother:	db	0

wboot:	jmp	start		;Warm boot write through
	dw	owboot		;Warm boot after initialization

list:	jmp	olist		;List output
	dw	otlst	

listst:	jmp	olistst		;List status
	dw	stlst	

	db	0		;End of table marker

cninit:	jmp	noop		;Console initialization
	dw	cinit

const:	jmp**********************************************************

start:	lxi	h,wboot		;Set up list device pointers
	call	setup
	lda	cpmbuf		;Test for flag
	ora	a
	lxi	h,cninit
	cz	setup		;If the flag is reset then set up more routines
	call	cninit		;Initialize console and list devices
	call	linit
	jmp	owboot		;Do regular warm boot

setup:	mov	a,m		;Test for end of table
	ora	a
	rz
	inx	h		;Bump to start of pointer
	mov	d,h		;Make 'from' pointer
	mov	e,l
	inx	d
	inx	d
	ldax	d		;Move low byte of	jmp	wboot		;Warm boot entry point
oconst:	jmp	const		;Console status routine
oconin:	jmp	conin		;Console input
oconout:jmp	conout		;Console output
olist:	jmp	list		;List device output
	jmp	$		;Punch device output
	jmp	$		;Reader device input
	jmp	$		;Home drive
	jmp	$		;Select disk
	jmp	$		;Set track
	jmp	$		;Set sector
	jmp	$		;Set DMA address
	jmp	$		;Read the disk
	jmp	$		;Write the disk
olistst:jmp	listst		;List device status
	jmp	$		;Sector translation
	jmp	$		;SINGLE.COM hookup

***	12		*
*	600	 192		    19200	 6		*
*      1200	  96		    38400	 3		*
*      1800	  64		    56000	 2		*
*								*
*****************************************************************

defcon:	dw	12		;Default console baud rate

*****************************************************************
*								*
* The next byte is to make sure that the group select byte	*
* on the Mult I/O or Decsion I stays consistant throughout	*
* the driver.  Only the group bits themselves (bits 0 and 1)	*
* should be *
*	ori	group2		;Select second serial port	*
*	out	grpsel		;Select the desired group	*
*								*
* Note: You should not set the group bits themselves in		*
*	the group byte.						*
*								*
*****************************************************************

group:	db	0		;Group byte

*****************************************************************
*								*
* Thе nexф bytе iу б motherboarд flag®  Iф iу б haу б non-	*Ќ
* zerп valuе iж б motherboarд iу presenф anд iу zerп foт б	*
* Multio®  T	oconst		;Console status
	dw	cstty

conin:	jmp	oconin		;Console input
	dw	citty

conout:	jmp	oconout		;Console output
	dw	cotty

	db	0		;End of table marker

*****************************************************************
*								*
* Thiу iу б one-time-onlщ warн booф routine®  Iф checkу		*
* foт thе presencе oж б flaз characterу and¬ iж present¬	*
* installу thе consolе driver®  Userу whп dп noф intenд tп	*
* usе б Multiп aу consolе shoulд typе б flaз argumenф '-'®	*	
*								*
******* pointer
	mov	m,a
	inx	d
	inx	h
	ldax	d		;Move high byte of pointer
	mov	m,a
	inx	h		;Bump to next table entry
	inx	h
	inx	h
	jmp	setup

noop:	ret

*****************************************************************
*								*
* Multi I/O or Decision I console driver			*
*								*
*****************************************************************

*****************************************************************
*								*
* This driver on cold boot will inspect bits 1-3 of the sense	*
** using the standard partition formula.  If the user wishes to		*
* implement even partitioning then he/she must set HDPART or MWPART	*
* to the number of partitions desired.					*
*									*
*************************************************************************

hdpart	equ	0		;Set to number of non standard partitions
mwpart	equ	0		;Set to number of non standard partitions

*************************************************************************
*									*
* The following equates define the		6	North Star motherboard (2 serial + 1 parallel)	*
*									*
* Set CBAUD to the divisor latch value for the console.  For an		*
* explanation of the values look at the DEFCON table.			*
*									*
*************************************************************************

contyp	equ	2
cbaud	equ	12

*************************************************************************
*									*
* Define the printer driver to be used.					*
*									*
* LSTTYP is:	0	Nothing, used for patching to PROM'o the divisor latch value for the printer.  For an		*
* explanation of the values see the deflst table.			*
*									*
*************************************************************************

lsttyp	equ	3
lbaud	equ	96

*************************************************************************
*									*
* The next equate determines if you have a Multi I/O Rev 3 or a		*
* Decision I mother board for parallel i/o.  If are not using		*
* either of these boards then you need not worry about this .			*
*									*
*************************************************************************

m10	equ	m10f or m10m

	if	hdpart ne 0 		;Use non standard partitions
hdlog	equ	hdpart
	else
hdlog	equ	m10*2+m20*3+m26*3	;Logical disks per drive for HDCA
	endif

	if	mwpart ne 0		;Use non standard partitions
mwlog	equ	mwpart
	else
mwlog	set	st506+st412*2++cm5619*2	;Logical disks per drive for HDDMA
	endif

hdca	equ	m26 or m20 or m10		;HDCA controller
fujitsu	equ	m20  or m10f
hdspt	equ	32*m26+21*m
bios	equ	ccp+ccpln+bdosln

offsetc	equ	2100h-bios	;Offset for sysgen

	if	debug
dbgtmp	set	offsetc		;DDT offset	! <debug>
dbgtmp	set	ccp		;CCP address	! <debug>
dbgtmp	set	bdos		;BDOS address	! <debug>
dbgtmp	set	bios		;CBIOS address	! <debug>
	endif

cdisk	equ	4		;Address of last logged disk
buff	equ	80h		;Default buffer address
tpa	equ	100h		;Transient memory
iobyte	equ	3		;IOBYTE location
wbot	equ	0		;Warm boot jump address
entry	equ	5		;BDOS entry jump address

	if	nostand ne 0
cblo console and printer environments.	*
*									*
*************************************************************************

*************************************************************************
*									*
* Define the console driver to be used.					*
*									*
* CONTYP is:	0	Nothing, used for patching to PROM's.		*
*		1	Provide for 128 bytes of patch space.		*
*		2	Multi I/O or Decision I driver.			*
*		3	2D/B driver.					*
*		4	DJDMA serial port				*
*		5	Switchboard serial port				*
*s.		*
*		1	Provide for 128 bytes of patch space.		*
*		2	Multio serial, no protocol.			*
*		3	Multio serial, Clear To Send protocol.		*
*		4	Multio serial, Data Set Ready protocol.		*
*		5	Multio serial, Xon/Xoff protocol.		*
*									*
* Note: The Decision board is functionally identical to the Multi	*
*	I/O board for serial printer I/O.  Selections 2 to 5 will	*
*	work on the Wunderbuss i/o board.  To use drivers 6 or 7	*
*	the MULTR3 equate will have to be set.				*
*									*
* Set pbaud tequate. 	*
* If you are using a Multi I/O rev. other than 3.x or 4.x then you	*
* should set MULTR3 to 0.						*
*									*
*************************************************************************

multr3	equ	0		;0 = Decision, 1 = Multi I/O rev. 3 or 4

congrp	equ	1		;Cosole port (1 = p1, 2 = p2, 3 = p3)

lstgrp	equ	3		;Printer port (1 = p1, 2 = p2, 3 = p3)

*************************************************************************
*									*
* The following equates are internal to the CBIOS20+21*m10		;Sectors per track

hdma	set	st506 or st412 or cm5619	;HD DMA controller
mwspt	equ	9				;Sectors per track

maxlog	equ	(maxhd*hdlog)+(maxmw*mwlog)+maxfd+maxdm+maxmf

*************************************************************************
*									*
* CP/M system equates.							*
*									*
*************************************************************************

ccpln	equ	800h
bdosln	equ	0e00h

size	equ	(msize*1024)
ccp	equ	size-(biosln*100h+ccpln+bdosln)
bdos	equ	ccp+ccplnck	equ	bios-19h	;Current actual block# * blkmsk
				;Used for unallocated writting
	endif

*************************************************************************
*									*
* The following are internal Cbios equates. Most are misc. constants.	*
*									*
*************************************************************************

retries	equ	10		;Max retries on disk i/o before error
clear	equ	'Z'-64		;Clear screen on an ADM 3

anul	equ	0		;Null
aetx	equ	'C'-64		;ETX character
aack	equ	'F'ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*****************************************************************
*								*
* Installable printer and console drivers.			*
*								*
*  Date	   Author	Description				*
*								*
*  6 21 82 Marc		Reversed the sense of the console flag	*
*  4  2 82 Marc		Console install flag			*
*  4  2 82 Marc		Automatic determination of hardware	*
*  3 31 82 Marc		Initial coding				*
*								*
*****************************************************************

congrp	equ	1		;Serial console port (1 = p1, 2 = qu	mbase+1		;Interupt enable register
clk	equ	mbase+2		;WB14 printer select port
lcr	equ	mbase+3		;Line control register
mcr	equ	mbase+4
lsr	equ	mbase+5		;Line status register
msr	equ	mbase+6
rbr	equ	mbase		;Read data buffer
thr	equ	mbase		;Tranmitter data buffer
dlab	equ	80h		;Divisor latch access bit
thre	equ	20h		;Status line THRE bit
cts	equ	10h		;Clear to send
dsr	equ	20h		;Data set ready
dr	equ	1		;Line status DR bit
wls0	equ	1		;Word length select bit 0
wls1	equ	2		;Word length select binter ready

; Define daisy 0 status input bits for Diablo HyType II driver

crstrd	equ	1020h		;Carriage ready
pfstrd	equ	810h		;Paper feed ready
pwstrd	equ	2040h		;Print wheel ready

; Define daisy 0 output bits

d9	equ	01h		;Data bit  9
d10	equ	02h		;Data bit 10
d11	equ	04h		;Data bit 11
d12	equ	08h		;Data bit 12

pfstb	equ	10h		;Paper feed strobe
crstb	equ	20h		;Carriage strobe
pwstb	equ	40h		;Print wheel strobe
rest	equ	80h		;Printer restore (Ribbon lift on Multi I/O)

; Define clockto 10 characters per inch
lperi	equ	6		;Default lines per inch
hinc	equ	120		;Horizontal increments per inch
vinc	equ	48		;Vertical increments per inch
numtabs	equ	160		;Number of horizontal tabs
maxchrs	equ	1024		;Maximum number of printer characters to queue
maxrgt	equ	1584		;Maximum carriage position
dfrmln	equ	110		;Forms length times 10
autolf	equ	0		;Default to no Auto line feed.

*****************************************************************
*								*
* The following are internal drivееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееp2, 3 = p3)

lstgrp	equ	3		;Serial printer port (1 = p1, 2 = p2, 3 = p3)

*****************************************************************
*								*
* The folowing equates will define the Decision I mother	*
* board I/O or the Multi I/O environments.			*
*								*
*****************************************************************

mbase	equ	48h		;Base address of Multi I/O or Decision I
grpsel	equ	mbase+7		;Group select port
dll	equ	mbase		;Divisor (lsb)
dlm	equ	mbase+1		;Divisor (msb)
ier	eit 1 for 8 bit word
stb	equ	4		;Stop bit count - 2 stop bits

; Define multi I/O ports addresses for group zero

gzero	equ	0
daisy0	equ	mbase		;Daisy input ports
daisy1	equ	mbase+1
sensesw	equ	mbase+1		;Sense switches

; Define daisy 0 status input bits

ribbon	equ	01h		;End of ribbon
paper	equ	02h		;Paper out
cover	equ	04h		;Cover open
pfrdy	equ	08h		;Paper feed ready
crrdy	equ	10h		;Carriage ready
pwrdy	equ	20h		;Print wheel ready
check	equ	40h		;Printer check (error)
ready	equ	80h		;Pr select bits

rlift	equ	40h		;Ribbon lift
pselect	equ	80h		;Select (Not used by Diablo)

; Define Modem Control Register bits

dtrenb	equ	1		;DTR enable
rtsenb	equ	2		;RTS enable

; Define group select bits (base + 7)

s0	equ	01h		;Group number (0-3)
s1	equ	02h
smask	equ	03h
bank	equ	04h
enint	equ	08h		;Enable interrupts
restor	equ	10h		;Printer restore on Multi I/O
denable	equ	20h		;Driver enable on Multi I/O

; Define special constants for the HyTyp II driver

cperi	equ	10		;Default er equates. Most are misc.	*
* constants.							*
*								*
*****************************************************************

cpmbuf	equ	80h		;CPM buffer (command flag buffer)

anul	equ	0		;Null
aetx	equ	'C'-64		;ETX character
aack	equ	'F'-64		;ACK character
abel	equ	'G'-64		;Bell
abs	equ	'H'-64		;Back Space
aht	equ	'I'-64		;Horizontal tab
alf	equ	'J'-64		;Line feed
avt	equ	'K'-64		;Vertical tab
aff	equ	'L'-64		;Form Feed
acr	equ	'M'-64		;Carriage return
xon	equ	'Q'-64		;Xon character
xo-64		;ACK character
abel	equ	'G'-64		;Bell
abs	equ	'H'-64		;Back Space
aht	equ	'I'-64		;Horizontal tab
alf	equ	'J'-64		;Line feed
avt	equ	'K'-64		;Vertical tab
aff	equ	'L'-64		;Form Feed
acr	equ	'M'-64		;Carriage return
xon	equ	'Q'-64		;Xon character
xoff	equ	'S'-64		;Xoff character
aesc	equ	1bh		;Escape character
ars	equ	1eh		;RS character
aus	equ	1fh		;US character
asp	equ	' '		;Space
adel	equ	7fh		;Delete

*************************************************************************
*							csv&nam&log
	dw	alv&nam&log
	endm

alloc	macro	nam,log,al,cs
csv&nam&log:	ds	cs
alv&nam&log:	ds	al
	endm

*************************************************************************
*									*
* The following marco is used in generating the logical order of the	*
* CP/M drives.								*
*									*
*************************************************************************

order	macro	num
	if	num eq hdorder
	dw	hddst
	endif

	if	num eq mworder
	dw	mwdst
	endif

	if	num eq fdorder
	dwtrk	equ	5	;Set track
d$ssec	equ	6	;Set sector
d$sdma	equ	7	;Set DMA address
d$read	equ	8	;Read a physical sector
d$write	equ	9	;Write a physical sector
d$bad	equ	10	;Return pointer to bad sector info

*************************************************************************
*									*
* The jump table below must remain in the same order, the routines	*
* may be changed, but the function executed must be the same.		*
*									*
*******************************************************************t device output
	endif

	if	contyp eq 6	;North Star drivers have punch entry points
	jmp	punout		;Punch device output
	else
	jmp	cout		;Use console I/O
	endif

	if	contyp eq 6	;North Star drivers have reader entry points
	jmp	rdrin		;Reader device input
	else
	jmp	cin		;Use console I/O
	endif

	jmp	home		;Home drive
	jmp	setdrv		;Select disk
	jmp	settrk		;Set track
	jmp	setsec		;Set sector
	jmp	setdma		;Set DMA address
	jmp	read		;Read the disk
	jmp	write		;Write the disk

	if	lsttyp ******************************

drconf:	db	0		;Revision 0 structure
	db	32		;32 bytes long now

*************************************************************************
*									*
* The following is the table of pointers to the Device			*
* Specification Tables.  The order of this table defines the		*
* logical order of the CP/M drives.					*
*									*
*************************************************************************

dsttab:	equ	$

dn	set	1
	rept	16
	order	%dn
dn	set	dn+1
	en		*
* The following are the macros used in generating the DPH, DPB and 	*
* allocation tables.							*
*									*
*************************************************************************

dpbgen	macro	nam,log,dspt,dbsh,dblm,dexm,ddsm,ddrm,dal0,dal1,dcks,doff,ssiz
dpb&nam&log	equ	$
	dw	dspt
	db	dbsh
	db	dblm
	db	dexm
	dw	ddsm
	dw	ddrm
	db	dal0
	db	dal1
	dw	dcks
	dw	doff
	db	ssiz
	endm

dphgen	macro	nam,log,dpb1,dpb2
dph&nam&log	equ	$
	dw	0
	dw	0,0,0
	dw	dirbuf
	dw	&dpb1&dpb2
	dw		fddst
	endif

	if	num eq dmorder
	dw	dmdst
	endif

	if	num eq mforder
	dw	mfdst
	endif
	endm

*************************************************************************
*									*
* The folloing are offset numbers of Device Specification Tables.	*
*									*
*************************************************************************

d$wboot	equ	0	;Warm boot
d$stran	equ	1	;Sector translation
d$sel1	equ	2	;Drive select, Return DPH
d$sel2	equ	3	;Drive select
d$home	equ	4	;Home drive
d$s******

	org	bios		;Cbios starting address

	jmp	cboot		;Cold boot entry point
wboote:	jmp	wboot		;Warm boot entry point

	if	contyp ne 0
const:	jmp	conist		;Console status routine
cin:	jmp	conin		;Console input
cout:	jmp	costrp		;Console output
	else
const:	jmp	$		;Console status routine PROM pointer
cin:	jmp	$		;Console input PROM pointer
cout:	jmp	$		;Console output PROM pointer
	endif

	if	(lsttyp ne 0) or (contyp eq 6)
pout:	jmp	lstout		;List device output
	else
pout:	jmp	cout		;Lisne 0
	jmp	lstost		;List device status
	else
	jmp	donop		;List device status
	endif

	jmp	sectran		;Sector translation

;
;	The following jumps are extended BIOS calls defined by Morrow Designs
;

	if	maxfd ne 0
	jmp	fdsel		;Hookup for SINGLE.COM program
	else
	jmp	donop
	endif

	jmp	0		;End of the jump table

*************************************************************************
*									*
* Drive configuration table.						*
*									*
*******************************************dm

*************************************************************************
*									*
* I/O configuration table.						*
*									*
* At this CBIOS revision 11 bytes are defined for this table.		*
* Several extensive changes are planned for the table.  Future		*
* revision of the IOCONF table will have independant entries for	*
* three serial ports and will be used by several character drivers.	*
* Also the IOBYTE will be implemented for all the character		*
* drivers.  I might even write an e crc bytes
	ld	a,90h		;Reset the crc
	ld	(de),a		;Change modes
	ld	b,0bh		;Sector header postamble length
sdlbl7:	ld	(hl),0ffh
	djnz	sdlbl7		;Write the postamble
	ld	a,80h		;16 bit write mode
	ld	(de),a		;Change modes
	ld	b,0ch		;Data field preamble length
sdlbl8:	ld	(hl),0aah	;Half a zero cell
	djnz	sdlbl8		;Write the preamble
	ld	a,81h		;Enable crc & 16 bit write
	ld	(de),a		;Change modes
	ld	(hl),0f5h	;First half of fb
	ld	a,91h		;8 bit write
	ld	(de),a		;Change modes
	ld	(hl),6fh	;Seconffh
	djnz	sdlbla		;Write the postamble
	jr	nz,smloop	;Test for more sectors to format
	ld	(hl),0ffh	;First fill byte
	ld	b,0		;Side bit
sdsbit	equ	$-1
	ld	a,(sside)	;Get the current side
	xor	b		;Conditionally switch side bits
	ld	(sside),a	;Update the side byte
	ld	(hl),0ffh	;Write second fill byte
	ld	b,19h		;Preamble length less one
	ex	Af,Af'		;Save the double sided status
sdlblb:	ld	(hl),0ffh	;Write a fill byte
	ld	a,(status)
	and	index
	jr	z,sdlblb	;Wait for the index hole
	ex	Af,Af'			;Advance track value
	ld	(strck),a	;Update the track value
	ret			;Return with track value
	.dephase
	page
;
;	North Star multi desity formatter routine
;
nsform	equ	$
	.phase	1030h
nsfmt:	ld	a,0
	call	sdrive
	ret	nz
	ld	(ix+0bh),0
	ld	a,(iy+2)
	or	0eh
	ld	(4004h),a
	call	hsync
nsexit:	ld	a,82h
	ret	z
track0:	call	home
	bit	5,(hl)
	jr	z,nsexit

entry:	ld	(ix+0bh),0
	ld	a,(track)
	cp	(iy+1)
	call	nz,seek
	ld	a,(4003h)
	and	40h
	ld	a,90h
	ret	nz
	ld	(ix+0ah),80h
wsect0:	call	a	equ	$-1
	xor	a
d1loop:	ex	(sp),hl
	ex	(sp),hl
	ld	(hl),e
	xor	e
	rlca
	djnz	d1loop
	ld	b,51h
den2	equ	$-1
	ex	(sp),hl
	ex	(sp),hl
	ld	(hl),d
	xor	d
	rlca
	ex	Af,Af'
	ld	a,e
	ld	(cpdata),a
	ex	Af,Af'
	ex	(sp),hl
	ex	(sp),hl
	ld	(hl),e
	xor	e
	rlca
d2loop:	ex	(sp),hl
	ex	(sp),hl
	ld	(hl),e
	xor	e
	rlca
	ex	(sp),hl
	ex	(sp),hl
	ld	(hl),e
	xor	e
	rlca
	djnz	d2loop
	ex	(sp),hl
	ex	(sp),hl
	ld	(hl),a
	ld	a,(den1)
	or	a
	ld	b,11h
	jr	z,$+4
	ld	b,20h
iloop:	ex	(sp),hl
	 track value
	ld	(track),a	;Update the track value
	ret			;Return with track value
track:	0
nsdsid:	0
	.dephase
ecode	equ	$		;End of code marker, stack follows
	ds	30h		;Room for the stack
buffer	equ	$		;Track read buffer

	end
 CBIOS&  ASM  ЂNOPQRSTUVWXYZ[\] CBIOS&  ASM	  ^_`abcdef        DEBLOCK ASM   Pghijk            DUMP    ASM   !lmn              FORMATDJ$$$  Ђopqrstuvwxyz{|}~ FORMATDJ$$$                    HYTYPE  ASM  ~ЂЃ‚ѓ„…†‡€‰Љ‹ЊЌЋЏ HYTYPE  PRL   ђ               d half of fb
	ld	b,80h		;Sector data field length
sdlbl9:	ld	(hl),0e5h
	djnz	sdlbl9		;Write the data field
	ld	a,0a1h
	ld	(de),a		;Change modes
	ld	(hl),a
	ld	(hl),a		;Write the crc bytes
	ld	a,90h		;Reset the crc
	ld	(de),a		;Change modes
	ld	a,(ssect)	;Get the current sector
	inc	a		;Advance
	cp	1bh		;Compare with 27
	ld	(hl),0ffh	;First postamble byte
	jr	nz,$+4		;Zero => all sectors written
	ld	a,1
	ld	(ssect),a	;Update the sector
	ld	b,1ah		;Postamble length less one
sdlbla:	ld	(hl),0;Recover the double sided status
	jr	z,sdlblc	;Zero => single sided
	ld	a,(iy+2)	;Get the drive pattern
	or	0ch		;Turn off the step command
	and	0fdh		;Turn on head one
	ld	(4005h),a	;Update drive control register
	ld	(hl),0ffh	;Write first preamble byte
	jp	sdlbl3		;Go format the other side
sdlblc:	ld	(hl),0ffh	;Trailing byte
	xor	a
	ld	(de),a		;Turn off write gate
	ld	a,6
	ld	(4006h),a	;Turn off the controller
	ld	a,40h		;Status code
	ret
sdadvt:	ld	a,(strck)	;Get the current track
	inc	a	hsync
	jr	z,nsexit
	xor	a
	cp	(ix+0ah)
	jr	nz,wsect0
	ld	a,90h
	ld	(contrl),a
	ld	hl,diskd
	ld	c,0
	ld	(ix+9),c
	ld	b,11h
	ld	a,0
den1	equ	$-1
	rra
	ld	a,64h
	jr	nc,cstart
	ld	a,18h
strack	equ	$-1
	rra
	add	a,5
	cp	(iy+1)
	sbc	a,a
	and	10h
	or	24h
	ld	b,20h
cstart:	ld	(4006h),a

zerow:	ld	(hl),0
	ex	(sp),hl
	ex	(sp),hl
	djnz	zerow
	ld	a,(den1)
	or	a
	jr	z,lasts
	ld	(hl),0fbh
	ex	(sp),hl
	ex	(sp),hl
lasts:	ld	(hl),0fbh
	ld	b,5ch
	ld	e,20h
data	equ	$-1
	ld	d,20h
cpdatex	(sp),hl
	ld	(hl),e
	ld	a,(status)
	and	index
	jr	z,iloop
	inc	c
	ld	a,0ah
	cp	c
	jr	nz,zerow
	ld	c,0

	ld	a,0
	ld	(contrl),a	;Turn off the controller (& write gate)

	push	bc		;Delay 1 m.s.
	ld	b,200d
dssllp:	ld	a,a
	djnz	dssllp
	pop	bc

	ld	a,(nsdsid)
	xor	0
dflag	equ	$-1
	ld	(nsdsid),a
	jr	z,ftdone
	ld	a,(iy+2)
	or	0eh
	and	0fdh
	ld	(4004h),a
	jp	entry
ftdone:	ld	(contrl),a	;Turn off write gate
	ld	a,40h
	ret
advtrk:	ld	a,(track)	;Get the current track
	inc	a		;Advanceееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееexternal program to edit this		*
* table.								*
*									*
* The first two bytes show the I/O configuration that the CBIOS was	*
* assembled with.  These bytes are used by external software to		*
* determine the configuration options that are available.		*
*									*
* The next byte is the initial IOBYTE value.  This value is written	*
* to location 3 on cold boots.  See the CP/M 2 alternation guide	*
* for a description of the IOBYTE.					*
*									*
* The next byte is to make sure that t				*
*				;Modify a bit in the group byte		*
*	lda	group		;Get group byte				*
*	ori	bank		;Set the bank bit			*
*	sta	group		;Save new group setting			*
*	ori	group2		;Select second serial port		*
*	out	grpsel		;Select the desired group		*
*									*
* Note: You should not set the group bits themselves in the		*
*	group byte.							*
*									*
*									*
* The following two words define the default baud rates for the		*
* console and the list devices.  These words are provided so that	*
		    19200	 6			*
*      1200	  96		    38400	 3			*
*      1800	  64		    56000	 2			*
*									*
*									*
* The next two bytes are ued to configure the hardware handshaking	*
* protocall used by the serial list drivers with the Multio or		*
* Wunderbuss I/O boards.  The first of these two bytes is a mask. 	*
* This mask is ANDed with the 8250's MODEM Status Register to strip	*
* out the desired handshake lines.  Next the result of the ANDing	*
* is XORed with the second of the two bytes.  T  This byte is used to		*
* implement Xon/Xoff software handshaking.  This handshaking		*
* protocol should not bother printers that have not implemented		*
* Xon/Xoff protocol so this driver is enabled all the time.		*
*									*
*************************************************************************

ioconf:	db	2		;Revision 2 structure
	db	11		;11 bytes long now
	db	contyp		;Console device driver number
	db	lsttyp		;List device drive number

iobyt	equ	$		;The initial IOBYTE is kept here
	dtand:	db	dsr		;Serial list handshake mask
lstxor:	db	0		;Serial list inversion flag
	endif

lastch:	db	xon		;Last character recieved from the printer

*************************************************************************
*									*
* The following table are drive parameters for drives connected to	*
* the DJDMA floppy disk controller.  There is one entry for each of	*
* the the eight drive that the controller can address.  The first	*
* four entries are for the 8 inch drives and the last fouhe group select byte on the	*
* Mult I/O or Decsion I stays consistant throughout the Cbios. 		*
* Only the group bits themselves (bits 0 and 1) should be changed	*
* as you output to the group port.  If you modify one of the other	*
* bits (such as driver-enable) then you should modify the same bit	*
* in this byte.  For example:						*
*									*
*				;Select console group			*
*	lda	group		;Get group byte				*
*	ori	congrp		;Select the console port		*
*	out	grpsel		;Select the group			*
*					* the user can easily modify them and that they will also be used	*
* in the future by Morrow Designs software.				*
*									*
* The following is a list of possible baud rates and the decimal	*
* value needed for the defcon or deflst words.				*
*									*
* Baud rate	defcon/deflst	Baud rate	defcon/deflst		*
*	 50	2304		     2000	58			*
*	 75	1536		     2400	48			*
*	110	1047		     3600	32			*
*	134.5	 857		     4800	24			*
*	150	 768		     7200	16			*
*	300	 384		     9600	12			*
*	600	 192his XORing allows	*
* the handshake lines to be inverted.  Common byte values are		*
* shown below.								*
*									*
* cts	equ	10h		;Clear To Send status mask		*
*									*
*	db	cts		;Morrow Designs 'Clear To Send'		*
*	db	0							*
*									*
*	db	cts		;Inverted Clear To Send			*
*	db	cts							*
*									*
*	db	0		;No handshaking				*
*	db	0ffh							*
*									*
*									*
* The last byte in the revision one structure is the last character	*
* that was recieved from the printer.b	00$00$00$00b	;All devices go to CON:

group:	db	0		;Group byte
defcon:	dw	cbaud		;Console baud rate divisor value
deflst:	dw	lbaud		;Printer baud rate divisor value

	if	(lsttyp ne 3) and (lsttyp ne 4)	;Xon/Xoff protocol
lstand:	db	0		;Serial list handshake mask
lstxor:	db	0ffh		;Serial list inversion flag
	endif

	if	lsttyp eq 3	;Clear To Send protocol
lstand:	db	cts		;Serial list handshake mask
lstxor:	db	0		;Serial list inversion flag
	endif

	if	lsttyp eq 4	;Data Set Ready protocol
lsr are for	*
* the 5 1/4 inch drives.  Users with fast stepping 8 inch drives	*
* (SA850/1) or slow 5 1/4 inch drives (SA400) should adjust this	*
* table for optimal device performace.					*
*									*
* Each table entry contains four fixed length fields.  The fields	*
* are defined as follows:						*
*									*
*	tracks	This byte contains the number of tracks on the		*
*               drive.  Most 8 inch drives have 77 tracks and		*
*               most 5 1/4 inch drives have 35 or 40 tracks.		d	(hl),0		;Write the track number
dtrck	equ	$-1
	ld	(hl),0		;Write the side
dside	equ	$-1
	ld	(hl),1		;Write the sector number
dsect	equ	$-1
	ld	(hl),1		;Sector length code
dlcode	equ	$-1
	ld	a,0a1h		;Mode to write crc bytes
	ld	(de),a		;Change mode
	ld	(hl),a
	ld	(hl),a		;Write the crc bytes
	ld	a,90h		;Reset crc generator
	ld	(de),a		;Change mode
	ld	b,16h		;4e postamble length
ddlbl7:	ld	(hl),4eh
	djnz	ddlbl7		;Write the postamble
	ld	b,0ch		;Data field preamble
ddlbl8:	ld	(hl),0
	djnz bytes
	djnz	ddlbl9		;Test for data field write done
	ld	a,0a1h		;Crc control byte
	ld	(de),a		;Change mode
	ld	(hl),a		;Write the crc bytes
	ld	(hl),a
	ld	a,90h		;Turn off the crc generator
	ld	(de),a		;Change mode
	ld	a,(dsect)	;Get the sector number
	inc	a
	cp	1bh		;Test for last sector +1
dlast	equ	$-1
	ld	(hl),4eh	;First byte of postamble
	jr	nz,$+4		;Zero => all sectors written
	ld	a,1
	ld	(dsect),a	;Update the sector number
	ld	b,35h		;Postamble length less one
ddlbla:	ld	(hl),4eh
	=> track write is done
	ld	a,(iy+2)	;Drive pattern
	or	0ch		;Turn off the step command
	and	0fdh		;Change read/write heads
	ld	(4005h),a	;Update the command register
	ld	(hl),4eh	;First preamble byte
	jp	ddlbl3		;Format the other side
ddlblc:	ld	(hl),4eh	;Trailing fill byte
	ld	(hl),4eh	;Trailing fill byte
	ld	(hl),4eh	;Trailing fill byte
	xor	a
	ld	(de),a		;Turn off the write gate
	ld	a,6
	ld	(4006h),a	;Turn off the controller
	ld	a,40h		;Status code
	ret
ddadvt:	ld	a,(dtrck)	;Get the curreec	hl
	ld	a,h
	or	l
	jr	nz,sdwait
	ld	(ix+0bh),a	;Reset the index counter
sdtrk0:	call	home		;Calibrate the head(s)
	bit	5,(hl)		;Test for track zero
	jr	z,snrext
sdrdy:	ld	hl,status
	bit	7,(hl)		;Test for the drive ready
snrext:	ld	a,82h		;Drive not ready code
	ret	z		;Error exit
	bit	6,(hl)		;Write protect bit
	ld	a,90h		;Write protect error code
	ret	nz
	ld	(ix+0bh),0	;Reset the index counter
	ld	a,(strck)	;Get the new track
	cp	(iy+1)		;Compare with current track
	call	nz,seek		;Do tra	a,80h		;16 bit write mode
	ld	(de),a		;Change modes
	ld	b,0ch		;Zero preamble length
sdlbl4:	ld	(hl),0aah	;Half a zero cell
	djnz	sdlbl4		;Write the zero preamble
	ld	(hl),0f7h	;First half of fc
	ld	a,90h		;8 bit write mode
	ld	(de),a		;Change modes
	ld	(hl),7ah	;Second half of fc
	ld	b,1ah		;Postamble length
sdlbl5:	ld	(hl),0ffh
	djnz	sdlbl5		;Write the postamble

smloop:	ld	a,80h		;16 bit write mode
	ld	(de),a		;Change modes
	ld	b,0ch		;Sector header preamble length
sdlbl6:	ld	(hl),0aah	;	ddlbl8		;Write the preamble
	ld	a,81h		;16 bit write w/crc
	ld	(de),a		;Change mode
	ld	(hl),44h	;First half of a1
	ld	(hl),89h	;Second half of a1
	ld	(hl),44h	;Second a1
	ld	(hl),89h
	ld	(hl),44h	;Third a1
	ld	a,91h		;8 bit write w/crc
	ld	(de),a		;Change mode
	ld	(hl),89h	;Finish the 3 sync bytes
	ld	(hl),0fbh	;Data header id byte
	ld	b,40h		;Sector length divided by four
dsize	equ	$-1
ddlbl9:	ld	(hl),0e5h	;Empty sector data byte
	ld	(hl),0e5h
	ld	(hl),0e5h
	ld	(hl),0e5h	;Write four filldjnz	ddlbla		;Write the postamble
	jr	nz,dmloop
	ld	(hl),4eh	;First fill byte
	ld	b,0		;Double sided bit test
ddsbit	equ	$-1
	ld	a,(dside)
	xor	b		;Conditionally switch the side byte
	ld	(dside),a	;Update the side byte
	ld	(hl),4eh	;Second fill byte
	ld	b,4fh		;Preamble length less one
	ex	Af,Af'		;Save the double sided status
dlblb:	ld	(hl),4eh	;Write a fill byte
	ld	a,(status)
	and	index		;Wait for the index pulse
	jr	z,dlblb
	ex	Af,Af'		;Recover the double sided status
	jr	z,ddlblc	;Zero nt track value
	inc	a		;Increment
	ld	(dtrck),a	;Restore the new value
	ret			;Return with current track value
	.dephase
	page
;
;	IBM 8 inch double density formatter routine
;
single	equ	$
	.phase	1030h
sdfmt:	ld	a,0		;Second byte filled with proper drive number
	call	sdrive		;Select the new drive
	ret	nz		;Return if wrong value
	ld	a,(iy+2)	;Get the drive pattern
	or	0fh		;Side 0 and no step command
	ld	(4005h),a	;Update drive control register
	ld	hl,0		;Delay for the head load
sdwait:	dck seek if necessary
	ld	hl,diskd	;Controller data register
	ld	de,contrl	;Control register
	ld	b,28h		;Preamble length
sdlbl1:	ld	a,(status)
	and	index	
	jr	nz,sdlbl1	;Wait for no index pulse
sdlbl2:	ld	a,(status)
	and	index
	jr	z,sdlbl2	;Wait for leading edge of new index pulse
	ld	a,90h		;Clear the crc register & turn on write gate
	ld	(de),a		;Change modes
	ld	a,44h		;Single density & start bit
	ld	(4006h),a	;Start the controller
sdlbl3:	ld	(hl),0ffh
	djnz	sdlbl3		;Write the preamble
	ldHalf a zero cell
	djnz	sdlbl6		;Write the preamble
	ld	a,81h		;Enable crc & 16 bit write
	ld	(de),a		;Change modes
	ld	(hl),0f5h	;First half of fe
	ld	a,91h		;Enable crc & 8 bit write
	ld	(de),a		;Change modes
	ld	(hl),7eh	;Second half of fe
	ld	(hl),0		;Write the track
strck	equ	$-1
	lD	(hl),0		;Write the side byte
sside	equ	$-1
	ld	(hl),1		;Write the sector number
ssect	equ	$-1
	ld	(hl),0		;Write the sector length code
	ld	a,0a1h
	ld	(de),a		;Change modes
	ld	(hl),a
	ld	(hl),a		;Write th*
*									*
*	config	This a a flag byte that indicates as to whether		*
*               or not this drive has been configured.  Set to		*
*               0 to force reconfiguration.				*
*									*
*	step	This word contains the stepping rate constant. 		*
*               The DJDMA's delay routines tick 34.1 times per		*
*               millisecond.  Thus the step constant would be the	*
*               drive manufactors recomended stepping delay times	*
*               34.1.  Example.  Shugart     milliseconds.  The settle constant would be 15 *	*
*               34.1 or 512.						*
*									*
* An assembler macro (dconf) has been provided to assist in		*
* generating the dparam table.  This macros parameters are the		*
* number of tracks, the step rate in milliseconds, and the head		*
* settle time in milliseconds.  For example:				*
*									*
*				;Shugart SA 850				*
*	dconf	77, 3, 15	;77 tracks, 3 ms step, 15 ms settle	*
*									*
*				;Shugart SA 400				*
*	dconf	35, 40, 10			;Reset the calibrated flag
	dw	step*341/10		;Step time
	dw	0			;Reserved for future use, must be zero
	dw	0			;Reserved for future use, must be zero
	dw	settle*341/10		;Head settle time
	endm

dmarap:	db	0, 10*8			;Revision 0, length 80 bytes

dparam:	equ	$			;Drive parameter table

*************************************************************************
*									*
* Define 8 inch drive parameters					*
* Use SA800 parameters: 77 tracks, 8 ms step, 8 ms settle		*
*									*
************e 1
	dconf	40, 5, 15		;Drive 2
	dconf	40, 5, 15		;Drive 3

	endif

*************************************************************************
*									*
* Console driver routines.						*
*									*
* Routine used depends on the value of CONTYP.  Possible CONTYP		*
* values are listed as follows:						*
*									*
* CONTYP is:	0	Nothing, used for patching to PROM's		*
*		1	Provide for 128 bytes of patch space		*
*		2	Multi I/O or Decision I driver			*
*		3	2D/B driver					*
*		4	DJDMA seri	;Strip parity on conout
	ani	7fh
	mov	c,a
	jmp	conout

	endif

*****************************************************************
*								*
* The folowing equates will define the Decision I mother	*
* board I/O or the Multi I/O environments if needed.		*
*								*
*****************************************************************

multio	equ	(contyp eq 2) or (lsttyp ge 2)	;Multi I/O board used?

	if	multio		;Define Multi I/O environment
mbase	equ	48h		;Base address of Multi I/O or DecisionSA 850's step at 3		*
*               milliseond intervals.  The step constant would be	*
*               3 * 43.1 or 102.					*
*									*
*	rfu	The next two words are reserved for future use.		*
*		They must be zero.					*
*									*
*	settle	This word is similar to the previously defined		*
*               step word.  This specifies the head settle timing	*
*               after the heads have been stepped.  Example,		*
*               Shugart's SA 850 head settle time is 15			*
*           ;35 tracks, 40 ms step, 10 ms settle	*
*									*
* Note: Caution should be used when defining the drive parameters. 	*
* Incorrect definations may damage the floppy disk drive.  Morrow	*
* Designs takes no responsibility for damage that occures through	*
* the misuse of this macro.						*
*									*
*************************************************************************

	if	(maxdm ne 0) or (maxmf ne 0)	;DJDMA present?

dconf	macro	tracks, step, settle
	db	tracks			;Number of tracks
	db	0	*************************************************************

	dconf	77, 8, 8		;Drive 0
	dconf	77, 8, 8		;Drive 1
	dconf	77, 8, 8		;Drive 2
	dconf	77, 8, 8		;Drive 3

*************************************************************************
*									*
* Define 5 1/4 inch drive parameters					*
* Use Tandon parameters: 40 tracks, 5 ms step, 15 ms settle		*
*									*
*************************************************************************

	dconf	40, 5, 15		;Drive 0
	dconf	40, 5, 15		;Drival port				*
*		5	Switchboard serial port				*
*		6	North Star motherboard (2 serial + 1 parallel)	*
*									*
*************************************************************************

*************************************************************************
*									*
* This routine is an experiment to reduce missed and garbled		*
* characters on console output.						*
*									*
*************************************************************************

	if	contyp ne 0

costrp:	mov	a,c	 I
grpsel	equ	mbase+7		;Group select port
dll	equ	mbase		;Divisor (lsb)
dlm	equ	mbase+1		;Divisor (msb)
ier	equ	mbase+1		;Interupt enable register
clk	equ	mbase+2		;WB14 printer select port
lcr	equ	mbase+3		;Line control register
mcr	equ	mbase+4
lsr	equ	mbase+5		;Line status register
msr	equ	mbase+6
rbr	equ	mbase		;Read data buffer
thr	equ	mbase		;Tranmitter data buffer
dlab	equ	80h		;Divisor latch access bit
thre	equ	20h		;Status line THRE bit
cts	equ	10h		;Clear to send
dsr	equ	20h		;Data s North Star format."
	db	0
	db	"c", "C", acr, 81h
	db	"    CP/M format."
	db	0

simess:	db	"Select: S - single sided or", acr, alf
	db	"	D - double sided media.", acr, alf
	db	"	"
	db	0
	db	2
	db	"s", "S", acr, 80h
	db	"    Single sided media selected."
	db	0
	db	"d", "D", 81h
	db	"    Double sided media selected."
	db	0

nrmess:	db	"Drive not ready - (R)estart program, or (C)ycle: "
	db	0
	db	2
	db	"r", "R", 80h
	db	"Restarting program"
	db	0
	db	"c", "C", acr, 81h
	db	"Cycling"
	 door and then press <RETURN> "
	db	0
	db	1
	db	alf, acr, 80h
	db	0

ftmess:	dw	crlfs
	db	"Formatting track:"
ftrack:	db	"  0"			;ASCII track number
	db	0

vtmess:	dw	crlfs
	db	"Verifying track: "
vtrack:	db	"  0"
	db	0

bsmess:	db	8, 8, 8			;Back terminal 3 spaces
	db	0

otrack:	db	"  0"			;Old ASCII track number
	db	0

vdmess:	dw	crlfs, crlfs
	db	"Verify done."
	dw	crlfs
	db	0

vemess:	dw	crlfs, crlfs
	db	"Fatal verify error, probable bad diskette."
	dw	crlfs
	db	0

vsmess:retrys:	db	0			;Retry counter, soft
valid:	db	0			;Temp save for number of valid replies
string:	dw	0			;Temp pointer to parse trees

sectab:	db	0, 0, 0, 0, 0, 0, 0, 0, 0, 0	;Sector status table
	db	0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	db	0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	page
;
;	The following routines are the actual formatting routines.
;	These routines are loaded into controller RAM at 1030h
;	and executed as needed.  Currently there are 3 routines:
;
;	IBM 8 inch single density.
;	IBM 8 inch double dck
	call	nz,seek		;Move the head(s) if needed
	ld	hl,diskd	;Pointer to disk shift register
	ld	de,contrl	;Pointer to control port
	pop	af		;Recover the tack
	cp	2bh		;Compare with track 43
	ld	a,4		;No write precompensation
	jr	c,loadpc	;Carry => track is less than 43
	ld	a,14h		;Write precompensation bit set
loadpc:	ld	(precmp),a	;Setup the write precompensation byte
	sbc	a,a		;Push carry bit throughout accumulator
	or	0feh		;Low current bit now set
	and	(iy+2)		;Merge with drive pattern
	or	2d	(4006h),a	;Start the controller
ddlbl3:	ld	(hl),4eh
	djnz	ddlbl3		;Write the preamble
	ld	b,0ch		;Zero preamble length
ddlbl4:	ld	(hl),0
	djnz	ddlbl4		;Write the zero preamble
	ld	a,80h		;Control byte for 16 bit write
	ld	(de),a		;Change mode
	ld	(hl),52h	;First half of c2
	ld	(hl),24h	;Second half of c2
	ld	(hl),52h	;Another c2
	ld	(hl),24h
	ld	(hl),52h	;The third c2
	ld	a,90h		;Control byte 8 bit write
	ld	(de),a		;Change mode
	ld	(hl),24h	;Finish the sync bytes
	ld	(hl),0fch	;Index markdb	0

femess:	dw	crlfs
	db	"Drive has become 'not ready' during formatting"
	db	0

wpmess:	db	"Write protected - (R)estart program, or (C)ycle: "
	db	0
	db	2
	db	"r", "R", 80h
	db	"Restarting program"
	db	0
	db	"c", "C", acr, 81h
	db	"Cycling"
	db	0

wdmes5:	dw	crlfs, crlfs
	db	"Insert a write enabled diskette in 5 1/4 inch drive "
wdriv5:	db	"0."
	db	0

wdmes8:	dw	crlfs, crlfs
	db	"Insert a write enabled diskette in 8 inch drive "
wdriv8:	db	"0."
	db	0

wdmess:	db	"Close the drive	dw	crlfs, crlfs
	db	"Sector verify error"
	dw	crlfs
	db	0

crlf:	dw	crlfs
	db	0
	page
drive:	db	0			;# of drive being formatted
densty:	db	0			;Density flag for current drive
nspt:	db	0			;Number of sectors per track
trksiz:	dw	0			;Size of a track (bytes)
verval:	db	0			;Byte to verify with
nside:	db	0			;Number of sides flag
ntrack:	db	0			;Number of tracks on current drive
ctrack:	db	0			;Current track number
ptrk:	dw	0			;Pointer to ASCII track #

retryh:	db	0			;Retry counter, hard
ensity.
;	North Star 5 1/4 inch multi desity.
;

;
;	IBM 8 inch single density formatter routine
;
double	equ	$
	.phase	1030h
ddfmt:	ld	hl,status
	bit	7,(hl)		;Check that the drive is ready
nrexit:	ld	a,82h		;Drive not ready error code
	ret	z		;Error exit
	bit	6,(hl)		;Test for write protected
	ld	a,90h		;Write protected error code
	ret	nz		;Error exit
	ld	(ix+0bh),0	;Reset index counter
	ld	a,(dtrck)	;Get the new track value
	cp	(iy+1)		;Compare with current track
	push	af		;Save the tra		;Select side 0
	ld	(iy+2),a	;Restore drive pattern
	or	0ch		;Turn off step command
	ld	(4005h),a	;Update the drive register
	ld	b,50h		;Preamble length
ddlbl1:	ld	a,(status)
	and	index		;Look for index pulse
	jr	nz,ddlbl1	;Wait for no index pulse present
ddlbl2:	ld	a,(status)
	and	index
	jr	z,ddlbl2	;Wait for leading edge of new indes pulse
	ld	a,90h		;Control byte - normal write/no crc
	ld	(de),a		;Initialize control port
	ld	a,0
precmp	equ	$-1		;Write precompensation & controller start
	l
	ld	b,32h		;Postamble length
ddlbl5:	ld	(hl),4eh
	djnz	ddlbl5		;Write the postamble

dmloop:	ld	b,0ch		;Zero preamble length
ddlbl6:	ld	(hl),0
	djnz	ddlbl6		;Write the preamble
	ld	a,81h		;16 bit write mode w/crc
	ld	(de),a		;Change mode
	ld	(hl),44h	;First half of a1
	ld	(hl),89h	;Second half of a1
	ld	(hl),44h	;Second a1
	ld	(hl),89h
	ld	(hl),44h	;Third a1
	ld	a,91h		;8 bit write mode w/crc
	ld	(de),a		;Change mode
	ld	(hl),89h	;Finish sync bytes
	ld	(hl),0feh	;Sector header id byte
	let ready
dr	equ	1		;Line status DR bit
wls0	equ	1		;Word length select bit 0
wls1	equ	2		;Word length select bit 1 for 8 bit word
stb	equ	4		;Stop bit count - 2 stop bits

; Define multi I/O ports addresses for group zero

gzero	equ	0
daisy0	equ	mbase		;Daisy input ports
daisy1	equ	mbase+1
sensesw	equ	mbase+1		;Sense switches

	if	multr3 eq 0	;Daisy output ports are different
daisi0	equ	mbase		;   for Decision I and Multi I/O.
daisi1	equ	mbase+1		;These two are the Decision I ports
	else
daady
pwstrd	equ	2040h		;Print wheel ready

; Define daisy 0 output bits

d9	equ	01h		;Data bit  9
d10	equ	02h		;Data bit 10
d11	equ	04h		;Data bit 11
d12	equ	08h		;Data bit 12

pfstb	equ	10h		;Paper feed strobe
crstb	equ	20h		;Carriage strobe
pwstb	equ	40h		;Print wheel strobe
rest	equ	80h		;Printer restore (Ribbon lift on Multi I/O)

; Define clock select bits

rlift	equ	40h		;Ribbon lift
pselect	equ	80h		;Select (Not used by Diablo)

; Define Modem Control Register bits

dtrenb	equ	1	er of horizontal tabs
maxchrs	equ	1024		;Maximum number of printer characters to queue
maxrgt	equ	1584		;Maximum carriage position
dfrmln	equ	110		;Forms length times 10
autolf	equ	0		;Default to noIAuto line feed

	endif

*****************************************************************
*								*
* CONTYP: 2	Multi I/O or Decision I console driver		*
*								*
*****************************************************************

	if	contyp eq 2

***********************************************		010 = 1200						*
*		011 = 2400						*
*		100 = 4800						*
*		101 = 9600						*
*		110 = 19200						*
*	     defcon = 9600						*
*									*
* Note:	If you are using a Multio then the switches will not be		*
*	available so the baud rate will be taken from DEFCON.	        *
*									*
*************************************************************************

*************************************************************************
*									*
* Due to its length, the TTYSET routine driver p parity
	ret

*****************************************************************
*								*
* Output a character to serial port.				*
*								*
*****************************************************************

conout:	call	selcon		;Select console

conout1:in	lsr		;Read status
	ani	thre		;Wait till transmitter buffer empty
	jz	conout1
	mov	a,c		;Character is in (c)
	out	thr		;Output to transmitter buffer
	ret

*****************************************************************
*								*
isi0	equ	mbase+1		;   and these are the Multi I/O's.
daisi1	equ	mbase
	endif

; Define daisy 0 status input bits

ribbon	equ	01h		;End of ribbon
paper	equ	02h		;Paper out
cover	equ	04h		;Cover open
pfrdy	equ	08h		;Paper feed ready
crrdy	equ	10h		;Carriage ready
pwrdy	equ	20h		;Print wheel ready
check	equ	40h		;Printer check (error)
ready	equ	80h		;Printer ready

; Define daisy 0 status input bits for Diablo HyType II driver

crstrd	equ	1020h		;Carriage ready
pfstrd	equ	810h		;Paper feed re	;DTR enable
rtsenb	equ	2		;RTS enable

; Define group select bits

s0	equ	01h		;Group number (0-3)
s1	equ	02h
smask	equ	03h
bank	equ	04h
enint	equ	08h
restor	equ	10h		;Printer restore on Multi I/O
denable	equ	20h		;Driver enable on Multi I/O

; Define special constants for the HyTyp II driver

cperi	equ	10		;Default to 10 characters per inch
lperi	equ	6		;Default lines per inch
hinc	equ	120		;Horizontal increments per inch
vinc	equ	48		;Vertical increments per inch
numtabs	equ	160		;Numb**************************
*									*
* This driver on cold boot will inspect bits 1-3 of the sense		*
* switches.  If the value found is in the range 0-6 then the		*
* console baud rate will be taken from the rate table.  Otherwise	*
* the baud rate will be set from the DEFCON word which is found		*
* just below the regular Cbios jump table.  The standard divisor	*
* table is given below.							*
*									*
* Sense switch: 123  (0 = off, 1 = on)					*
*		000 = 110						*
*		001 = 300						*
*is below the CBOOT	*
* CBOOT routine.							*
*									*
*************************************************************************

*****************************************************************
*								*
* Read a character from the serial port.			*
*								*
*****************************************************************

conin:	call	selcon		;Select console

conin1:	in	lsr		;Read status register
	ani	dr		;Wait till character ready
	jz	conin1
	in	rbr		;Read character
	ani	7fh		;Stri* Return serial port status.  Returns zero if character is not	*
* ready to be read.  Else returns 255 if ready.			*
*								*
*****************************************************************

conist:	call	selcon		;Select console

	in	lsr		;Read status register
	ani	dr
	rz			;No charactter ready
	mvi	a,0ffh		;Character ready
	ret

	endif			;Multi I/O or Decision I

*****************************************************************
*								*
* CONTYP: 3	2DB console driver				*
*								*flag will be set.
;
getc:	push	hl
	ld	hl,crlf			;Print an initial CRLF
	call	putm
	pop	hl
	call	putm			;Print prompt
	inc	hl			;Bump to number of valid replies
	ld	c,(hl)
	ld	a,c
	ld	(valid),a		;Save reply count
	ld	(string),hl		;Save string pointer
gtchk:	push	bc			;Save reply count
	push	hl			;Save string pointer
gtwait:	ld	c,direct		;Direct console I/O
	ld	e,255			;We want input!
	call	bdos
	or	a			;Test for no character typed
	jp	z,gtwait		;Wait for a character
	pop	hl
	pop	bc
	cp	3nc	hl			;Bump to response message
	call	putm
	ld	hl,crlf			;Print a trailing CRLF
	call	putm
	pop	af			;Restore reply value
	and	7fh			;Clear parity bit
	ret
gtflsh:	inc	hl			;Look for and of message (null)
	ld	a,(hl)
	or	a
	jp	nz,gtflsh
	dec	c			;Bump reply count
	jp	nz,gtscan		;Continue scan
	ld	a,(valid)		;Reinitialize reply count
	ld	c,a
	ld	hl,(string)		;Reinitialize string pointer
	jp	gtchk			;User guessed wrong, let us try again
gtspec:	ld	a,80h			;Special flag
	or	a			;Zap flags
	

dotcmd:	db	0a2h			;Execute controller routine command
	dw	1030h			;Format a track address
	db	0			;Execute command status
	db	25h			;Halt command
	db	0			;Status byte

atcmd:	db	0a2h
	dw	sdadvt			;Advance the track value address
	db	0
	db	25h
	db	0

sscmd:	db	022h			;Sense drive status
	db	0			;Drive #
	db	0			;Drive characteristic byte
	db	0			;Sector size byte
	db	0			;Status port byte
	db	0			;Completion status
	db	25h
	db	0

sacmd:	db	023h			;Set DMA address
	dw	buffer
	db	0

nstype:	db	90h
	db	0a0h
	db	0c0h
	db	0
	db	0f0h
	db	0d0h
	db	0e0h
tsize:	db	26*256/100h		;Number of pages per track
	db	15*512/100h
	db	8*1024/100h

sptabl:	db	27			;26 sectors per track (256 bytes)
	db	16			;15 sectors per track (512 bytes)
	db	9			;8 sectors per track (1024 bytes)
	page
qfmess:	dw	crlfs
	db	"DJDMA Format Program (Rev 3.3 - 30_Mar_83)", acr, alf
	db	"	Type ESC or DEL to restart selections", acr, alf
	db	"	The option listed first is the default", acr, alf
	dw	crlfs
	dbat drive 0"
	db	0
	db	"1", 81h
	db	"Preparing to format drive 1"
	db	0
	db	"2", 82h
	db	"Preparing to format drive 2"
	db	0
	db	"3", 83h
	db	"Preparing to format drive 3"
	db	0

dnmess:	db	"Select: D - double density", acr, alf
	db	"	S - single density", acr, alf
	db	"	"
	db	0
	db	2
	db	"d", "D", acr, 81h
	db	"    Double density selected."
	db	0
	db	"s", "S", 80h
	db	"    Single density selected."
	db	0

ntmess:	db	"Select the number of tracks ( 0=35, 1=40, 2=80 ): "
	db	0
	db	3
				;Check for control C
	jp	z,0			;    exit to CP/M
	cp	aesc			;Escape and delete get special coverage
	jp	z,gtspec
	cp	adel
	jp	z,gtspec
	ld	b,a			;Save user reply
gtscan:	inc	hl			;Bump to reply string
	ld	a,(hl)			;Load reply character
	or	a			;Test for end of reply string
	jp	m,gtflsh		;Not in this reply list, flush string
	cp	b			;Compare to user reply
	jp	nz,gtscan		;No match, continue scan
gtdone:	inc	hl			;Look for reply value
	ld	a,(hl)
	or	a
	jp	p,gtdone
	push	af			;Save value
	iret
	page
slcmd:	db	02eh			;Set/get logical drive settings
	db	0			;Logical to set
	db	0			;Logical drives returned
	db	25h
	db	0

lddcmd:	db	0a1h			;Write controller memory command
	dw	double			;Main memory address pointer
	db	0
	dw	single-double		;Byte count
	dw	1030h			;Controller memory address pointer
	db	25h			;Controller halt command
	db	0			;Halt command status byte

lsdcmd:	db	0a1h			;Write controller memory for single
	dw	single
	db	0
	dw	nsform-single
	dw	1030h
	db	25h
	db	0	db	25h
	db	0

rtcmd:	db	029h			;Read track command
	db	0			;Track #
	db	0			;Side #
	db	0			;Drive #
	dw	sectab			;Sactor table
	db	0
	db	0			;Status
	db	25h
	db	0

nscmlm:	db	0a1h			;Load controller memory
	dw	nsform
	db	0
	dw	ecode-nsform
	dw	1030h
	db	25h
	db	0

nscmex:	db	0a2h			;Execute controller memory
	dw	1030h
	db	0
	db	25h
	db	0

nscmat:	db	0a2h			;Advance track command (internal)
	dw	advtrk
	db	0
	db	25h
	db	0

nstrak:	db	35			;Track count table
	db	40
	db	80
	"Select: Carriage_Return - Exit to CP/M",acr,alf
	db	"	I - 8""    disk (IBM 3740 compatable)",acr,alf
	db	"	N - 5.25"" disk (CP/M-North_Star compatable)",acr,alf
	dw	crlfs
	db	"Select size of media (Carriage_Return, I, or N): "
	db	0
	db	3
	db	"i", "I", 80h
	db	"IBM 3740 format"
	db	0
	db	"n", "N", 81h
	db	"CP/M - North_Star format"
	db	0
	db	alf, acr, 82h
	db	"Returning to CP/M"
	db	0

drmess:	db	"Select a drive ( 0, 1, 2, or 3 ): "
	db	0
	db	4
	db	"0", acr, 80h
	db	"Preparing to formdb	"0", acr, 80h
	db	"35 track drive"
	db	0
	db	"1", 81h
	db	"40 track drive"
	db	0
	db	"2", 82h
	db	"80 track drive"
	db	0

slmess:	db	"Select the sector length ( 2=1024, 1=512, 0=256 ): "
	db	0
	db	3
	db	"0", 80h
	db	"256 byte sectors"
	db	0
	db	"1", 81h
	db	"512 byte sectors"
	db	0
	db	"2", acr, 82h
	db	"1024 byte sectors"
	db	0

nsmess:	db	"Select: C - CP/M compatibility or",acr, alf
	db	"	N - North star compatibility", acr, alf
	db	"	"
	db	0
	db	2
	db	"n", "N", 80h
	db	"   
*****************************************************************

	if	contyp eq 3

conout:	jmp	fdcout		;Console output

conin:	jmp	fdcin		;Console input

conist:	call	fdtstat		;Console status
	mvi	a,0ffh
	rz
	inr	a
	ret

	endif			;2DB

*****************************************************************
*								*
* CONTYP: 4	DJDMA console driver				*
*								*
*****************************************************************

	if	contyp eq 4
conout:	lxi	h,dmchan
	mvi	m,serout	;CommaP: 5	Switchboard as serial console				*
*									*
*************************************************************************

	if	contyp eq 5

swbase	equ	0			;Base of the SWITCHBOARD

conist:	in	swbase+2		;Get the first ports status
	ani	4			;Mask the data ready bits
	rz				;Return console not ready
	mvi	a,0ffh
ttyset:	ret				;NULL terminal initialization

conin:	in	swbase+2		;Get switchboard status
	ani	4			;Test for data ready
	jz	conin
	in	swbase			;Get a character
	ani	7fh			;Strip of
	ret

selcon:	lda	group		;Select console group
	ori	congrp
	out	grpsel
	ret

selrdr:	lda	group		;Select reader/punch group
	ori	5-lstgrp	;Use 'other' serial port
	out	grpsel
	ret

sellst:	lda	group		;Select printer group
	ori	lstgrp
	out	grpsel
	ret

	endif

*****************************************************************
*								*
* The following byte determines if an initial command is to be	*
* given to CP/M on warm or cold boots. The value of the byte is	*
* used to give the co	warmcm		;Pointer to the warm start command

*****************************************************************
*								*
* If there is a command inserted here, it will be passed to the	*
* CCP if the auto feature is enabled.  For Example:		*
*								*
*	coldcm:	db	coldend-coldcm				*
*		db	'MBASIC MYPROG'				*
*	coldend	equ	$					*
*								*
* will execute Microsoft BASIC, and MBASIC will execute the	*
* "MYPROG" BASIC program.  Note: The command line must be in	*
* upper case for most commanternal tables. At the start of	*
* each of these tables we have a revision byte and a length byte.  	*
* The revision byte is the current revision number for that		*
* particular structure and the length byte is the length of that	*
* structure.  This length does not include the revision byte nor	*
* the length byte itself.						*
*									*
*	Revision	Description					*
*	E.0		1 and 2 defined					*
*	E.3		This table is moved to a page boundry		*
*	E.3		0, 3 and 4 defined					*
*									*
* Thnd for serial output
	inx	h
	mov	m,c
	jmp	docmd

conin:	lxi	h,serin+1	;Serial input status
	xra	a
ci2:	cmp	m		;Wait till 40h deposited at 3fH
	jz	ci2
	mov	m,a		;Clear status
	dcx	h		;Point to input data
	mvi	a,7fh		;For masking out parity
	ana	m
	ret

conist:	lda	serin+1		;Pick up serial input status
	ora	a
	rz			;If zero then no character ready
	mvi	a,0ffh		;Set character ready
	ret
	endif

*************************************************************************
*									*
* CONTYf parity
	ret

conout:	in	swbase+2		;Check status
	ani	8			;Wait till output buffer empty
	jz	conout
	mov	a,c			;Write a character
	out	swbase
	ret

	endif

*************************************************************************
*									*
* Multio/Wunderbuss group select routines				*
*									*
*************************************************************************

	if (contyp eq 2) or (lsttyp ge 2)	;Need group select routines?

selg0:	lda	group		;Select group zero
	out	grpselmmand to CP/M:				*
*								*
* 0 = never give command.					*
* 1 = give command on cold boots only.				*
* 2 = give the command on warm boots only.			*
* 3 = give the command on warm and cold boots.			*
*								*
*****************************************************************

autost:	db	0		;Revision 0 structure
	db	100h - (low $)	;The rest of the page is used for this stuff

autoflg:db	0		;Auto command feature enable flag

coldmes:dw	coldcm		;Pointer to the cold start command
warmes:	dwnds.					*
*								*
*****************************************************************

coldcm:	db	coldend-coldcm		;Length of cold boot command
	db	''			;Cold boot command goes here
coldend	equ	$

warmcm:	db	warmend-warmcm		;Length of warm boot command
	db	''			;Warm boot command goes here
warmend	equ	$

*************************************************************************
*									*
* At the first page boundry following the CBIOS we have a series of	*
* pointers that point to various ie pointers defined so far are as follows:				*
*									*
* 0)	High byte is the page number of the CBIOS.  Low byte is		*
*	the CBIOS revision number.  Used to determine pointer		*
*	structure.							*
*									*
* 1)	This points to the drive configuration table.			*
*									*
* 2)	This points to the I/O configuration bytes for the serial	*
*       drivers.  Eg, the console, printer, reader, and punch		*
*       devices.							*
*									*
* 3)	This points to the drive parameter table for D	jp	nz,verspt
	ld	hl,rtcmd+2		;Side ok, check for other side
	ld	a,(hl)			;Get side flag
	ld	(hl),0			;Clear flag just in case ...
	or	a			;Test flag
	jp	nz,versid		;Verify other side
	dec	hl			;Bump to track count
	inc	(hl)			;Bump track number
	ld	a,(ntrack)		;Test for end of disk
	cp	(hl)
	jp	nz,vertrk		;Verify next track
	ld	hl,vdmess		;Verify done
	call	putm
	jp	start			;Restart
verfat:	ld	hl,retryh		;Bump hard retry count
	dec	(hl)
	jp	nz,versid
	ld	hl,vemess		;Verify error
	jp	errprlue in the
;	c register added to hl should produce a pointer to the
;	halt status.
;
lcmd:	ld	a,26h			;Branch channel command
	ld	(channl),a
	ld	(channl+1),hl		;Channel address
	xor	a
	ld	(channl+3),a		;Extended address
	ld	b,0
	add	hl,bc			;Offset to status byte
	ld	(hl),a			;Clear halt status
	out	(0efh),a		;Start controller
waitc:	or	(hl)			;Wait for halt complete
	jp	z,waitc
	dec	hl			;Back up to command status
	dec	hl
	ld	a,(hl)			;Load status
	cp	40h			;Comper to Ok status
	ret
;
ld number
	jp	nz,ptrkdn		;Skip if done
	inc	c			;Bump offset
	inc	de			;     current pointer
	inc	hl			;     old pointer
	dec	b			;     counter
	jp	nz,ptrkcp		;Compare next digit
	ret				;Numbers were the same
ptrkdn:	push	hl			;Save pointer to first dirty digit
ptrklp:	ld	(hl),a			;Copy dirty string over
	inc	de
	ld	a,(de)
	inc	hl
	dec	b
	jp	nz,ptrklp
	ld	hl,bsmess		;Back space
	add	hl,bc			;Offset neccesary amount
	call	putm
	pop	hl			;Retreive string pointer
	call	putm			;And print
	l
	inc	hl			;Bump to next position
	pop	af
	ret
;
;	Print a null terminated text to the terminal
;
putm:	ld	a,(hl)			;Get current byte of message
	or	a			;Test for end of message
	ret	z			;Return at end of message
	push	hl			;Save the character pointer
	call	putc			;Output the character
	pop	hl			;Recover the character pointer
	inc	hl			;Advance the character pointer
	jp	putm			;Go get the next character
;
;	Print a character to the terminal
;
putc:	push	af
	push	bc
	push	de
	push	hl
	ldter is returned.
;
;	The routine is called with a pointer to a string in hl and
;	returns a value in (a) and (zero).  The format for the string
;	follows:
;
;		db	"initial prompt string"
;		db	0			;Null terminator
;		db	2			;Number of 'reply values'
;		db	"a", "A", acr		;A list of characters to be
;						;  with the coresponding reply
;						;  'value.'
;		db	83h			;The reply value.  Parity must
;						;  be set.
;		db	"Reply echo string for a, A, or acr."
;		db	0			;Null terminator
;		db	"d
vererr:	ld	hl,retrys		;Bump hard retry count
	dec	(hl)
	jp	nz,versid
	ld	hl,vsmess		;Verify error
errpr:	call	putm			;Tell user about it
	jp	start			;    and quit
;
;	Execute controller command.
;	hl -> Start of command sequence
;	c  -> Offset pointer to status byte of sequence
;	a  <- Status return (z flag set if = 40h)
;
;	The command sequence must end with a halt.  If any status
;	is returned from the regular part of the command then this
;	status must immediatly precede the halt.  The va;	Print a track #, do fancy backspacing, ect.
;
ptrack:	ld	(ptrk),hl		;Save ASCII pointer
	ld	a,(ctrack)		;Load current track
	push	af
	ld	hl,(ptrk)		;Place to deposite track #
	call	decim3			;Figure track #
	pop	af
	inc	a			;Bump to next track
	ld	(ctrack),a
	ld	bc,300h			;b = fore count, b = back count
	ld	hl,(ptrk)		;Pointer to current track #
	ld	de,otrack		;Pointer to old track #
	ex	de,hl			;Set pointers the way we want them
ptrkcp:	ld	a,(de)			;Get a digit
	cp	(hl)			;Compare against od	c,6
	ld	e,0ffh
	call	5
	ret
;
;	Put 'a' in (hl) in ASCII decimal form with leading spaces
;
decim3:	ld	c,"0"			;Initialize 'leader' flag
	ld	d,100			;Hundreds
	call	decfig
	ld	d,10			;Tens
	call	decfig
decim1:	ld	c,0			;Force leading 0
	ld	d,1			;Ones
	jp	decfig

decfig:	ld	e,"0"-1
declop:	inc	e
	sub	d
	jp	nc,declop
	add	a,d
	push	af
	ld	a,e
	cp	c			;Handle leading space (sometimes)
	jp	nz,decok
	ld	e," "			;Load space
	jp	decokk
decok:	ld	c," "
decokk:	ld	(hl),e			;Save digit	e,a
	ld	c,wcon
	call	bdos
	pop	hl
	pop	de
	pop	bc
	pop	af
	ret
;
;	Call getc.  Parse ESC and DEL codes.  If these codes
;	were typed then return to start.
;
getcc:	call	getc			;Get code
	jp	m,start			;Restart if ESC or DEL
	ret				;Return regular status
;
;	This routine prints a prompt and then accepts an input character.
;	This input character is compared to a 'reply list'.  If the
;	character is found then an associated 'reply string' is echoed
;	and a value associated with that charac", "D"		;A list of characters to be
;						;  with the coresponding reply
;						;  'value.'
;		db	85h			;The reply value.  Parity must
;						;  be set.
;		db	"Reply echo string for d or D."
;		db	0			;Null terminator
;
;	This structure will return a 3 if an 'a', 'A', or acr is typed
;	and a 5 if a 'd' or 'D' is typed.  The routine prints a CRLF
;	before the initial prompt string and a CRLF after the reply
;	string.  If an ESC or DEL is typed then a code of 80h will be
;	returned and the minus JDMA floppy	*
*       disk drives.  If no DJDMA is present then this pointer is	*
*       null (0).							*
*									*
* 4)	This points to the autostart command structures.  Used to	*
*	automatically invoke a command on cold or warm boot		*
*									*
* 5)	This will be a null (0) pointer.  It marks the end of the	*
*       table.								*
*									*
*************************************************************************

	if	$ gt bios+256	;Test for code overlap
	'Fatal error, pointer table		*
* The following code performs the mapping of logical to physical	*
* serial I/O devices.  The physical entry points are CONIN, CONOUT,	*
* CONIST, RDRIN, PUNOUT, LSTOUT, and LSTOST.  These entry points	*
* are mapped via the Intel standard I/O byte (IOBYTE) at location 3	*
* in the base page to the low level device drivers.			*
*									*
* Note:  A naming convention has been chosen to reduce label		*
* colisions.  The first three characters of a name indicate the		*
* device drivers name, theacter to the device			*
* devIST	Return the device character input ready status		*
* devOST	Return the device character output ready status		*
*									*
* The setup routine initializes the device and returns.  The input	*
* routine returns one character in the A register (parity reset).	*
* The output routine write one character from the C register.  The	*
* input status routine returns in the A register a 0 if the device	*
* does not have a character ready for input for 0ffh if a character	*
* i								*
*	device	setup	input	output	input	output			*
*	name				status	status			*
*									*
*	CON:		CONIN	CONOUT	CONIST				*
*	RDR:		RDRIN		RDRIST				*
*	PUN:			PUNOUT					*
*	LST:			LSTOUT		LSTOST			*
*									*
*	TTY:	TTYSET	TTYIN	TTYOUT	TTYIST	TTYOST			*
*	CRT:	CRTSET	CRTIN	CRTOUT	CRTIST	CRTOST			*
*	UC1:	UC1SET	UC1IN	UC1OUT	UC1IST				*
*									*
*	PTR:	PTRSET	PTRIN		PTRIST				*
*	UR1:	UR1SET	UR1IN		UR1IST				*
*	UR2:	UR2SET	UR2IN		UR2IST				*
*									*
*	PTP:	PTPSET		PTPOUT							;I/O byte implemented for North Star
					;   drivers.  Other drivers to follow

conin:	mvi	e,1			;Console input
	call	redir			;	IOBYTE:	76543210
	dw	ttyin			;CON: = TTY:	xxxxxx00
	dw	crtin			;CON: = CRT:	xxxxxx01
	dw	rdrin			;CON: = BAT:	xxxxxx10
	dw	uc1in			;CON: = UC1:	xxxxxx11

conout:	mvi	e,1			;Console output
	call	redir			;	IOBYTE:	76543210
	dw	ttyout			;CON: = TTY:	xxxxxx00
	dw	crtout			;CON: = CRT:	xxxxxx01
	dw	lstout			;CON: = BAT:	xxxxxx10
	dw	uc1out			;CON: = UC1:	xxxxxx11

co placement.'
	else
	ds	bios+256-$	;Start at a page boundry
	endif

	db	high ($-1)	;CBIOS page number
	db	revnum		;Cbios revision number
	dw	drconf		;Drive configuration table pointer
	dw	ioconf		;I/O configuration table pointer
	if	(maxdm ne 0) or (maxmf ne 0)	;DJDMA present?
	dw	dmarap		;Drive parameter table pointer
	else
	dw	0
	endif
	dw	autost		;Auto command structure pointer
	dw	0		;End of table marker

*************************************************************************
*							 following three characters indicated the	*
* function performed by that particular device routine.  The device	*
* names are defined and described in the "An Introduction to CP/M	*
* Features and Facilities" manual in the section on the STAT		*
* command and in the "CP/M Interface Guide" in the IOBYTE section.	*
* The device function postfixes are as follows.				*
*									*
* devSET	Initial device setup and initialzation			*
* devIN	Read one character from the device				*
* devOUT	Write one chars ready for input.  The output status routine returns in the A	*
* register a 0 if the device is not ready accept a character and a	*
* 0ffh if the device is ready.  The input and output routines		*
* should wait untill the device is ready for the desired operation	*
* before the doing the operation and returning.				*
*									*
* Not all of these functions need to be implemented for all the		*
* devices.  The following is a table of the entry points needed for	*
* each device handler.							*
*	*
*	UP1:	UP1SET		UP1OUT					*
*	UP2:	UP2SET		UP2OUT					*
*									*
*	LPT:	LPTSET		LPTOUT		LPTOST			*
*	UL1:	UL1SET		UL1OUT		UL1OST			*
*									*
* The CONIN, CONOUT, CONIST, RDRIN, RDRIST, PUNOUT, LSTOUT, and		*
* LSTOST routines are the logical device driver entry points		*
* provided by this device mapper.  The other entry names must be	*
* provided by the physical device drivers.				*
*									*
*************************************************************************

	if	contyp eq 6nist:	mvi	e,1			;Console input status
	call	redir			;	IOBYTE:	76543210
	dw	ttyist			;CON: = TTY:	xxxxxx00
	dw	crtist			;CON: = CRT:	xxxxxx01
	dw	rdrist			;CON: = BAT:	xxxxxx10
	dw	uc1ist			;CON: = UC1:	xxxxxx11

rdrin:	mvi	e,7			;Reader input
	call	redir			;	IOBYTE:	76543210
	dw	ttyin			;RDR: = TTY:	xxxx00xx
	dw	ptrin			;RDR: = PTR:	xxxx01xx
	dw	ur1in			;RDR: = UR1:	xxxx10xx
	dw	ur2in			;RDR: = UR2:	xxxx11xx

rdrist:	mvi	e,7			;Reader input status
	call	redir			;	IOBYTE:	76543210
	dw	ttyist	ip if write protected
	ld	a,b			;Restore full status port value
	and	4			;Mask in 'sides' bit
	rrca				;Shift to bit 0
	rrca
	ld	(ddsbit-ddfmt+double),a	;Store in format code double density
	ld	(sdsbit-sdfmt+single),a	;Store in format code single density
	rrca				;Zap around to bit 7
	ld	(nside),a		;And save side flag
	ld	hl,ftmess		;Formatting ... message
	call	putm
	ld	a,1			;Load track counter
	ld	(ctrack),a
	ld	hl,lsdcmd		;Load single density code command
	ld	c,9			;Offset to halt status
n address of format
	ld	a,(densty)
	or	a			;Test for double density
	jp	z,contue		;Make no adjustments for single density
	ld	hl,lddcmd		;Load double density format command
	ld	c,9			;Offset to halt status
	call	lcmd			;Load the code into controller
	ld	hl,ddadvt		;Advance track execute address
	ld	(atcmd+1),hl		;Update the command execute address
	ld	hl,1030h		;Format execute address
contue:	ld	(dotcmd+1),hl		;Update track format execute address
	ld	hl,atcmd		;Advance track command
	ld	c,5			;Oready
	call	putm
	jp	start			;Stop the formatting
	page
;
;	The following routine set up and execute the North Star formatter
;
nstart:	ld	hl,1030h
	ld	(nscmex+1),hl
	ld	a,20h
	ld	(data-nsfmt+nsform),a
	ld	(cpdata-nsfmt+nsform),a
	ld	(verval),a
	xor	a
	ld	(track-nsfmt+nsform),a
	ld	a,10			;Load number of sectors per track
	ld	(nspt),a
	ld	hl,10*512		;Load number of bytes per track
	ld	(trksiz),hl
	ld	hl,slcmd+1		;Set 5 1/4 inch drive as 0-3
	ld	(hl),4
	dec	hl
	ld	c,4
	call	lcmd
	ld	hld	(dflag-nsfmt+nsform),a
	rrca
	ld	(nside),a		;Set up side flag
	rlca
	jp	z,nsdatc
	rlca
	rlca
	add	a,e
	ld	e,a
nsdatc:	push	de
	ld	hl,nsmess		;Ask about North Star vs CP/M format
	call	getcc
	pop	de
	jp	z,nsload
	ld	a,e
	and	80h
	ld	a,10h
	jp	z,nstord
	ld	hl,nstype-80h
	add	hl,de
	ld	a,(hl)
nstord:	ld	(cpdata-nsfmt+nsform),a
	ld	a,0e5h
	ld	(data-nsfmt+nsform),a
	ld	(verval),a
nsload:	ld	a,(drive)		;Get drive #
	add	a,"0"			;Make ASCII decimal
	ld	(wdriv5),a		;Save in wait messagb,a
	ld	a,(strack-nsfmt+nsform)
	cp	b
	jp	z,verify		;Go verify disk
	ld	hl,nscmex
	ld	c,5
	call	lcmd
	jp	z,nscont
	ld	hl,femess		;Drive not ready
	call	putm
	jp	start
	page
;
;	Verify the disk
;
verify:	ld	hl,vtmess		;Send verifying ... message
	call	putm
	ld	hl,sacmd		;Set the DMA address
	ld	c,5			;Halt status offset
	call	lcmd
	xor	a			;Initialize track counters
	ld	(ctrack),a
	ld	(rtcmd+1),a
	ld	a,(drive)		;Initialize the drive number
	ld	(rtcmd+3),a
vertrk:	ld	hl,vtrack		;Print	call	lcmd			;Load the code
	ld	hl,dotcmd		;Format track 0 command
	ld	c,5			;Offset to status
	call	lcmd			;Execute the command
	jp	z,proced		;Zero => no error
	ld	hl,nrmess		;Drive not ready message
	cp	82h			;Drive not ready error code
	jp	z,nready		;Test for drive not ready
	ld	hl,wpmess		;Well...  the write tab fell off...
nready:	call	getcc			;Send the message
	jp	z,start			;Zero => start the program over
	jp	retryf			;Go back and do the command over
proced:	ld	hl,sdrdy		;Adjusted executioffset to status
	call	lcmd			;Load the command and execute
	cp	77			;Last track value (77 decimal)
	jp	nz,fmtrck		;Zero => formatting done
	ld	a,77			;77 tracks on an 8 inch drive
	ld	(ntrack),a
	jp	verify			;Verify disk
fmtrck:	ld	hl,ftrack		;Pointer to track #
	call	ptrack			;Print and update track number
	ld	hl,dotcmd		;Format a track command
	ld	c,5			;Offset to status
	call	lcmd			;Load and execute the command
	jp	z,contue+3		;Loop back for more tracks
	ld	hl,femess		;Drive has become not l,drmess		;Get drive number
	call	getcc
	ld	(nsform+1),a
	ld	(drive),a
	ld	hl,ntmess		;Get number of tracks
	call	getcc
	ld	d,0
	ld	e,a
	ld	hl,nstrak
	add	hl,de
	ld	a,(hl)
	ld	(strack-nsfmt+nsform),a
	ld	(ntrack),a
	push	de
	ld	hl,dnmess		;Get density
	call	getcc
	pop	de
	ld	b,051h
	jp	z,nstore
	push	af
	rrca
	add	a,e
	ld	e,a
	pop	af
	ld	b,0d1h
nstore:	ld	(den1-nsfmt+nsform),a
	ld	a,b
	ld	(den2-nsfmt+nsform),a
	push	de
	ld	hl,simess		;Get number of sides
	call	getcc
	pop	de
	e
	ld	hl,wdmes5		;Wait for a disk
	call	putm
	ld	hl,wdmess
	call	getcc
nsrtry:	ld	hl,nscmlm
	ld	c,9
	call	lcmd
	ld	hl,nscmex
	ld	c,5
	call	lcmd
	jp	z,nsproc
	ld	hl,nrmess
	cp	82h
	jp	z,$+6
	ld	hl,wpmess		;Tell about fault
	call	getcc
	jp	z,start
	jp	nsrtry
nsproc:	ld	hl,ftmess		;Formatting ... message
	call	putm
	xor	a			;Initialize track counter
	ld	(ctrack),a
	ld	hl,entry
	ld	(nscmex+1),hl
nscont:	ld	hl,ftrack		;Print track #
	call	ptrack
	ld	hl,nscmat
	ld	c,5
	call	lcmd
	ld	 track #
	call	ptrack
	ld	a,(nside)
	ld	(rtcmd+2),a		;Load sides flag
	ld	a,retries		;Initialize retry counters
	ld	(retrys),a		;Soft error counter
	ld	(retryh),a		;Hard error counter
versid:	ld	hl,rtcmd		;Verify a side
	ld	c,9			;Status offset
	call	lcmd			;Read a track
	jp	nz,verfat		;Fatal drive error
	ld	hl,sectab		;Lets check out sectors
	ld	a,(nspt)		;Load number of sectors to check
	ld	c,a
	ld	a,40h			;'Ok' code
verspt:	cp	(hl)
	jp	nz,vererr		;Sector does not verify
	inc	hl
	dec	c
		;RDR: = TTY:	xxxx00xx
	dw	ptrist			;RDR: = PTR:	xxxx01xx
	dw	ur1ist			;RDR: = UR1:	xxxx10xx
	dw	ur2ist			;RDR: = UR2:	xxxx11xx

punout:	mvi	e,5			;Punch output
	call	redir			;	IOBYTE:	76543210
	dw	ttyout			;PUN: = TTY:	xx00xxxx
	dw	ptpout			;PUN: = PTP:	xx01xxxx
	dw	up1out			;PUN: = UP1:	xx10xxxx
	dw	up2out			;PUN: = UP2:	xx11xxxx

lstout:	mvi	e,3			;List output
	call	redir			;	IOBYTE:	76543210
	dw	ttyout			;LST: = TTY:	00xxxxxx
	dw	crtout			;LST: = CRT:	01xxxxxx
	dw	lptout			;LST: = LPT:			;Get the table base
	dad	d			;Offset into our table
	mov	a,m			;Load the low level i/o routine pointer
	inx	h
	mov	h,m
	mov	l,a
	pchl				;Execute the low level i/o driver

	endif				;IOBYTE redirector

*************************************************************************
*									*
* CONTYP: 1	Blank space for console driver				*
*									*
* The driver entries CONOUT, CONIN, CONIST are defined in the CP/M	*
* alternation guide.  Eg.  Input parameters are in register C and	*
* results
conin	equ	$			;Console input
conist	equ	$			;Console input status
	jmp	$
	ds	125
	endif				;User IO

*************************************************************************
*									*
* CONYTP: 6	North Star						*
*									*
* The following code implements the North Star console I/O system.	*
* This system is for users who purchase a Morrow Designs disk		*
* system to replace their North Star disk system.  The Mapping of	*
* the logical to physical entry points is performed as follows:		*parallel port.				*
*									*
*************************************************************************

	if	contyp eq 6		;Use North Star I/O?

nsldat	equ	2			;Left serial port data port
nslsta	equ	3			;Left serial port status port

nsrdat	equ	4			;Right serial port data port
nsrsta	equ	5			;Right serial port status port

nsstbe	equ	1			;Transmitter buffer empty status bit
nssrbr	equ	2			;Reciever buffer ready status bit

					;See the 8251 data sheets for more
					;   configuration infor
					;xx0xxxxx Odd parity generation/check
					;xx1xxxxx Even parity generation/check
					;00xxxxxx Invalid
					;01xxxxxx 1 stop bit
					;10xxxxxx 1.5 stop bits
					;11xxxxxx 2 stop bits

nslin2	equ	37h			;Left serial port initialization # 2
nsrin2	equ	37h			;Right serial port initialization # 2
					;76543210 Bit definations
					;00110111 Default configuration
					;xxxxxxx1 Enable transmitter
					;xxxxxx1x Assert DTR*
					;xxxxx1xx Enable reciever
					;xxxx1xxx Send break character10xxxxxx
	dw	ul1out			;LST: = UL1:	11xxxxxx

lstost:	mvi	e,3			;List output status
	call	redir			;	IOBYTE:	76543210
	dw	ttyost			;LST: = TTY:	00xxxxxx
	dw	crtost			;LST: = CRT:	01xxxxxx
	dw	lptost			;LST: = LPT:	10xxxxxx
	dw	ul1ost			;LST: = UL1:	11xxxxxx

redir:	lda	iobyte			;Get the INTEL standard iobyte
redir0:	rlc				;Shift the next field in
	dcr	e			;Bump the shift count
	jnz	redir0

redir1:	ani	110b			;Mask the redirection field
	mov	e,a			;Make the word table offset
	mvi	d,0
	pop	h	 are returned in register A.  The TTYSET routine is used	*
* for initialization code.  It should execute a RET when complete.	*
*									*
* The TTYSET routine could be placed just below the CBOOT routine.	*
* This space (below CBOOT) is recyled for use as a disk buffer		*
* after CBOOT is done.							*
*									*
*************************************************************************

	if	contyp eq 1		;User defined IO area
ttyset	equ	$			;Console initialization
conout	equ	$			;Console output
*									*
* Device name		Left	Right	Parallel			*
*			serial	serial	port				*
*									*
* Console	CON: =	TTY:	CRT:	UC1:				*
* Reader	RDR: =	TTY:	PTR:	UR1:				*
* Punch		PUN: =	TTY:	PTP:	UP1:				*
* List		LST: =	TTY:	CRT:	UL1:				*
*									*
* For example, to use a printer connected to the right serial port,	*
* use the CP/M command:							*
*									*
*	STAT LST:=CRT:							*
*									*
* Likewise, the CP/M command "STAT LST:=UL1:" is used if you have a	*
* printer connected to the mation.

nslin1	equ	0ceh			;Left serial port initialization # 1
nsrin1	equ	0ceh			;Right serial port initialization # 1
					;76543210 Bit definations
					;11001110 Default configuration
					;xxxxxx00 Synchronous mode
					;xxxxxx01 1X clock rate
					;xxxxxx10 16X clock rate
					;xxxxxx11 64X clock rate
					;xxxx00xx 5 bit characters
					;xxxx01xx 6 bit characters
					;xxxx10xx 7 bit characters
					;xxxx11xx 8 bit characters
					;xxx0xxxx Parity disbable
					;xxx1xxxx Parity enable, TxD low
					;xxx1xxxx Reset PE, OE, FE error flags
					;xx1xxxxx Assert RTS*
					;x1xxxxxx Internal reset
					;1xxxxxxx Enter hunt mode (for sync)

nspdat	equ	0			;Parallel data port
nspsta	equ	6			;Parallel status port

nsprbr	equ	1			;Reciever buffer ready status bit
nsptbe	equ	2			;Transmitter buffer empty status bit

nsram	equ	0c0h			;North Star memory parity port,
					;   set to 0 for no North Star RAM

*************************************************************************
*		
;	STACK AREA
	DS	64	;RESERVE 32 LEVEL STACK
STKTOP:
;
	END
OPENF
	CALL	BDOS
;	255 IN ACCUM IF OPEN ERROR
	RET
;
DISKR:	;READ DISK FILE RECORD
	PUSH H! PUSH D! PUSH B
	LXI	D,FCB
	MVI	C,READF
	CALL	BDOS
	POP B! POP D! POP H
	RET
;
;	FIXED MESSAGE AREA
SIGNON:	DB	'FILE DUMP VERSION 1.4$'
OPNMSG:	DB	CR,LF,'NO INPUT FILE PRESENT ON DISK$'

;	VARIABLE AREA
IBP:	DS	2	;INPUT BUFFER POINTER
OLDSP:	DS	2	;ENTRY SP VALUE FROM CCP
;ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее	title	djdma/format.mac (rev 3.3 - 30_Mar_83)

	.z80

channl	equ	50h		;Start channel address
index	equ	10h		;Delta index status bit
wproct	equ	40h		;Write protected status bit
dready	equ	80h		;Drive ready status bit
home	equ	0a0h		;Internal Table home-disk routine address
seek	equ	0a3h		;	  	seek-track
sdrive	equ	0a6h		;	  	set-drive
hsync	equ	0a9h		;	  	header-sync
diskd	equ	4001h		;Disk data port
status	equ	4003h		;Status port
contrl	equ	4007h		;Control port

crlfs	equ	0d0ah		;Carraige ret	call	getc
	jp	z,ibmst			;Formatting IBM
	cp	1
	jp	z,nstart		;Formatting North Star
	jp	0			;Return to CP/M
ibmst:	ld	hl,1030h		;Initalize command addresss
	ld	(dotcmd+1),hl
	ld	hl,sdadvt
	ld	(atcmd+1),hl
	ld	hl,slcmd+1		;Set 8 inch drive as 0-3
	ld	(hl),0	
	dec	hl
	ld	c,4
	call	lcmd
	ld	hl,drmess		;Get drive number
	call	getcc
	ld	(single+1),a		;Store the drive number in code
	ld	(drive),a		;   and save in a safe place
	ld	a,26			;26 Sectors per track for single
	ld	(nspt),a
	ld	hl,26*1	(dlcode-ddfmt+double),a	;Store in format code
	ld	hl,sptabl
	add	hl,de
	ld	a,(hl)			;Fetch number of sectors
	ld	(dlast-ddfmt+double),a	;Store in format code
	dec	a
	ld	(nspt),a		;   and in the verify section
	ld	a,20h			;Sector length code is 80,100, or 0
dcnst:	add	a,a
	dec	e			;Decrement the sector type
	jp	p,dcnst			;Test for cycle done
	ld	(dsize-ddfmt+double),a	;Store 1/4 length in format code
side:	ld	a,(drive)		;Get drive #
	add	a,"0"			;Make ASCII decimal
	ld	(wdriv8),a		;Save in waiееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееurn / line feed sequence
acr	equ	0dh		;A carraige return character
alf	equ	0ah		;A line feed character
aesc	equ	1bh		;An escape character
adel	equ	7fh		;A delete character
retries	equ	3		;Disk retries before giving up on verify

bdos	equ	5		;Bdos entry address
wcon	equ	2		;Write console function
direct	equ	6		;Direct console I/O
	page	63
start:	ld	sp,ecode+30h		;Initialize the stack pointer
	ld	hl,"0 "			;Initialize track number to 0
	ld	(ftrack+1),hl
	ld	hl,qfmess		;Ask about type of format
28		;Load number of bytes per track
	ld	(trksiz),hl
	ld	a,0e5h			;We format with e5's
	ld	(verval),a
	ld	hl,dnmess		;Get density
	call	getcc
	ld	(densty),a		;Save for later use
	jp	z,side			;Skip sector size if single density
	ld	hl,slmess		;Select sector length message
	call	getcc
	ld	d,0			;Form offset into sector table
	ld	e,a
	ld	hl,tsize		;Get track size
	add	hl,de
	ld	h,(hl)			;Get high byte of size
	ld	l,0
	ld	(trksiz),hl		;Save track size
	inc	a			;Adjust for sector length code
	ldt message
	ld	hl,wdmes8		;Wait for a disk
	call	putm
	ld	hl,wdmess
	call	getcc
retryf:	ld	hl,sscmd+1		;Test various drive parameters
	ld	a,(drive)		;Load drive # to sense
	ld	(hl),a
	dec	hl
	ld	c,7			;Offset to status
	call	lcmd
	ld	hl,nrmess		;Not ready message
	cp	82h			;Test for not ready
	jp	z,nready		;Skip if not ready
	ld	a,(sscmd+4)		;fetch status port value
	ld	b,a			;Save for a while
	ld	hl,wpmess		;Write protected message
	and	40h			;Mask in write protected bit
	jp	nz,nready		;Sk							*
* Left serial port routines.  Use TTY: device.				*
*									*
*************************************************************************

ttyin:					;Read a character
	in	nslsta
	ani	nssrbr
	jz	ttyin			;Wait till a character is ready
	in	nsldat			;Get the character
	ani	7fh			;Strip parity
	ret

ttyout:					;Write a character
	in	nslsta
	ani	nsstbe
	jz	ttyout			;Wait till the buffer is empty
	mov	a,c			;Write the character
	out	nsldat
	ret

ttyist:					;Return input buffer star
ptrin:
	in	nsrsta
	ani	nssrbr
	jz	crtin			;Wait till a character is ready
	in	nsrdat			;Get the character
	ani	7fh			;Strip parity
	ret

crtout:					;Write a character
ptpout:
	in	nsrsta
	ani	nsstbe
	jz	crtout			;Wait till the buffer is empty
	mov	a,c			;Write the character
	out	nsrdat
	ret

crtist:					;Return input buffer status
ptrist:
	in	nsrsta
	ani	nssrbr
	rz				;Return not ready
	mvi	a,0ffh
	ret				;There is a character ready

crtost:					;Return output buffer status
	in	push	psw
	mvi	a,30h			;Reset the parallel input flag
	out	nspsta
	pop	psw
	ani	7fh			;Strip parity
	ret

uc1out:					;Write a character
up1out:
up2out:
lptout:
ul1out:
	in	nspsta
	ani	nsptbe
	jz	uc1out			;Wait till the buffer is empty
	mvi	a,20h			;Reset the parallel output flag
	out	nspsta
	mov	a,c			;Write the character, strobe bit 7
nspout:	ori	80h
	out	nspdat
	ani	7fh
	out	nspdat
	ori	80H
	out	nspdat
	ret

uc1ist:					;Return input buffer status
ur1ist:
ur2ist:
	in	nspsta
						*
* LSTTYP is:	0	Nothing, used for patching to PROM's		*
*		1	Provide for 128 bytes of patch space		*
*		2	Multio serial, no protocol			*
*		3	Multio serial, Clear To Send protocol		*
*		4	Multio serial, Data Set Ready protocol		*
*		5	Multio serial, Xon/Xoff protocol		*
*									*
*************************************************************************

*************************************************************************
*									*
* lsttyp: 1	Blank space for printer driver				*
********************************************

	if	lsttyp eq 1
lstset	equ	$			;Printer initialization
lstout	equ	$			;Printer output
lstost	equ	$			;Printer output status
	jmp	$
	ds	125
	endif				;User IO

*****************************************************************
*								*
* lsttyp: 2, 3, 4, or 5 Serial printer, multi protocol		*
*								*
*****************************************************************

	if	(lsttyp ge 2) and (lsttyp le 5)

lstout:	call	lstost		;Check printer stattus
	in	nslsta
	ani	nssrbr
	rz				;Return not ready
	mvi	a,0ffh
	ret				;There is a character ready

ttyost:					;Return output buffer status
	in	nslsta
	ani	nsstbe
	rz				;Return not ready
	mvi	a,0ffh
	ret				;Return ready

*************************************************************************
*									*
* Right serial port routines.  Use CRT:, PTR:, and PTP: devices.	*
*									*
*************************************************************************

crtin:					;Read a charactensrsta
	ani	nsstbe
	rz				;Return not ready
	mvi	a,0ffh
	ret				;Return ready

*************************************************************************
*									*
* Parallel port routines.  Use UC1:, UR1:, UR2:, UP1:, UP2:, LPT:,	*
* and UL1: devices.							*
*									*
*************************************************************************

uc1in:					;Read a character
ur1in:
ur2in:
	in	nspsta
	ani	nsprbr
	jz	uc1in			;Wait till a character is ready
	in	nspdat			;Get the character
	ani	nsprbr
	rz				;Return not ready
	mvi	a,0ffh
	ret				;Return ready

lptost:					;Return output buffer status
ul1ost:
	in	nspsta
	ani	nsptbe
	rz				;Return not ready
	mvi	a,0ffh
	ret				;Return ready

	endif				;North Star I/O configuration

*************************************************************************
*									*
* LST: device driver routines.						*
*									*
* Routine used depends on the value of lsttyp.  Possible LSTTYP		*
* values are listed as follows:						*
*													*
* The driver entries LSTOUT and LSTOST are defined in the CP/M		*
* alternation guide.  Eg.  Input parameters are in register C and	*
* results are returned in register A.  The LSTSET routine is used	*
* for initialization code.  It should execute a RET when complete.	*
*									*
* The LSTSET routine could be placed just below the CBOOT routine.	*
* This space (below CBOOT) is recyled for use as a disk buffer		*
* after CBOOT is done.							*
*									*
******************************us
	ora	a
	jz	lstout		;Loop if not ready

	mov	a,c		;Print the character
	out	thr
	ret

lstost:	call	sellst		;Printer status routine

	in	lsr		;Check if transmitter buffer empty
	ani	thre
	rz			;Return busy if buffer is not empty

	lhld	lstand		;Fetch handshake mask bits

	in	msr		;Get MODEM Status Register
	ana	l		;Strip out hand-shake lines
	xra	h		;Invert status
	rz			;Return busy if printer is busy

	lda	lastch		;Get last character recieved from the printer
	mov	b,a
	in	lsr		;Chec
sekdsk:	ds	1		;seek disk number
sektrk:	ds	2		;seek track number
seksec:	ds	1		;seek sector number
;
hstdsk:	ds	1		;host disk number
hsttrk:	ds	2		;host track number
hstsec:	ds	1		;host sector number
;
sekhst:	ds	1		;seek shr secshf
hstact:	ds	1		;host active flag
hstwrt:	ds	1		;host written flag
;
unacnt:	ds	1		;unalloc rec cnt
unadsk:	ds	1		;last unalloc disk
unatrk:	ds	2		;last unalloc track
unasec:	ds	1		;last unalloc sector
;
erflag:	ds	1		;error reporting
rsflag:	ds	1		;read sector;	FILE DUMP PROGRAM, READS AN INPUT FILE AND PRINTS IN HEX
;
;	COPYRIGHT (C) 1975, 1976, 1977, 1978
;	DIGITAL RESEARCH
;	BOX 579, PACIFIC GROVE
;	CALIFORNIA, 93950
;
	ORG	100H
BDOS	EQU	0005H	;DOS ENTRY POINT
CONS	EQU	1	;READ CONSOLE
TYPEF	EQU	2	;TYPE FUNCTION
PRINTF	EQU	9	;BUFFER PRINT ENTRY
BRKF	EQU	11	;BREAK KEY FUNCTION (TRUE IF CHAR READY)
OPENF	EQU	15	;FILE OPEN
READF	EQU	20	;READ FUNCTION
;
FCB	EQU	5CH	;FILE CONTROL BLOCK ADDRESS
BUFF	EQU	80H	;INPUT DISK BUFFER ADDRESS
;
;	NON GRAPHEA (RESTORED AT FINIS)
	LXI	SP,STKTOP
;	READ AND PRINT SUCCESSIVE BUFFERS
	CALL	SETUP	;SET UP INPUT FILE
	CPI	255	;255 IF FILE NOT PRESENT
	JNZ	OPENOK	;SKIP IF OPEN IS OK
;
;	FILE NOT THERE, GIVE ERROR MESSAGE AND RETURN
	LXI	D,OPNMSG
	CALL	ERR
	JMP	FINIS	;TO RETURN
;
OPENOK:	;OPEN OPERATION OK, SET BUFFER INDEX TO END
	MVI	A,80H
	STA	IBP	;SET BUFFER POINTER TO 80H
;	HL CONTAINS NEXT ADDRESS TO PRINT
	LXI	H,0	;START WITH 0000
;
GLOOP:
	PUSH	H	;SAVE LINE POSITION
	CALL	GNB
	POP	H	;RECALLTHAT A JMP TO 0000H REBOOTS)
	CALL	CRLF
	LHLD	OLDSP
	SPHL
;	STACK POINTER CONTAINS CCP'S STACK LOCATION
	RET		;TO THE CCP
;
;
;	SUBROUTINES
;
BREAK:	;CHECK BREAK KEY (ACTUALLY ANY KEY WILL DO)
	PUSH H! PUSH D! PUSH B; ENVIRONMENT SAVED
	MVI	C,BRKF
	CALL	BDOS
	POP B! POP D! POP H; ENVIRONMENT RESTORED
	RET
;
PCHAR:	;PRINT A CHARACTER
	PUSH H! PUSH D! PUSH B; SAVED
	MVI	C,TYPEF
	MOV	E,A
	CALL	BDOS
	POP B! POP D! POP H; RESTORED
	RET
;
CRLF:
	MVI	A,CR
	CALL	PCHAR
	MVI	A,LF
	CALL	PC
;	READ ANOTHER BUFFER
;
;
	CALL	DISKR
	ORA	A	;ZERO VALUE IF READ OK
	JZ	G0	;FOR ANOTHER BYTE
;	END OF DATA, RETURN WITH CARRY SET FOR EOF
	STC
	RET
;
G0:	;READ THE BYTE AT BUFF+REG A
	MOV	E,A	;LS BYTE OF BUFFER INDEX
	MVI	D,0	;DOUBLE PRECISION INDEX TO DE
	INR	A	;INDEX=INDEX+1
	STA	IBP	;BACK TO MEMORY
;	POINTER IS INCREMENTED
;	SAVE THE CURRENT FILE ADDRESS
	LXI	H,BUFF
	DAD	D
;	ABSOLUTE CHARACTER ADDRESS IS IN HL
	MOV	A,M
;	BYTE IS IN THE ACCUMULATOR
	ORA	A	;RESET CARRY BIT
	RET
;
 flag
readop:	ds	1		;1 if read operation
wrtype:	ds	1		;write operation type
dmaadr:	ds	2		;last dma address
hstbuf:	ds	hstsiz		;host buffer
;
;*****************************************************
;*                                                   *
;*	The ENDEF macro invocation goes here	     *
;*                                                   *
;*****************************************************
	end
IC CHARACTERS
CR	EQU	0DH	;CARRIAGE RETURN
LF	EQU	0AH	;LINE FEED
;
;	FILE CONTROL BLOCK DEFINITIONS
FCBDN	EQU	FCB+0	;DISK NAME
FCBFN	EQU	FCB+1	;FILE NAME
FCBFT	EQU	FCB+9	;DISK FILE TYPE (3 CHARACTERS)
FCBRL	EQU	FCB+12	;FILE'S CURRENT REEL NUMBER
FCBRC	EQU	FCB+15	;FILE'S RECORD COUNT (0 TO 128)
FCBCR	EQU	FCB+32	;CURRENT (NEXT) RECORD NUMBER (0 TO 127)
FCBLN	EQU	FCB+33	;FCB LENGTH
;
;	SET UP STACK
	LXI	H,0
	DAD	SP
;	ENTRY STACK POINTER IN HL FROM THE CCP
	SHLD	OLDSP
;	SET SP TO LOCAL STACK AR LINE POSITION
	JC	FINIS	;CARRY SET BY GNB IF END FILE
	MOV	B,A
;	PRINT HEX VALUES
;	CHECK FOR LINE FOLD
	MOV	A,L
	ANI	0FH	;CHECK LOW 4 BITS
	JNZ	NONUM
;	PRINT LINE NUMBER
	CALL	CRLF
;
;	CHECK FOR BREAK KEY
	CALL	BREAK
;	ACCUM LSB = 1 IF CHARACTER READY
	RRC		;INTO CARRY
	JC	FINIS	;DON'T PRINT ANY MORE
;
	MOV	A,H
	CALL	PHEX
	MOV	A,L
	CALL	PHEX
NONUM:
	INX	H	;TO NEXT LINE NUMBER
	MVI	A,' '
	CALL	PCHAR
	MOV	A,B
	CALL	PHEX
	JMP	GLOOP
;
FINIS:
;	END OF DUMP, RETURN TO CCP
;	(NOTE HAR
	RET
;
;
PNIB:	;PRINT NIBBLE IN REG A
	ANI	0FH	;LOW 4 BITS
	CPI	10
	JNC	P10
;	LESS THAN OR EQUAL TO 9
	ADI	'0'
	JMP	PRN
;
;	GREATER OR EQUAL TO 10
P10:	ADI	'A' - 10
PRN:	CALL	PCHAR
	RET
;
PHEX:	;PRINT HEX CHAR IN REG A
	PUSH	PSW
	RRC
	RRC
	RRC
	RRC
	CALL	PNIB	;PRINT NIBBLE
	POP	PSW
	CALL	PNIB
	RET
;
ERR:	;PRINT ERROR MESSAGE
;	D,E ADDRESSES MESSAGE ENDING WITH "$"
	MVI	C,PRINTF	;PRINT BUFFER FUNCTION
	CALL	BDOS
	RET
;
;
GNB:	;GET NEXT BYTE
	LDA	IBP
	CPI	80H
	JNZ	G0SETUP:	;SET UP FILE 
;	OPEN THE FILE FOR INPUT
	XRA	A	;ZERO TO ACCUM
	STA	FCBCR	;CLEAR CURRENT RECORD
;
	LXI	D,FCB
	MVI	C,OPENF
	CALL	BDOS
;	255 IN ACCUM IF OPEN ERROR
	RET
;
DISKR:	;READ DISK FILE RECORD
	PUSH H! PUSH D! PUSH B
	LXI	D,FCB
	MVI	C,READF
	CALL	BDOS
	POP B! POP D! POP H
	RET
;
;	FIXED MESSAGE AREA
SIGNON:	DB	'FILE DUMP VERSION 1.4$'
OPNMSG:	DB	CR,LF,'NO INPUT FILE PRESENT ON DISK$'

;	VARIABLE AREA
IBP:	DS	2	;INPUT BUFFER POINTER
OLDSP:	DS	2	;ENTRY SP VALUE FROM CCP
;k for a character from the printer
	ani	dr
	jz	xskip		;Skip if no character present
	in	rbr		;Get the character
	ani	7fh		;Strip parity
	sta	lastch		;Save last character recieved
	mov	b,a
xskip:	mov	a,b
	sui	xoff		;Check for Xoff char (control S)
	jnz	xsdone		;Printer ready
	ret			;Printer not ready (return zero)

xsdone:	mvi	a,0ffh		;Printer ready for data
	ret

	endif			;Multi I/O serial driver

*****************************************************************
*								*
* Gocpm is the shld	entry+1
	xra	a		;A <- 0
	sta	bufsec		;Set buffer to unknown state
	sta	bufwrtn		;Set buffer not dirty flag
	sta	error		;Clear buffer error flag

	lda	cwflg		;Get cold/warm boot flag
	ora	a
	lxi	h,coldmes	;Pointer to initial cold command
	jz	cldcmnd
	lxi	h,warmes	;Pointer to initial warm command
cldcmnd:mov	e,m		;Do one level of indirection
	inx	h
	mov	d,m
	ldax	d		;Get command length
	inr	a		;Bump length to include length byte itself
	lxi	h,ccp+7		;Command buffer (includes length byte)S, then initializes	*
* system parameters as in cold boot. See the Cold Boot Loader	*
* listing for exactly what happens during warm and cold boots.	*
*								*
*****************************************************************

wboot:	lxi	sp,tpa		;Set up stack pointer
	mvi	a,1
	sta	cwflg		;Set cold/warm boot flag

	mvi	h,wmdrive	;Move drive to warm boot off of into (h)
	mvi	l,d$wboot	;Peform warm boot operation
	call	jumper
	jnc	gocpm		;No error

	hlt			;Halt computer
	db	0

	jmp	wboot		;ata transfer.		*
*								*
*****************************************************************

setdma:	mov	h,b		;Enter with DMA address in (bc)
	mov	l,c
	shld	cpmdma		;CP/M dma address
	ret

*****************************************************************
*								*
* Home is translated into a seek to track zero.			*
*								*
*****************************************************************

home:	lda	bufwrtn		;Test buffer dirty flag
	ora	a
	jnz	dohome		;Skip buffer disable if buffer dir****************
*								*
* Sectran translates a logical sector number into a physical	*
* sector number.						*
*								*
*****************************************************************

sectran:lda	cpmdrv		;Get the Drive Number
	mov	h,a		;Drive in (h)
	mvi	l,d$stran
	jmp	jumper		;See device level sector translation routines

*****************************************************************
*								*
* Setdrv selects the next drive to be used in read/write	*
* operations.  If the driveentry point from cold boots, and warm boots. It	*
* initializes some of the locations in page 0, and sets up the	*
* initial DMA address (80h).					*
*								*
*****************************************************************

gocpm:	lxi	h,buff		;Set up initial DMA address
	call	setdma
	mvi	a,(jmp)		;Initialize jump to warm boot
	sta	wbot
	sta	entry		;Initialize jump to BDOS
	lxi	h,wboote	;Set up low memory entry to CBIOS warm boot
	shld	wbot+1
	lxi	h,bdos+6	;Set up low memory entry to BDOS
	
	mov	c,a		;Set up for block move
	mvi	b,0
	call	movbyt		;Move command to internal CCP buffer
	lda	cwflg		;Figure out whether or not to send message
	ora	a
	lda	autoflg
	jz	cldbot
	rar
cldbot:	rar
	lda	cdisk		;Jump to CP/M with currently selected disk in C
	mov	c,a
	jc	ccp		;Enter CP/M, send message
	jmp	ccp+3		;Enter CP/M, no message

cwflg:	db	0		;Cold/warm boot flag

*****************************************************************
*								*
* WBOOT loads in all of CP/M except the CBIOIn case user restarts the computer

*****************************************************************
*								*
* Setsec just saves the desired sector to seek to until an	*
* actual read or write is attempted.				*
*								*
*****************************************************************

setsec:	mov	h,b		;Enter with sector number in (bc)
	mov	l,c
	shld	cpmsec
donop:	ret

*****************************************************************
*								*
* Setdma saves the DMA address for the dty
	xra	a		;Invalidate buffer on home call
	sta	bufsec
dohome:	lxi	b,0		;Track to seek to

*****************************************************************
*								*
* Settrk saves the track # to seek to. Nothing is done at this	*
* point, everything is deffered until a read or write.		*
*								*
*****************************************************************

settrk:	mov	h,b	;Enter with track number in (bc)
	mov	l,c
	shld	cpmtrk
	ret

************************************************* has never been selected it calls	*
* a low level drive select routine that should perform some	*
* sort of check if the device is working.  If not working then	*
* it should report an error.  If the logical drive has been	*
* selected before then setdrv just returns the DPH without	*
* checking the drive.						*
*								*
*****************************************************************

setdrv:	mov	a,c		;Save the logical drive number
	sta	cpmdrv
	cpi	maxlog		;Check for a valid drive number
	jkdsk		;disk to seek
	sta	unadsk		;unadsk = sekdsk
	lhld	sektrk
	shld	unatrk		;unatrk = sectrk
	lda	seksec
	sta	unasec		;unasec = seksec
;
chkuna:
	;check for write to unallocated sector
	lda	unacnt		;any unalloc remain?
	ora	a
	jz	alloc		;skip if not
;
;	more unallocated records remain
	dcr	a		;unacnt = unacnt-1
	sta	unacnt
	lda	sekdsk		;same disk?
	lxi	h,unadsk
	cmp	m		;sekdsk = unadsk?
	jnz	alloc		;skip if not
;
;	disks are the same
	lxi	h,unatrk
	call	sektrkcmp	;sektrk = unatrk?
	ag		;rsflag = 0
	jmp	rwoper		;to perform the write
;
alloc:
	;not an unallocated record, requires pre-read
	xra	a		;0 to accum
	sta	unacnt		;unacnt = 0
	inr	a		;1 to accum
	sta	rsflag		;rsflag = 1
;
;*****************************************************
;*                                                   *
;*	Common code for READ and WRITE follows       *
;*                                                   *
;*****************************************************
rwoper:
	;enter here to pertrack?
	lxi	h,hsttrk
	call	sektrkcmp	;sektrk = hsttrk?
	jnz	nomatch
;
;	same disk, same track, same buffer?
	lda	sekhst
	lxi	h,hstsec	;sekhst = hstsec?
	cmp	m
	jz	match		;skip if match
;
nomatch:
	;proper disk, but not correct sector
	lda	hstwrt		;host written?
	ora	a
	cnz	writehst	;clear host buff
;
filhst:
	;may have to fill the host buffer
	lda	sekdsk
	sta	hstdsk
	lhld	sektrk
	shld	hsttrk
	lda	sekhst
	sta	hstsec
	lda	rsflag		;need to read?
	ora	a
	cnz	readhst		;yes, if 1
	xra	 direction
	mvi	a,1
	sta	hstwrt		;hstwrt = 1
	xchg			;source/dest swap
;
rwmove:
	;C initially 128, DE is source, HL is dest
	ldax	d		;source character
	inx	d
	mov	m,a		;to dest
	inx	h
	dcr	c		;loop 128 times
	jnz	rwmove
;
;	data has been moved to/from host buffer
	lda	wrtype		;write type
	cpi	wrdir		;to directory?
	lda	erflag		;in case of errors
	rnz			;no further processing
;
;	clear host buffer for directory write
	ora	a		;errors?
	rnz			;skip if so
	xra	a		;0 to accum
	sta	hstwrt
	inx	d
	inx	h
	ldax	d
	cmp	m	;sets flags
	ret
;
;*****************************************************
;*                                                   *
;*	WRITEHST performs the physical write to      *
;*	the host disk, READHST reads the physical    *
;*	disk.					     *
;*                                                   *
;*****************************************************
writehst:
	;hstdsk = host disk #, hsttrk = host track #,
	;hstsec = host sect #. write "hstsiz" bytes
	;frjnz	alloc		;skip if not
;
;	tracks are the same
	lda	seksec		;same sector?
	lxi	h,unasec
	cmp	m		;seksec = unasec?
	jnz	alloc		;skip if not
;
;	match, move to next sector for future ref
	inr	m		;unasec = unasec+1
	mov	a,m		;end of track?
	cpi	cpmspt		;count CP/M sectors
	jc	noovf		;skip if no overflow
;
;	overflow to next track
	mvi	m,0		;unasec = 0
	lhld	unatrk
	inx	h
	shld	unatrk		;unatrk = unatrk+1
;
noovf:
	;match found, mark as unnecessary read
	xra	a		;0 to accumulator
	sta	rsflform the read/write
	xra	a		;zero to accum
	sta	erflag		;no errors (yet)
	lda	seksec		;compute host sector
	rept	secshf
	ora	a		;carry = 0
	rar			;shift right
	endm
	sta	sekhst		;host sector to seek
;
;	active host sector?
	lxi	h,hstact	;host active flag
	mov	a,m
	mvi	m,1		;always becomes 1
	ora	a		;was it already?
	jz	filhst		;fill host if not
;
;	host buffer active, same as seek buffer?
	lda	sekdsk
	lxi	h,hstdsk	;same disk?
	cmp	m		;sekdsk = hstdsk?
	jnz	nomatch
;
;	same disk, same a		;0 to accum
	sta	hstwrt		;no pending write
;
match:
	;copy data to or from buffer
	lda	seksec		;mask buffer number
	ani	secmsk		;least signif bits
	mov	l,a		;ready to shift
	mvi	h,0		;double count
	rept	7		;shift left 7
	dad	h
	endm
;	hl has relative host buffer address
	lxi	d,hstbuf
	dad	d		;hl = host address
	xchg			;now in DE
	lhld	dmaadr		;get/put CP/M data
	mvi	c,128		;length of move
	lda	readop		;which way?
	ora	a
	jnz	rwmove		;skip if read
;
;	write operation, mark and switch		;buffer written
	call	writehst
	lda	erflag
	ret
;
;*****************************************************
;*                                                   *
;*	Utility subroutine for 16-bit compare        *
;*                                                   *
;*****************************************************
sektrkcmp:
	;HL = .unatrk or .hsttrk, compare with sektrk
	xchg
	lxi	h,sektrk
	ldax	d		;low byte compare
	cmp	m		;same?
	rnz			;return if not
;	low bytes equal, test high 1som hstbuf and return error flag in erflag.
	;return erflag non-zero if error
	ret
;
readhst:
	;hstdsk = host disk #, hsttrk = host track #,
	;hstsec = host sect #. read "hstsiz" bytes
	;into hstbuf and return error flag in erflag.
	ret
;
;*****************************************************
;*                                                   *
;*	Unitialized RAM data areas		     *
;*                                                   *
;*****************************************************
;nc	zret		;Illegal drive

	mov	a,e		;Check if bit 0 of (e) = 1
	ani	1
	jnz	setd3		;Drive has allready been accessed

	mov	h,c		;Move logical drive into (h)
	mvi	l,d$sel1
	call	jumper		;Call low level drive select
	mov	a,h		;Check if the low level drive select returned
	ora	l		; zero to indicate an error
	jz	zret		;Yes, an error so report to CP/M

	push	h		;Save DPH address
	call	gdph		;Get entry if DPH save table
	pop	d		;DPH -> (de)
	mov	m,e		;Put address of DPH in table
	inx	h
	mov	m,d
	rrors
	ret

setd3:	push	d		;Save DPH address
	mov	h,c		;Drive in (h)
	mvi	l,d$sel2	;Select drive
	call	jumper
	call	gdph		;Quick select
	pop	d
	mov	e,m		;DPH -> (de)
	inx	h
	mov	d,m
	inx	h
	mov	c,m		;Sector size -> (c)
	xchg			;DPH -> (hl)
	jmp	setd0

gdph:	lda	cpmdrv		;Return pointer to DPH save area
	rlc			;Each entry is 4 bytes long
	rlc
	mov	e,a
	mvi	d,0
	lxi	h,dphtab	;DPH save area table
	dad	d		;Add offset
	ret			;(hl) = DPH save area for current drive

zret:	lxi	h,0		;Seldrv*******************************************************

dphtab:	rept	maxlog*4
	db	0
	endm

*****************************************************************
*								*
* Getbad - Check if a device has a bad map.  If the device has	*
* a bad sector map then append bad entries to end of badmap	*
* table.							*
*								*
*****************************************************************

getbad:	mvi	m,1		;Set drive initilized
	push	b
	push	d
	lda	cpmdrv		;Pick up current drive
	mov	h,a		;Cter
	lxi	d,buffer	;Start at beginning of buffer
badl:	ldax	d		;Pick up an entry from the buffer
	ora	a
	jz	bade		;All done
	mov	a,m		;Pick up entry from bad map table
	inr	a
	jz	overflo		;Bad map overflow
	lda	cpmdrv		;Put drive in table
	mov	m,a
	inx	h
	lxi	b,8
	call	movbyt		;Move the rest of information into the table
	jmp	badl

bade:	shld	badptr		;Restore new bad map pointer
badret:	pop	d
	pop	b
	ret

overflo:lxi	h,omes
	call	message
	jmp	badret

omes:	db	0dh, 0ah, 'BAD MAP OVERFLesired sector. Once the correct sector is in memory, the	*
* buffer written indicator is set, so the buffer will be	*
* flushed, then the data is transferred into the buffer.	*
*								*
*****************************************************************

write:	mov	a,c		;Save write command type
	sta	writtyp
	mvi	a,1		;Set write command
	jmp	rwent

*****************************************************************
*								*
* Read routine to buffer data from the disk. If the sector	*
* requesteinx	h
	mov	m,c		;Put sector size in table
	inx	h
	mov	a,m		;Check if bad map has ever been read for this
	ora	a		; drive
	cz	getbad		;Never been read so read in bad map
	xchg			;DPH -> (hl)

setd0:	mov	a,c		;Move sector size code into (a)
	sta	secsiz		;Save sector size
	xra	a
setd1:	dcr	c		;Create number of (128 bytes/physical sector)-1
	jz	setd2
	rlc
	ori	1
	jmp	setd1
setd2:	sta	secpsec		;Save for deblocking
	lda	cpmdrv		;Save current drive as old drive
	sta	lastdrv		; in case of select e error exit
	lda	lastdrv		;Get last selected drive
	mov	c,a
	lda	cdisk		;Pick up user/drive
	ani	0f0h		;Save user number
	ora	c		;Put together with old drive
	sta	cdisk
	ret

*****************************************************************
*								*
* DPH save area.  Each entry is 4 bytes long:			*
*	0 - LSB of DPH address					*
*	1 - MSB of DPH address					*
*	2 - Sector size code (1 = 128, 2 = 256, 3 = 512...	*
*	3 - Bad map has been initilized (0 = Uninitilized)	*
*								*
**********all drive routine to return a pointer to
	mvi	l,d$bad		;the track and sector of the bad map
	call	jumper

	mov	a,h		;If routine returns 0 then the device has
	ora	l		; no bad sector map
	jz	badret

	mov	e,m		;Pick up track number of bad sector map -> (de)
	inx	h
	mov	d,m
	inx	h
	xchg
	shld	cpmtrk
	xchg
	mov	a,m		;Pick up sector number of of bad sector map
	inx	h
	mov	h,m
	mov	l,a
	shld	truesec
	call	fill		;Read in bad sector map into the buffer
	rc

	lhld	badptr		;Pick up bad map poinOW!', 0dh, 0ah, 0

nobad:	lxi	h,0		;Used by device drives to indicate no bad
	ret			; sector map

badptr:	dw	badmap		;Pointer to next available bad map entry

*****************************************************************
*								*
* Write routine moves data from memory into the buffer. If the	*
* desired CP/M sector is not contained in the disk buffer, the	*
* buffer is first flushed to the disk if it has ever been	*
* written into, then a read is performed into the buffer to get	*
* the dd from CP/M is in the buffer, then the data is simply	*
* transferred from the buffer to the desired dma address. If	*
* the buffer does not contain the desired sector, the buffer is	*
* flushed to the disk if it has ever been written into, then	*
* filled with the sector from the disk that contains the	*
* desired CP/M sector.						*
*								*
*****************************************************************

read:	xra	a		;Set the command type to read
	if	nostand ne 0
	sta	unaloc		;Clear unallo*mwlog		;Generate CKS and ALV tables
	alloc	mw,%dn,%alv,0
dn	set	dn+1
	endm

	else				;Use standard partitioning

dn	set	0
trkoff	set	8192/(mwsecpt/8)+1
psize	set	trkoff*(mwsecpt/8)

	rept	maxmw

blocks	set	mwsecpt/8*mwtrks

	rept	blocks/8192		;Generate some 8 megabyte ALV's
	alloc	mw,%dn,256,0
blocks	set	blocks-psize
dn	set	dn+1
	endm

blocks	set	blocks/4

	if	blocks gt 256		;Use the remainder
blocks	set	blocks-1
alv	set	(blocks/8)+1
	alloc	mw,%dn,%alv,0
dn	set	dn+1
	endif
	end;*****************************************************
;*                                                   *
;*      Sector Deblocking Algorithms for CP/M 2.0    *
;*                                                   *
;*****************************************************
;
;	utility macro to compute sector mask
smask	macro	hblk
;;	compute log2(hblk), return @x as result
;;	(2 ** @x = hblk on return)
@y	set	hblk
@x	set	0
;;	count right shifts of @y until = 1
	rept	8
	if	@y = 1
	exitm
	endi28	;CP/M sects/host buff
cpmspt	equ	hstblk * hstspt	;CP/M sectors/track
secmsk	equ	hstblk-1	;sector mask
	smask	hstblk		;compute sector mask
secshf	equ	@x		;log2(hstblk)
;
;*****************************************************
;*                                                   *
;*        BDOS constants on entry to write           *
;*                                                   *
;*****************************************************
wrall	equ	0		;write to allocated
wrdir	equ	1		;write  boot to initialize
	xra	a		;0 to accumulator
	sta	hstact		;host buffer inactive
	sta	unacnt		;clear unalloc count
	ret
;
home:
	;home the selected disk
home:
	lda	hstwrt	;check for pending write
	ora	a
	jnz	homed
	sta	hstact	;clear host active flag
homed:
	ret
;
seldsk:
	;select disk
	mov	a,c		;selected disk number
	sta	sekdsk		;seek disk number
	mov	l,a		;disk number to HL
	mvi	h,0
	rept	4		;multiply by 16
	dad	h
	endm
	lxi	d,dpbase	;base of parm block
	dad	d		;hl=.dpb(curdsk)
	    *
;*	the previous BIOS defintion for READ.        *
;*                                                   *
;*****************************************************
read:
	;read the selected CP/M sector
	xra	a
	sta	unacnt
	mvi	a,1
	sta	readop		;read operation
	sta	rsflag		;must read data
	mvi	a,wrual
	sta	wrtype		;treat as unalloc
	jmp	rwoper		;to perform the read
;
;*****************************************************
;*                                                   *
;*	The WRITE enm

	endif
	endif

bioslen	equ	(high ($-bios))+1	;BIOS length in pages

	if	bioslen gt biosln	;Test for overflow
	'FATAL ERROR, system overflow.  BIOSLN must be at least'
dbgtmp	set	bioslen		;BIOSLN! <debug>
	endif

	if	debug
dbgtmp	set	biosln		;Current BIOSLN! <debug>
	if	biosln gt bioslen
dbgtmp	set	bioslen		;Optimal BIOSLN! <debug>
	endif
	endif

	end
ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееf
;;	@y is not 1, shift right one position
@y	set	@y shr 1
@x	set	@x + 1
	endm
	endm
;
;*****************************************************
;*                                                   *
;*         CP/M to host disk constants               *
;*                                                   *
;*****************************************************
blksiz	equ	2048		;CP/M allocation size
hstsiz	equ	512		;host disk sector size
hstspt	equ	20		;host disk sectors/trk
hstblk	equ	hstsiz/1to directory
wrual	equ	2		;write to unallocated
;
;*****************************************************
;*                                                   *
;*	The BDOS entry points given below show the   *
;*      code which is relevant to deblocking only.   *
;*                                                   *
;*****************************************************
;
;	DISKDEF macro, or hand coded tables go here
dpbase	equ	$		;disk param block base
;
boot:
wboot:
	;enter here on systemret
;
settrk:
	;set track given by registers BC
	mov	h,b
	mov	l,c
	shld	sektrk		;track to seek
	ret
;
setsec:
	;set sector given by register c 
	mov	a,c
	sta	seksec		;sector to seek
	ret
;
setdma:
	;set dma address given by BC
	mov	h,b
	mov	l,c
	shld	dmaadr
	ret
;
sectran:
	;translate sector number BC
	mov	h,b
	mov	l,c
	ret
;
;*****************************************************
;*                                                   *
;*	The READ entry point takes the place of  try point takes the place of     *
;*	the previous BIOS defintion for WRITE.       *
;*                                                   *
;*****************************************************
write:
	;write the selected CP/M sector
	xra	a		;0 to accumulator
	sta	readop		;not a read operation
	mov	a,c		;write type in c
	sta	wrtype
	cpi	wrual		;write unallocated?
	jnz	chkuna		;check for unalloc
;
;	write to unallocated, set parameters
	mvi	a,blksiz/128	;next unalloc recs
	sta	unacnt
	lda	secated write flag
	endif
rwent:	sta	rdwr		;Save command type

*****************************************************************
*								*
* Redwrt calculates the physical sector on the disk that	*
* contains the desired CP/M sector, then checks if it is the	*
* sector currently in the buffer. If no match is made, the	*
* buffer is flushed if necessary and the correct sector read	*
* from the disk.						*
*								*
*****************************************************************

redwrt:	mvi	v	l,a
	jmp	divloop		;
divdone:inx	h
	mov	a,h
	ora	c		;Restore the side bit
	mov	h,a
	shld	truesec		;Save the physical sector number
	lxi	h,cpmdrv	;Pointer to desired drive,track, and sector
	lxi	d,bufdrv	;Pointer to buffer drive,track, and sector
	mvi	b,6		;Count loop
dtslop:	dcr	b		;Test if done with compare
	jz	move		;Yes, match. Go move the data
	ldax	d		;Get a byte to compare
	cmp	m		;Test for match
	inx	h		;Bump pointers to next data item
	inx	d
	jz	dtslop		;Match, continue testing

* the buffer.							*
*								*
*****************************************************************

move:	lda	cpmsec		;Get the CP/M sector to transfer
	dcr	a		;Adjust to proper sector in buffer
	ani	0		;Strip off high ordered bits
secpsec	equ	$-1		;The 0 is modified to represent the # of
				;	CP/M sectors per physical sectors
	mov	l,a		;Put into HL
	mvi	h,0
	dad	h		;Form offset into buffer
	dad	h
	dad	h
	dad	h
	dad	h
	dad	h
	dad	h
	lxi	d,buffer	;Beginning address of buffer
	dad	d		;Form b
	sta	bufwrtn		;Set buffer written into flag
	mvi	a,0		;Check for directory write
writtyp	equ	$-1
	dcr	a		;Test for a directory write
	mvi	a,0
	rnz			;No error exit

*****************************************************************
*								*
* Flush writes the contents of the buffer out to the disk if	*
* it has ever been written into.				*
*								*
*****************************************************************

flush:	mvi	a,0		;The 0 is modified to reflect if
				;	the buffer has beenep:	call	alt		;Check for alternate sectors
	di			;Reset interrupts
	xra	a		;Reset buffer written flag
	sta	bufwrtn

	mvi	b,retries	;Maximum number of retries to attempt
retrylp:push	b		;Save the retry count

	mvi	l,d$sel2	;Select drive
	call	jumpbuf

	lhld	alttrk		;Track number -> (hl)

	mov	a,h		;Test for track zero
	ora	l

	push	h		;Save track number
	mvi	l,d$home
	cz	jumpbuf
	pop	b		;Restore track #

	mvi	l,d$strk
	call	jumpbuf

	lhld	altsec		;Sector -> (hl)
	mov	b,h
	mov	c,l
b,0		;The 0 is modified to contain the log2
secsiz	equ	$-1		;	of the physical sector size/128
				;	on the currently selected disk
	lhld	cpmsec		;Get the desired CP/M sector #
	mov	a,h
	ani	80h		;Save only the side bit
	mov	c,a		;Remember the side
	mov	a,h
	ani	7fh		;Forget the side bit
	mov	h,a
	dcx	h		;Temporary adjustment
divloop:dcr	b		;Update repeat count
	jz	divdone
	ora	a
	mov	a,h
	rar
	mov	h,a
	mov	a,l
	rar			;Divide the CP/M sector # by the size
				;	of the physical sectors
	mo****************************************************************
*								*
* Drive, track, and sector don't match, flush the buffer if	*
* necessary and then refill.					*
*								*
*****************************************************************

	call	fill		;Fill the buffer with correct physical sector
	rc			;No good, return with error indication

*****************************************************************
*								*
* Move has been modified to cause either a transfer into or out	*
*eginning address of sectgr to transfer
	xchg			;DE = address in buffer
	lxi	h,0		;Get DMA address, the 0 is modified t/
				;	contain the DMA address
cpmdma	equ	$-2
	mvi	a,0		;The zero gets modified to contain
				;	a zero if a read, or a 1 if write
rdwr	equ	$-1
	ana	a		;Test which kind of operation
	jnz	into		;Transfer data into the buffer
outof:	call	mov128
	lda	error		;Get the buffer error flag
	ret

into:	xchg			;
	call	mov128		;Move the data, HL = destination
				;	DE = source
	mvi	a,1 written into
bufwrtn	equ	$-1
	ora	a		;Test if written into
	rz			;Not written, all done
	mvi	a,d$write
	sta	rwop+1
	call	prep		;Do the physical write
	sta	error		;Set up the error flag
	ret

*****************************************************************
*								*
* Prep prepares to read/write the disk. Retries are attempted.	*
* Upon entry, H&L must contain the read or write operation	*
* address.							*
*								*
*****************************************************************

pr
	mvi	l,d$ssec
	call	jumpbuf

	lxi	b,buffer	;Set the DMA address
	mvi	l,d$sdma
	call	jumpbuf

rwop:	mvi	l,0		;Get operation address
	call	jumpbuf

	pop	b		;Restore the retry counter
	mvi	a,0		;No error exit status
	rnc			;Return no error
	dcr	b		;Update the retry counter
	stc			;Assume retry count expired
	mvi	a,0ffh		;Error return
	rz			;Return sad news
	mov	a,b
	cpi	retries/2
	jnz	retrylp		;Try again
	push	b		;Save retry count
	mvi	l,d$home	;Home drive after (retries/2) errors
	call	******************************************
*									*
* Initialize the North Star Mother board, left serial port, right	*
* serial port, and North Star RAM parity.				*
*									*
*************************************************************************

	if	contyp eq 6		;North Star drivers

ttyset:					;Set up the parallel port + motherboard
	xra	a			;Initialize mother board
	out	6
	out	6
	out	6
	out	6

	mvi	a,30h			;Reset the parallel port input flag
	out	nspsta
	mvi	a,60h			;Set the prdat
	in	nsrdat

	if	nsram ne 0		;Reset parity on North Star RAMs
	mvi	a,40h			;Disable parity logic
	out	nsram
	lxi	h,0			;Starting address

nset0:	mov	a,m			;Get a byte
	mov	m,a			;Rewrite, set proper parity
	inr	l			;Bump the address pointer
	jnz	nset0

nset1:	inr	h			;Skip to the next memory page
	jz	nset2			;Skip if all done 
	mvi	a,(high $) + 1		;Is the pointer above us?
	cmp	h			;Set carry if pointer is <= our page+1
	jc	nset0			;Reset the next pages parity
	mov	a,m			;Test for a PR
ptrset:
ptpset:
uc1set:
ur1set:
ur2set:
up1set:
up2set:
lptset:
ul1set:
	ret
	endif				;North Star drivers

	if	(lsttyp ge 2) and (lsttyp le 5)	;Serial Multi I/O list drivers

lstset:	call	sellst			;Select printer group
	mvi	a,dlab			;Access divisor latch
	out	lcr
	lhld	deflst			;Get LST: baud rate divisor
	mov	a,h
	out	dlm			;Set upper baud rate
	mov	a,l
	out	dll
	mvi	a,stb+wls0+wls1		;2 stop bits + 8 bit word
	out	lcr
	mvi	a,dtrenb+rtsenb		;DTR + RTS enabled
	out	mcr
	in	rbr			;1k sector devices
	endif

*****************************************************************
*								*
* Each bad map entry consists of 9 bytes:			*
*	Logical drive number (1 byte)				*
*	Track number of bad sector (2 bytes)			*
*	Sector number of bad sector (2 bytes)			*
*	Track number of alternate sector (2 bytes)		*
*	Sector number of alternate sector (2 bytes)		*
*								*
*****************************************************************

badmap:	ds	badsiz*9+1		;32 entries + end marker

	rept	maxhd*hdlog		;Generate CKS and ALV tables
	alloc	hd,%dn,%alv,0
dn	set	dn+1
	endm

	else				;Standard partitioning

dn	set	0
	rept	maxhd
	if	m26 ne 0
	alloc	hd,%dn,252,0
dn	set	dn+1
	alloc	hd,%dn,252,0
dn	set	dn+1
	alloc	hd,%dn,256,0
dn	set	dn+1
	endif

	if	m10 ne 0
	alloc	hd,%dn,159,0
dn	set	dn+1
	alloc	hd,%dn,161,0
dn	set	dn+1
	endif

	if	m20 ne 0
	alloc	hd,%dn,255,0
dn	set	dn+1
	alloc	hd,%dn,255,0
dn	set	dn+1
	alloc	hd,%dn,129,0
dn	set	dn+1
	endif
	endm
	endif

	arallel port output flag
	out	nspsta
	mvi	a,acr			;Force a CR out the parallel port
	call	nspout

					;Initialize the left serial port
	mvi	a,nslin1		;See the equates for bit definations
	out	nslsta
	mvi	a,nslin2
	out	nslsta
	xra	a			;Clear the input/output buffers
	out	nsldat
	in	nsldat
	in	nsldat

					;Initialize the right serial port
	mvi	a,nsrin1		;See the equates for bit definations
	out	nsrsta
	mvi	a,nsrin2
	out	nsrsta
	xra	a			;Clear the input/output buffers
	out	nsrdat
	in	nsOM or no memory
	mov	b,a			;Save the original byte
	cma				;See if this location will change
	mov	m,a
	cmp	m			;Test for a change
	mov	m,b			;Restore the original value
	jz	nset0			;Value complemented, must be RAM
	ora	a			;Test for no memory present
	jz	nset1			;Skip to the next page if no memory
	lxi	d,700h			;Skip 2K bytes of 'PROM'
	dad	d
	jnc	nset1			;Do a page check if no overflow

nset2:	mvi	a,41h			;Re-enable parity on the memory boards
	out	nsram
	endif

crtset:					;Null routinesClear input buffer
	xra	a
	out	ier			;No interrupts
	ret

	endif

	db	0,0ffh,0

codelen	equ	($-bios)		;Length of Cbios code

	if	codelen gt 1000h	;Test for SYSGEN problems
	'FATAL ERROR, system is too big for SYSGEN rev. 4.X'
dbgtmp	set	codelen		;Cbios code length   !   <debug>
	endif

	if	debug
dbgtmp	set	codelen		;Cbios code length   !   <debug>
	endif

	ds	512-($-buffer)		;Buffer for 512 byte sectors

	if	(maxfd ne 0) or (maxdm ne 0) or (maxmw ne 0)
	ds	512			;Additional space for 
dirbuf:	ds	128			;Directory buffer

tempb:	ds	16			;A little temporary buffer

*****************************************************************
*								*
* Allocation and checked directory table area			*
*								*
*****************************************************************

	if	maxhd ne 0
	if	hdpart ne 0		;Use non-standard partitioning

tracks	set	hdtrks/hdlog		;Number of tracks per partition
dsm	set	hdsectp/8*tracks/4-1	;Number of groups per partition
alv	set	(dsm/8)+1

dn	set	0endif

	if	maxfd ne 0
dn	set	0

	rept	maxfd
	alloc	fd,%dn,75,64
dn	set	dn+1
	endm
	endif

	if	maxdm ne 0
dn	set	0

	rept	maxdm
	alloc	dm,%dn,75,64
dn	set	dn+1
	endm
	endif

	if	maxmf ne 0
dn	set	0
	rept	maxmf
	alloc	mf,%dn,22,16
dn	set	dn+1
	endm
	endif

	if	maxmw ne 0
	if	mwpart ne 0		;Use non-standard partitioning

tracks	set	mwtrks/mwlog		;Number of tracks per partition
dsm	set	mwsectp/8*tracks/4-1	;Number of groups per partition
alv	set	(dsm/8)+1
dn	set	0

	rept	maxmwjumpbuf
	pop	b
	jmp	retrylp		;Try again

*****************************************************************
*								*
* Fill fills the buffer with a new sector from the disk.	*
*								*
*****************************************************************

fill:	call	flush		;Flush buffer first
	rc			;Check for error
	lxi	d,cpmdrv	;Update the drive, track, and sector
	lxi	h,bufdrv
	lxi	b,5		;Number of bytes to move
	call	movbyt		;Copy the data

	lda	rdwr		;Test read write flag
	ora	a
	jz	fremov	a,e
	cmp	l
	jnz	awritin
	lxi	h,cpmdrv	;Test for different drive
	lda	unadrv
	cmp	m
	jnz	awritin		;Drive is different, clear unallocated mode
	ret			;Unallocated write, do nothing...

fnaloc:	dcr	a
	jz	awritin		;Do a directory write
				;We are now doing an unallocated write
	lhld	cblock		;Save current block number
	shld	oblock
	lda	cpmdrv		;Save drive that this block belongs to
	sta	unadrv
	mvi	a,1		;Set unallocated write flag
	sta	unaloc
	ret			;   and we do nothing about the write
evice	*
* subroutine.  Jumper is called with the drive in (h) and the	*
* routine number (see description above) in (l).  It passes	*
* along the (bc) and (de) registers unaltered.  Jumpbuf is	*
* a call to jumper with the drive number from bufdrv.		*
*								*
*****************************************************************

jumpbuf:lda	bufdrv		;Dispatch with bufdrv for drive
	mov	h,a

jumper:	push	d
	push	b
	push	h
	mov	a,h		;Logical drive into (a)
	lxi	d,dsttab	;Drive specification pointandler for selected
	inx	h		; function
	mov	h,m
	mov	l,a		;(hl) = *routine
	mov	a,c		;Logical in (a)
	pop	b		;Restore saved registers
	pop	d
	pchl

*****************************************************************
*								*
* Check for alternate sectors in bad sector table.  If an	*
* alternate sector is found replace alttrk and altsec with	*
* new sector number else pass along unaltered.			*
*								*
*****************************************************************

alt:	lxi	h,badmap	;A
	cmp	m		;Check if drive in table matches
	jnz	altmis		;Does not match skip this entry
	inx	h		;Point to LSB of alternate track
	lda	buftrk		;Pick up LSB of buffer track
	cmp	m
	jnz	altmis
	inx	h		;Point to MSB alternate track
	lda	buftrk+1	;Pick up MSB of buffer track
	cmp	m
	jnz	altmis
	inx	h		;Point to LSB of alternate sector
	lda	bufsec		;Pick up LSB of buffer sector
	cmp	m
	jnz	altmis
	inx	h		;Point to MSB of alternate sector
	lda	bufsec+1	;Pick up MSB of buffer sector
	cmp	m
	jnz	altmad		;Skip write type check if reading
	lda	writtyp		;0 = alloc, 1 = dir, 2 = unalloc

	if	nostand ne 0	;Do non standard (but quick and dirty) check
	ora	a
	jnz	fnaloc		;Skip if not an allocated write

	lda	unaloc		;Check unallocated write in progress flag
	ora	a
	jz	fwritin		;We are doing an allocated write
	lhld	cblock		;Get current block address
	xchg
	lhld	oblock		;   and old block address
	mov	a,d		;Compare old versus new
	cmp	h
	jnz	awritin		;Different, clear unallocated writting mode
	
awritin:xra	a		;Clear unallocated writting mode
	sta	unaloc

	else			;Do standard unallocated test

	sui	2		;Test for an unallocated write
	rz

	endif

fwritin:lda	secsiz		;Check for 128 byte sectors
	dcr	a
	rz			;No deblocking needed

fread:	mvi	a,d$read
	sta	rwop+1
	call	prep		;Read the physical sector the buffer
	sta	error		;Set the error status
	ret

*****************************************************************
*								*
* Jumpbuf, jumper are used to dispatch to a low level der table
jumpl:	mov	c,a		;Save logical in (c)
	ldax	d
	mov	l,a
	inx	d
	ldax	d
	mov	h,a		;Get a DST pointer in (hl)
	inx	d
	mov	a,c		;Logical in (a)
	sub	m		;Subtract from first entry in DST
	jnc	jumpl		;Keep scanning table till correct driver found

	inx	h		;Bump (hl) to point to start of dispatch table
	pop	d		;Real (hl) -> (de)
	mov	a,e		;Move offset number into (a)
	rlc			;Each entry is 2 bytes
	mov	e,a		;Make an offset
	mvi	d,0
	dad	d		;(hl) = **Routine
	mov	a,m		;Pick up address of hddress of bad map -> (hl)
	lda	bufdrv		;Pick up drive number currently working on
	mov	c,a		;Move drive into (c) for speed in search
all:	xchg
	lhld	badptr		;Get bad map pointer
	xchg			; -> (de)
	mov	a,d		;Check if at end of bad map table
	cmp	h
	jnz	alt2		;Still more
	mov	a,e
	cmp	l
	jnz	alt2		;Still more
	lhld	buftrk		;No alternate sector so use selected sector
	shld	alttrk
	lhld	bufsec
	shld	altsec
	ret

alt2:	push	h		;Save current bad map entry address
	mov	a,c		;Move drive into (a)is		;Found an alternate sector
	inx	h		;Point to real info on the alternate sector
	lxi	d,alttrk
	xchg			;MOVLOP (de) = source, (hl) = dest
	push	b
	lxi	b,4
	call	movbyt		;Move alternate sector info in correct place
	pop	b
	pop	h
	ret

altmis:	pop	h		;Current alternate did not match
	lxi	d,9		;Bump pointer by the length of an entry
	dad	d
	jmp	all		;Loop for more

*****************************************************************
*								*
* Mover moves 128 bytes of data. Source pointer in6'
	endif
	endif

	if	dn eq mworder		;Generate the HDDMA's message
	msbump	maxmw*mwlog
	db	'HDDMA'
	if	mwquiet eq 0
	db	' '
	if	maxmw gt 1
	db	'(', maxmw+'0', ')'
	endif
	if	st506 ne 0
	db	'M5'
	endif
	if	st412 ne 0
	db	'M10'
	endif
	if	cm5619 ne 0
	db	'M16'
	endif
	endif
	endif

	if	dn eq fdorder		;Generate the 2D/B message
	msbump	maxfd
	db	'DJ2D/B @'
	prhex	fdorig/100h
	prhex	fdorig
	endif

	if	dn eq dmorder		;Generate the DJDMA 8 message
	msbump	maxdm
	db	'DJDMA 8"'
	en
	sta	group			;Clear group select byte
	sta	cpmdrv			;Select disk A:
	sta	cdisk

	lxi	h,bios+3		;Patch cold boot to warm code
	shld	bios+1

	lda	iobyt			;Initialize the IOBYTE
	sta	iobyte

	lxi	d,badmap		;Clear out bad map
	stax	d
	lxi	h,badmap+1
	lxi	b,9*badsiz		;32 map entries
	call	movbyt
	mvi	m,0ffh			;End marker

	if	contyp ne 6		;Non IOBYTE inits
	if	contyp ne 0		;Do not call TTYSET for PROM's
	call	ttyset			;Initialize the terminal
	endif

	if	lsttyp ne 0		;Do not call LSTSET f pointers
	dw	ptrset, ur1set, ur2set
	dw	ptpset, up1set, up2set
	dw	lptset, ul1set, 0

cboot2	equ	$
	endif

	lxi	h,prompt		;Prep for sending signon message
	call	message			;Send the prompt
	jmp	gocpm

*****************************************************************
*								*
* Console and list device initialization routines follow.	*
*								*
*****************************************************************

	if	contyp eq 2		;Multi I/O, Decision I

***********************************
	call	tini0			;Initialize the reader/punch
	ret

tini0:	ani	0e0h			;Mask in upper three bits
	rlc				;Move into lower 3 bits
	rlc
	rlc
	cpi	7			;check for sense = 7 (Default setting)
	jz	dfbaud			;Use default baud rate

	lxi	h,btab			;Pointer to baud rate table
	add	a			;Table of words so double
	mov	e,a			;Make a 16 bit number into (de)
	mvi	d,0
	dad	d			;Get a pointer into baud rate table
	mov	e,m			;Get lower byte of word
	inx	h			;Bump to high byte of word
	mov	d,m			;Get upper byte. (s Register
	in	lsr			;Clear Line Status Register
	in	rbr			;Clear reciever buffers
	in	rbr
	ret

btab:	dw	1047			;110 Baud	000
	dw	384			;300		001
	dw	96			;1200		010
	dw	48			;2400		011
	dw	24			;4800		100
	dw	12			;9600		101
	dw	6			;19200		110
					;DEFCON		111

	endif				;Multi I/O, Decision I

	if	contyp eq 3		;2D/B console initialization

ttyset:	call	fdtstat			;Clean input buffer
	rnz				;All empty
	call	fdcin
	jmp	ttyset

	endif				;2D/B console

	if	contyp eq 4
ttyset:	cadif

	if	dn eq mforder		;Generate the DJDMA 5 1/4 message
	msbump	maxmf
	db	'DJDMA 5 1/4"'
	endif

dn	set	dn+1
	endm

	db	acr,alf
	db	0			;End of message

*****************************************************************
*								*
* Cboot is the cold boot loader. All of CP/M has been loaded in	*
* when control is passed here.					*
*								*
*****************************************************************

cboot:	lxi	sp,tpa			;Set up stack

	xra	a			;Clear cold boot flag
	sta	cwflgor PROM's
	call	lstset			;Initialize the list device
	endif
	else				;Do IOBYTE inits
	lxi	h,devset		;Device setup routine pointer table
cboot0:	mov	e,m			;Load a routine address
	inx	h
	mov	d,m
	inx	h
	mov	a,d			;Test for the end of the table
	ora	e
	jz	cboot2
	push	h			;Save the table pointer
	lxi	h,cboot1		;Return address
	push	h
	xchg
	pchl				;'CALL' a device setup routine
cboot1:	pop	h			;Restore the table pointer
	jmp	cboot0

devset:	dw	ttyset, crtset, uc1set	;Device setup routine******************************
*								*
* Terminal initilization routine.  This routine reads the sense	*
* switch on the WB-14 and sets the speed accordingly.		*
*								*
*****************************************************************

ttyset:	call	selg0			;Select group 0
	in	sensesw			;Get sense switch (ff on a Multio)
	push	psw
	call	selcon			;Select console
	pop	psw
	push	psw
	call	tini0			;Initialize the console
	pop	psw
	push	psw
	call	selrdr			;Select the reader/punch
	pop	pswde) now has divisor
	jmp	setit			;Set baud rate

dfbaud:	lhld	defcon			;Use default baud rate
	xchg

setit:	mvi	a,dlab+wls1+wls0+stb	;Enable divisor access latch
	out	lcr			;Set the baud rate in (de)
	mov	a,d
	out	dlm			;Set upper divisor
	mov	a,e
	out	dll			;Set lower divisor

	mvi	a,wls1+wls0+stb		;Clear Divisor latch
	out	lcr
	xra	a
	out	ier			;Set no interrupts
	out	lsr			;Clear status
	mvi	a,dtrenb+rtsenb		;Enable DTR and RTS outputs to terminal
	out	mcr
	in	msr			;Clear MODEM Statull	dminit			;See if controller present
	rc				;No controller, return
	lxi	d,dmaci			;Console initialization sequence
	lxi	h,dmchan
	lxi	b,10			;Command length
	call	movbyt
	dcx	h
	xra	a			;Clear serial input status
	sta	serin+1
	jmp	docmd2			;Do stuff and return

dmaci:	db	writem			;Zot monitor disable flag
	dw	ttyset			;Any non-zero byte will do
	db	0
	dw	1			;One byte
	dw	13f5h			;Magical place in monitor
	db	senabl			;Enable serial input
	db	1

	endif

******************************* DE, Dest	*
* pointer in HL.						*
*								*
*****************************************************************

mov128:	lxi	b,128		;Length of transfer
movbyt:	xra	a		;Check if host processor is a Z80
	adi	3
	jpo	z80mov		;Yes, Its a Z80 so use block move

m8080:	ldax	d		;Get a byte of source
	mov	m,a		;Move it
	inx	d		;Bump pointers
	inx	h
	dcx	b		;Update counter
	mov	a,b		;Test for end
	ora	c
	jnz	m8080
	ret

z80mov: xchg			;Source in (hl), Destination in (de)
	dw	0b0edh		;ldir
	xchg********************************
*								*
* Utility routine to output the message pointed at by (hl)	*
* terminated with a null.					*
*								*
*****************************************************************

message:mov	a,m		;Get a character of the message
	inx	h		;Bump text pointer
	ora	a		;Test for end
	rz			;Return if done
	push	h		;Save pointer to text
	mov	c,a		;Output character in C
	call	cout		;Output the character
	pop	h		;Restore the pointer
	jmp	message		;Continue until null port (on HDC4)
hdfunc	equ	hdorg+2			;Function port
hddata	equ	hdorg+3			;Data port

;	Status port (50)

tkzero	equ	01h			;Track zero
opdone	equ	02h			;Operation done
complt	equ	04h			;Seek complete
tmout	equ	08h			;Time out
wfault	equ	10h			;Write fault
drvrdy	equ	20h			;Drive ready
index	equ	40h			;Delta index

;	Control port (50)

hdfren	equ	01h			;Enable external drivers
hdrun	equ	02h			;Enable controllers state machine
hdclok	equ	04h			;Clock source control bit, high = disk
hdwprt	equ***************************************
*								*
* Device Specification Table for HDCA controller driver		*
*								*
*****************************************************************

hddst:	db	maxhd*hdlog		;Number of logical drives
	dw	hdwarm			;Warm boot
	dw	hdtran			;Sector translation
	dw	hdldrv			;First time select
	dw	hddrv			;General select
	dw	hdhome			;Home current selected drive
	dw	hdseek			;Seek to selected track
	dw	hdsec			;Select sector
	dw	hddma			;Set DMA address
	dw	hdreaddress
	inr	h
	shld	hdadd
	push	h
	push	psw
hdwrrd:	lxi	b,retries*100h+0	;Retry counter
hdwr:	push	b			;Save the retry count
	call	hdread			;Read the sector
	pop	b
	jnc	hdwrld			;Test for error
	dcr	b			;Update the error count
	jnz	hdwr			;Keep trying if not too many errors
	stc				;Error flag
	ret

hdtran:	mov	h,b			;Sector translation is handled via
	mov	l,c			;   physical sector header skewwing
	inx	h
	ret

hdldrv:	sta	hdcur			;Save logical disk
	call	divlog			;Divide by logical dis
	ret

*****************************************************************
*								*
* Return DPH pointer.  Enter with (de) with DPH base address	*
* and (a) with logical drive number.  Returns with DPH address	*
* in (hl).							*
*								*
*****************************************************************

retdph	mov	l,a		;Move logical drive into (l)
	mvi	h,0
	dad	h		;Multiply by 16 (size of DPH)
	dad	h
	dad	h
	dad	h
	dad	d		;(hl) = pointer to DPH
	ret

*********************************reached

*****************************************************************
*								*
* The following code is for the Diskus Hard disk		*
*								*
*****************************************************************

	if	hdca ne 0		;Want HDC3 or 4 controller included ?

hdorg	equ	50h			;Hard Disk Controller origin

hdstat	equ	hdorg			;Disk Status
hdcntl	equ	hdorg			;Disk Control
hdreslt	equ	hdorg+1			;Disk Results
hdcmnd	equ	hdorg+1			;Disk Commands
hdskomp	equ	hdorg+2			;Seek complete clear 	08h			;Write protect a drive

;	Result port (51)

retry	equ	02h			;Retry flag

;	Command port (51)

idbuff	equ	0			;Initialize data buffer pointer
rsect	equ	1			;Read sector
wsect	equ	5			;Write sector
isbuff	equ	8			;Initialize header buffer pointer

;	Function port (52)

pstep	equ	04h			;Step bit
nstep	equ	0ffh-pstep		;Step bit mask
null	equ	0fch			;Null command

;	Misc constants

hdrlen	equ	4			;Sector header length
seclen	equ	512			;Sector data length

**************************ad			;Read a sector
	dw	hdwrite			;Write a sector
	dw	nobad			;No bad sector map

hdwarm:	call	divlog			;Get physical drive number in (c)
	xra	a
	lxi	h,ccp-200h		;Initial DMA address
	push	h
	sta	head			;Select head zero
	inr	a			; 1 -> (a)
	push	psw			;Save first sector - 1
	call	hdd2			;Select drive
	mvi	c,0
	call	hdhome			;Home the drive
hdwrld:	pop	psw			;Restore sector
	pop	h			;Restore DMA address
	inr	a
	sta	hdsect
	cpi	13			;Past BDOS ?
	rz				;Yes, all done
	inr	h			;Update DMA ks per drive
	mov	a,c
	sta	hddisk			;Save new physical drive
	call	hdptr			;Get track pointers
	mov	a,m			;Get current track
	inr	a			;Check if -1
	jnz	hdl2			;Nope, allready accessed
	ori	null			;Select drive
	out	hdfunc
	mvi	a,hdfren+hdclok		;Enable drivers
	out	hdcntl
	mvi	c,239			;Wait 2 minutes for disk ready
	lxi	h,0
hdtdel:	dcx	h
	mov	a,h
	ora	l
	cz	dcrc
	jz	zret			;Drive not ready error
	in	hdstat			;Test if ready yet
	ani	drvrdy
	jnz	hdtdel

	if	not fujitsu
	lxi	h,0			;Time oCSIZ

dpbhd1	dw	1024		;CP/M sectors/track
	db	5		;BSH
	db	31		;BLM
	db	1		;EXM
	dw	2015		;DSM
	dw	511		;DRM
	db	0ffh		;AL0
	db	0ffh		;AL1
	dw	0		;CKS
	dw	64		;OFF
	db	3		;SECSIZ

dpbhd2	dw	1024		;CP/M sectors/track
	db	5		;BSH
	db	31		;BLM
	db	1		;EXM
	dw	2047		;DSM
	dw	511		;DRM
	db	0ffh		;AL0
	db	0ffh		;AL1
	dw	0		;CKS
	dw	127		;OFF
	db	3		;SECSIZ
	endif

	if	m10 ne 0
dpbhd0	dw	336		;CP/M sectors/track
	db	5		;BSH
	db	31		;BLM
	db	1		;EXM
	dw	1269		;DSM
	dw	511		;DRM
	db	db	31		;BLM
	db	1		;EXM
	dw	2036		;DSM
	dw	511		;DRM
	db	0ffh		;AL0
	db	0ffh		;AL1
	dw	0		;CKS
	dw	98		;OFF
	db	3		;SECSIZ

dpbhd2	dw	672		;CP/M sectors/track
	db	5		;BSH
	db	31		;BLM
	db	1		;EXM
	dw	1028		;DSM
	dw	511		;DRM
	db	0ffh		;AL0
	db	0ffh		;AL1
	dw	0		;CKS
	dw	195		;OFF
	db	3		;SECSIZ
	endif
	endif
	endif			;End of HD DPH's and DPB's

	if	maxmf ne 0

	dpbgen	mf, 0, 20, 3,  7, 0, 04fh,  63, 0c0h, 0, 16, 3, 2
	dpbgen	mf, 1, 40, 3,  7, 0, 0a4h,  63, 0c0h, 0, 16, 2, 3
	dpbs per cylinder.	*
* mwsectp = 72 * heads						*
*								*
* mwtrks is the total number of data cylinders.			*
* mwtrks = tracks - 1						*
*								*
*****************************************************************

	if	st506 ne 0
	mwsecpt	equ	288		;Sectors per track
	mwtrks	equ	152		;Total data tracks
	endif

	if	st412 ne 0
	mwsecpt	set	288
	mwtrks	set	305
	endif

	if	cm5619 ne 0
	mwsecpt	set	432
	mwtrks	set	305
	endif

dphdsk	set	0		;Generate DPH's for the HDDMA hard disks
	rept	ff	set	1			;Initial system track offset
trkoff	set	8192/(mwsecpt/8)+1	;The number of tracks in a partition
blocks	set	mwsecpt/8*mwtrks	;The number of blocks on the drive
psize	set	trkoff*(mwsecpt/8)	;The number of blocks in a partition
ldsk	set	0

	rept	blocks/8192	;Generate some 8 megabyte DPB's
	dpbgen	mw,%ldsk,%mwsecpt,5,31,1,2047,1023,0ffh,0ffh,0,%off,4
off	set	off+trkoff
blocks	set	blocks-psize
ldsk	set	ldsk+1
	endm
blocks	set	blocks/4
	if	blocks gt 256	;If there is any stuff left, then us/M version number
	db	cpmrev/10+'0'
	db	'.'
	db	(cpmrev mod 10)+'0'
	db	' '
	db	(revnum/10)+'A'-1
	db	(revnum mod 10)+'0'
	db	acr, alf

;
;	Print a message like:
;
;	 AB: DJDMA 8", CD: DJDMA 5 1/4", E: HDDMA M5
;

msdrv	set	0			;Start with drive A:

msbump	macro	ndrives			;Print a drive name
	if	dn gt 1
	db	', '
	endif
	rept	ndrives
	db	msdrv+'A'
msdrv	set	msdrv+1
	endm
	db	': '
	endm

prhex	macro	digit			;Write a byte in hex
	prnib	digit/10h
	prnib	digit
	endm

prnib	macro	0ffh		;AL0
	db	0ffh		;AL1
	dw	0		;CKS
	dw	1		;OFF
	db	3		;SECSIZ

dpbhd1	dw	336		;CP/M sectors/track
	db	5		;BSH
	db	31		;BLM
	db	1		;EXM
	dw	1280		;DSM
	dw	511		;DRM
	db	0ffh		;AL0
	db	0ffh		;AL1
	dw	0		;CKS
	dw	122		;OFF
	db	3		;SECSIZ
	endif

	if	m20 ne 0
dpbhd0	dw	672		;CP/M sectors/track
	db	5		;BSH
	db	31		;BLM
	db	1		;EXM
	dw	2036		;DSM
	dw	511		;DRM
	db	0ffh		;AL0
	db	0ffh		;AL1
	dw	0		;CKS
	dw	1		;OFF
	db	3		;SECSIZ

dpbhd1	dw	672		;CP/M sectors/track
	db	5		;BSH
	gen	mf, 2, 40, 4, 15, 1, 051h,  63,  80h, 0, 16, 2, 3
	dpbgen	mf, 3, 40, 4, 15, 1, 0a9h,  63,  80h, 0, 16, 2, 3

dn	set	0
	rept	maxmf
	dphgen	mf,%dn,dpbmf,%dn
dn	set	dn+1
	endm
	endif

	if	maxfd ne 0
dn	set	0
	rept	maxfd
	dphgen	fd,%dn,0,0
dn	set	dn+1
	endm
	endif

	if	maxdm ne 0
dn	set	0
	rept	maxdm
	dphgen	dm,%dn,0,0
dn	set	dn+1
	endm
	endif

	if	maxmw ne 0

*****************************************************************
*								*
* mwsectp is the number of 128 byte sectormaxmw
ldsk	set	0
	rept	mwlog
	dphgen	mw,%dphdsk,dpbmw,%ldsk
dphdsk	set	dphdsk+1
ldsk	set	ldsk+1
	endm
	endm

	if	mwpart ne 0	;Generate DPB's for a HDDMA hard disk

ldsk	set	0		;Use non-standard partitioning
tracks	set	mwtrks/mwlog	;Number of tracks per partition
dsm	set	mwsectp/8*tracks/4-1	;Number of groups per partition
off	set	1

	rept	mwlog
	dpbgen	mw,%ldsk,%mwsecpt,5,31,1,%dsm,1023,0ffh,0ffh,0,%off,4
off	set	off+tracks
ldsk	set	ldsk+1
	endm

	else			;Use standard partitioning

oe it
blocks	set	blocks-1
	dpbgen	mw,%ldsk,%mwsecpt,5,31,1,%blocks,1023,0ffh,0ffh,0,%off,4
	endif
	endif
	endif

buffer	equ	$

*****************************************************************
*								*
* Signon message output during cold boot.			*
*								*
*****************************************************************

prompt:	db	80h, clear		;Clean buffer and screen
	db	acr, alf, alf
	db	'Morrow Designs '
	db	'0'+msize/10		;CP/M memory size
	db	'0'+(msize mod 10)
	db	'K CP/M '		;CPdigit			;Write a digit in hex
temp	set	digit and 0fh
	if	temp < 10
	db	temp + '0'
	else
	db	temp - 10 + 'A'
	endif
	endm

dn	set	1			;Generate the drive messages

	rept	16			;Run off at least 16 drives

	if	dn eq hdorder		;Generate the HDCA's message
	msbump	maxhd*hdlog
	db	'HDCA '
	if	maxhd gt 1
	db	'(', maxhd+'0', ')'
	endif
	if	m10 ne 0
	if	m10m ne 0
	db	'Memorex'
	else
	db	'Fujitsu'
	endif
	db	' M10'
	endif
	if	m20 ne 0
	db	'Fujitsu M20'
	endif
	if	m26 ne 0
	db	'Shugart M2ne revolution of the drive
	mvi	c,index
	in	hdstat
	ana	c
	mov	b,a			;Save current index level in B
hdinxd1:in	hdstat
	ana	c
	cmp	b			;Loop untill index level changes
	jz	hdinxd1
hdindx2:inx	h
	in	hdstat			;Start counting untill index returns to
	ana	c			;	previous state
	cmp	b
	jnz	hdindx2

	if	m10			;Memorex M10's have 40 ms head settle
	dad	h			;HL*2
	endif

	if	m26			;Shugart M26's have 30 ms head settle
	xra	a			;HL/2 + HL (same as HL*1.5)
	mov	a,h
	rar
	mov	d,a
	mov	a,l
	rar
ren+hdrun+hdclok+hdwprt	;Write protect
	out	hdcntl
	ret

hdhome:	call	hdptr			;Get track pointer
	mvi	m,0			;Set track to zero
	in	hdstat			;Test status
	ani	tkzero			;At track zero ?
	rz				;Yes

	if	not fujitsu
hdstepo:in	hdstat			;Test status
	ani	tkzero			;At track zero ?
	jz	hddelay
	mvi	a,1
	stc
	call	accok			;Take one step out
	jmp	hdstepo

	else

	xra	a
	jmp	accok
	endif

	if	not fujitsu
hddelay:lhld	settle			;Get hddelay
deloop:	dcx	h			;Wait 20ms
	mov	a,h
	ora	l
	inx	nc			;Output high step line
	dcr	b			;Update repeat count
	jnz	sloop			;Keep going the required # of tracks
	jmp	wsdone

hddma:	mov	h,b			;Save the DMA address
	mov	l,c
	shld	hdadd
	ret

wsdone:	in	hdstat			;Wait for seek complete to finish
	ani	complt
	jz	wsdone
	in	hdskomp			;Clear sdone bit on an HDCA4
	ret

	if	m26
hdsec:	mvi	a,01fh			;For compatibility with Cbios revs.
					;  2.3 and 2.4
	ana	c			;Mask in sector number (0-31)
	cz	getspt			;Translate sector 0 to sector 32
	sta	hdsecall	process
	rc
	xra	a
	out	hdcmnd
	mvi	b,seclen/4
	lhld	hdadd
	in	hddata
	in	hddata
rtloop:	in	hddata			;Move four bytes
	mov	m,a
	inx	h
	in	hddata
	mov	m,a
	inx	h
	in	hddata
	mov	m,a
	inx	h
	in	hddata
	mov	m,a
	inx	h
	dcr	b
	jnz	rtloop
	ret

hdwrite:call	hdprep			;Prepare header
	rc
	xra	a
	out	hdcmnd
	lhld	hdadd
	mvi	b,seclen/4
wtloop:	mov	a,m			;Move 4 bytes
	out	hddata
	inx	h
	mov	a,m
	out	hddata
	inx	h
	mov	a,m
	out	hddata
	inx	h
	mov	a,m
	out	hddata
	inx	h
	d
	ori	0ch
	out	hdfunc
	lda	head
	out	hddata			;Form head byte
	call	hdptr			;Get pointer to current drives track
	mov	a,m			;Form track byte
	out	hddata
	ana	a
	mvi	b,80h
	jz	zkey
	mvi	b,0
zkey:	lda	hdsect			;Form sector byte
	out	hddata
	mov	a,b
	out	hddata
	mvi	a,hdfren+hdrun+hdclok	;Write protect
	out	hdcntl
	mvi	a,hdfren+hdrun+hdclok+hdwprt	;Write protect
	out	hdcntl
	xra	a
	ret

hdptr:	lhld	hddisk			;Get a pointer to the current drives
	mvi	h,0			;   track position
	xchg
	lxi	mov	e,a
	dad	d
	endif

	shld	settle			;Save the count for timeout delay
	endif

	call	hdhome

hdl2:	lda	hdcur			;Load logical drive
	lxi	d,dphhd0		;Start of hard disk DPH's
	mvi	c,3			;Hard disk sector size equals 512 bytes
	jmp	retdph

dcrc:	dcr	c			;Conditional decrement C routine
	ret

divlog:	mvi	c,0
divlx:	sui	hdlog
	rc
	inr	c
	jmp	divlx

hddrv:	sta	hdcur
	call	divlog			;Get the physical drive #
hdd2:	mov	a,c
	sta	hddisk			;Select the drive
	ori	null
	out	hdfunc
	mvi	a,hdfh
	dcx	h
	jnz	deloop
	ret
	endif

hdseek:	call	hdptr			;Get pointer to current track
	mov	e,m			;Get current track
	mov	m,c			;Update the track
	mov	a,e			;Need to seek at all ?
	sub	c
	rz
	cmc				;Get carry into direction
	jc	hdtrk2
	cma
	inr	a
	if	fujitsu
hdtrk2:	jmp	accok
	else
hdtrk2:	call	accok
	jmp	hddelay
	endif

accok:	mov	b,a			;Prep for build
	call	build
sloop:	ani	nstep			;Get step pulse low
	out	hdfunc			;Output low step line
	ori	pstep			;Set step line high
	out	hdfuct			;Save translated sector number (1-32)
	mvi	a,0e0h			;Get the head number
	ana	c
	rlc
	rlc
	rlc
	sta	head			;Save the head number
getspt:	mvi	a,hdspt
	ret

	else

hdsec:	mov	a,c
	call	divspt
	adi	hdspt
	ana	a
	cz	getspt
	sta	hdsect
	mov	a,c
	sta	head
getspt:	mvi	a,hdspt
	dcr	c
	ret

divspt:	mvi	c,0
divsx:	sui	hdspt
	rc
	inr	c
	jmp	divsx
	endif

hdread:	call	hdprep
	rc
	xra	a
	out	hdcmnd
	cma
	out	hddata
	out	hddata
	mvi	a,rsect			;Read sector command
	out	hdcmnd
	dcr	b
	jnz	wtloop
	mvi	a,wsect			;Issue write sector command
	out	hdcmnd
	call	process
	rc
	mvi	a,wfault
	ana	b
	stc
	rz
	xra	a
	ret

process:in	hdstat			;Wait for command to finish
	mov	b,a
	ani	opdone
	jz	process
	mvi	a,hdfren+hdrun+hdclok	;Write protect
	out	hdcntl
	in	hdstat
	ani	tmout			;Timed out ?
	stc
	rnz
	in	hdreslt
	ani	retry			;Any retries ?
	stc
	rnz
	xra	a
	ret

hdprep:	in	hdstat
	ani	drvrdy
	stc
	rnz
	mvi	a,isbuff		;Initialize pointer
	out	hdcmnd
	call	buil	h,hdtrak
	dad	d
	ret

build:	lda	head			;Build a controller command byte
	ral
	ral
	ral
	ral
	lxi	h,hddisk
	ora	m
	xri	0f0h
	ret

hdcur:	db	0			;Current logical disk
hdadd:	dw	0			;DMA address
hddisk:	db	0			;Current physical disk number
head:	db	0			;Current physical head number
hdsect:	db	0			;Current physical sector number

hdtrak:	db	0ffh			;Track pointer for each drive
	db	0ffh			;All drive default to an uncalibrated
	db	0ffh			;   state (ff)
	db	0ffh

settle:	dw	0			;Time del;Load sector address
	sta	dmarg3

	if	0		;Set to 1 for MW error reporter
mwissue	call	mwdoit		;Do desired operation
	rnc			;Do nothing if no error
	push	psw		;Save error info
	call	hexout		;Print status
	call	dspout		;   and a space
	lxi	h,dmachan
	mvi	c,16		;16 bytes of status
mwerr:	push	b
	push	h
	mov	a,m
	call	hexout		;Print a byte of the status line
	call	spout
	pop	h
	pop	b
	inx	h		;Bump command channel pointer
	dcr	c
	jnz	mwerr
	mvi	c,0ah		;Terminate with a CRLF
	call	pout
	mvii	d,0		;Time out counter (65536 retries)
mwiloop	mov	a,m		;Get status
	ora	a		;Set up CPU flags
	rm			;Return no error (carry reset)
	stc
	rnz			;Return error status
	xthl			;Waste some time
	xthl
	xthl
	xthl
	dcx	d		;Bump timeout counter
	mov	a,d
	ora	e
	jnz	mwiloop		;Loop if still busy
	stc			;Set error flag
	ret

mwptr	lda	mwdrive		;Get currently select drives track address
	rlc
	mov	e,a
	mvi	d,0
	lxi	h,mwtab
	dad	d		;Offset into track table
	ret

mwtran:	mov	h,b
	mov	l,c
	inx		equ	$		;Command channel area
dmasel0	db	0		;Drive select
dmastep	dw	0		;Relative step counter
dmasel1	db	0		;Head select
dmadma	dw	0		;DMA address
	db	0		;Extended address
dmarg0	db	0		;First argument
dmarg1	db	0		;Second argument
dmarg2	db	0		;Third argument
dmarg3	db	0		;Fourth argument
dmaop	db	0		;Operation code
dmastat	db	0		;Controller status byte
dmalnk	dw	dmachan		;Link address to next command channel
	db	0		;extended address

	endif

***********************************************ntains CP/M sector

error:	db	0		;Buffer's error status flag
bufdrv:	db	0		;Drive that buffer belongs to
buftrk:	dw	0		;Track that buffer belongs to
bufsec:	dw	0		;Sector that buffer belongs to

alttrk:	dw	0		;Alternate track
altsec:	dw	0		;Alterante sector
lastdrv:db	0		;Last selected drive

*****************************************************************
*								*
* DPB and DPH area.						*
*								*
*****************************************************************

	if	maxhd ne 0

ders that are used for the system.  If the number of	*
* 'system tracks' is not one then the initial value of		*
* 'off' should be adjusted accordingly.				*
*								*
* hdtrks = tracks - 1						*
*								*
*****************************************************************

	if	m10 ne 0
	hdsectp	equ	336		;Sectors per track
	hdtrks	equ	243		;Total data tracks
	endif

	if	m20 ne 0
	hdsectp	equ	672
	hdtrks	equ	243
	endif

	if	m26 ne 0
	hdsectp	equ	1024
	hdtrks	equ	201
	endif

ldsk	set	0		c,0dh
	call	pout
	pop	psw		;Restore error status
	ret

dspout:	call	spout		;Print two spaces
spout:	mvi	c,' '		;Print a space
	jmp	pout

hexout:	push	psw		;Poor persons number printer
	rrc
	rrc
	rrc
	rrc
	call	nibout
	pop	psw
nibout:	ani	0fh
	adi	'0'
	cpi	'9'+1
	jc	nibok
	adi	27h
nibok:	mov	c,a
	jmp	pout

mwdoit	equ	$

	else

mwissue	equ	$		;Do a disk command, handle timeouts + errors

	endif

	lxi	h,dmastat	;Clear status byte
	mvi	m,0
	out	attn		;Start the controller
	lxh
	ret

mwneghl:mov	a,h
	cma
	mov	h,a
	mov	a,l
	cma
	mov	l,a
	inx	h
	ret

mwhlmde:xchg
	call	mwneghl
	xchg
	dad	d
	ret

mwhlcde:mov	a,h
	cmp	d
	rnz
	mov	a,l
	cmp	e
	ret

mwtab	equ	$		;Collection of track addresses
	rept	maxmw
	db	0ffh		;Initialize to (way out on the end of the disk)
	db	0ffh
	endm
	db	0ffh

mwcurl	db	0		;Current logical drive
mwdrive	db	0ffh		;Currently selected drive
mwhead	db	0		;Currently selected head
mwsectr	db	0		;Currently selected sector

dmachan******************
*								*
* Cbios ram locations that don't need initialization.		*
*								*
*****************************************************************

	if	nostand ne 0	;Unallocated writting variables
unaloc:	db	0		;Unallocated write in progress flag
oblock:	dw	0		;Last unallocated block number written
unadrv:	db	0		;Drive that the block belongs to
	endif

cpmsec:	dw	0		;CP/M sector #

cpmdrv:	db	0		;CP/M drive #
cpmtrk: dw	0		;CP/M track #
truesec:dw	0		;Physical sector that cophdsk	set	0		;Generate DPH's for the HDCA hard disks
	rept	maxhd
ldsk	set	0
	rept	hdlog
	dphgen	hd,%dphdsk,dpbhd,%ldsk
ldsk	set	ldsk+1
dphdsk	set	dphdsk+1
	endm
	endm

	if	hdpart ne 0	;Use non-standard partitioning

*****************************************************************
*								*
* hdsectp is the number of 128 byte sectors per cylinder.	*
*								*
* hdtrks is the total number of data cylinders.  Eg.  it is	*
* the number of cyliders on the drive minus the number of	*
* cylind	;Use non-standard partitioning
tracks	set	hdtrks/hdlog	;Number of tracks per partition
dsm	set	hdsectp/8*tracks/4-1	;Number of groups per partition
off	set	1

	rept	hdlog
	dpbgen	hd,%ldsk,%hdsectp,5,31,1,%dsm,511,0ffh,0ffh,0,%off,3
off	set	off+tracks
ldsk	set	ldsk+1
	endm

	else			;Else use standard DPB's

	if	m26 ne 0
dpbhd0	dw	1024		;CP/M sectors/track
	db	5		;BSH
	db	31		;BLM
	db	1		;EXM
	dw	2015		;DSM
	dw	511		;DRM
	db	0ffh		;AL0
	db	0ffh		;AL1
	dw	0		;CKS
	dw	1		;OFF
	db	3		;SEay constant for head settle

	endif

*****************************************************************
*								*
* The following equates relate the Morrow Designs 2D/B		*
* controller. If the controller is non standard (0F800H)	*
* only the FDORIG equate need be changed.			*
*								*
*****************************************************************

	if	maxfd ne 0	;Include Discus 2D ?
fdorig	equ	0f000H		;Origin of Disk Jockey PROM
fdboot	equ	fdorig+00h	;Disk Jockey 2D initialization
fdcin	stat	equ	fdorig+21h	;Disk Jockey 2D terminal status routine
fdstat	equ	fdorig+27h	;Disk Jockey 2D status routine
fderr	equ	fdorig+2ah	;Disk Jockey 2D error, flash led
fdden	equ	fdorig+2dh	;Disk Jockey 2D set density routine
fdside	equ	fdorig+30h	;Disk Jockey 2D set side routine
fdram	equ	fdorig+400h	;Disk Jockey 2D RAM address
dblsid	equ	20h		;Side bit from controller
io	equ	fdorig+3f8h	;Start of I/O registers
dreg	equ	io+1
cmdreg	equ	io+4
clrcmd	equ	0d0h

***************************************
	dw	nobad		;No bad sector map

*****************************************************************
*								*
* Floppy disk warm boot loader					*
*								*
*****************************************************************

fdwarm:	mov	c,a
	call	fdsel		;Select drive A
	mvi	c,0		;Select side 0
	call	fdside
wrmfail:call	fdhome		;Track 0, single density
	jc	wrmfail		;Loop if error

				;The next block of code re-initializes
				;   the warm boot loader for track 0
	mvi	a,5-2		;Initialize the 
	lxi	h,ccp-100h	;Memory address of sector - 100h
newdma	equ	$-2
	lxi	d,100h		;Update DMA address
	dad	d
nowrp:	shld	newdma		;Save the updated DMA address
	mov	b,h
	mov	c,l
	call	fddma		;Set up the new DMA address
	lxi	b,retries*100h+0;Maximum # of errors, track #
wrmfred:push	b
	call	fdseek		;Set up the proper track
	call	fdread		;Read the sector
	pop	b
	jnc	t0boot		;Continue if no error
	dcr	b
	jnz	wrmfred		;Keep trying if error
	jmp	fderr		;Too many errors, flash the light

;Load trackdcx	b		;Bump counter
	mov	a,b		;Check if done
	ora	c
	jnz	wrmcpy		;   if not, loop

	lxi	b,ccp+0f00h	;Address for sector 2
	lxi	d,10*100h+2	;Retry count + sector 2
	call	wrmread

	xra	a		;Clear error indicator
	ret

wrmread:push	d
	call	fddma		;Set DMA address
	pop	b
	call	fdsec		;Set sector
wrmfrd:	push	b		;Save error count
	call	fdread		;Read a sector
	jc	wrmerr		;Do retry stuff on error
	call	fdstat		;Sector size must be 1024 bytes
	ani	0ch		;Mask length bits
	sui	0ch		;Carry (error)equ	fdorig+03h	;Disk Jockey 2D character input routine
fdcout	equ	fdorig+06h	;Disk Jockey 2D character output routine
fdhome	equ	fdorig+09h	;Disk Jockey 2D track zero seek
fdseek	equ	fdorig+0ch	;Disk Jockey 2D track seek routine
fdsec	equ	fdorig+0fh	;Disk Jockey 2D set sector routine
fddma	equ	fdorig+12h	;Disk Jockey 2D set DMA address
fdread	equ	fdorig+15h	;Disk Jockey 2D read routine
fdwrite	equ	fdorig+18h	;Disk Jockey 2D write routine
fdsel	equ	fdorig+1bh	;Disk Jockey 2D select drive routine
fdt**************************
*								*
* Device Specification Table for the Disk Jockey 2D/B		*
*								*
*****************************************************************

fddst:	db	maxfd		;Number of logical drives
	dw	fdwarm		;Warm boot
	dw	fdtran		;Sector translation
	dw	fdldrv		;Select drive 1
	dw	fdsel2		;Select drive 2
	dw	fdlhome		;Home drive
	dw	fdseek		;Seek to specified track
	dw	fdssec		;Set sector
	dw	fddma		;Set DMA address
	dw	fdread		;Read a sector
	dw	fdwrite		;Write a sectorsector to read - 2
	sta	newsec
	lxi	h,ccp-100h	;First revolution DMA - 100h
	shld	newdma
				;Load all of track 0

t0boot:	mvi	a,5-2		;First sector - 2
newsec	equ	$-1
	inr	a		;Update sector #
	inr	a
	cpi	27		;Size of track in sectors + 1
	jc	nowrap		;Skip if not at end of track
	jnz	t1boot		;Done with this track
	sui	27-6		;Back up to sector 6
	lxi	h,ccp-80h	;Memory address of sector - 100h
	shld	newdma
nowrap:	sta	newsec		;Save the updated sector #
	mov	c,a
	call	fdsec		;Set up the sector 1, sector 1, sector 3 (partial), sector 2 (1024 byte sectors)

t1boot:	mvi	c,1		;Track 1
	call	fdseek
	lxi	b,ccp+0b00h	;Address for sector 1
	lxi	d,10*100h+1	;Retry count + sector 1
	call	wrmread
	lxi	b,ccp+0f00h	;Address for sector 2
	lxi	d,10*100h+3	;Retry count + sector 3
	call	wrmread

	lxi	b,0300h		;Size of partial sector
	lxi	d,ccp+1300h	;Address for sector 3
	lxi	h,ccp+0f00h	;Address of sector 3

wrmcpy:	mov	a,m		;Get a byte and
	stax	d		;   save it
	inx	d		;Bump pointers
	inx	h
	 will be set if < 0c0h
wrmerr:	pop	b		;Fetch retry count
	rnc			;Return if no error
	dcr	b		;Bump error count
	jnz	wrmfrd
	jmp	fderr		;Error, flash the light

fdtran:	inx	b
	push	d		;Save table address
	push	b		;Save sector #
	call	fdget		;Get DPH for current drive
	lxi	d,10		;Load DPH pointer
	dad	d
	mov	a,m
	inx	h
	mov	h,m
	mov	l,a
	mov	a,m		;Get # of CP/M sectors/track
	ora	a		;Clear carry
	rar			;Divide by two
	sub	c		;Subtract sector number
	push	psw		;Save adjusted sector
	jm	sid
	sta	mwhead		;Select head zero
	sta	mwsectr		;Select sector 1
	lxi	h,buffer	;Load sector 1 into buffer
	shld	dmadma
	call	mwwread		;Read CCP into buffer
	rc			;Return if error
	lxi	d,buffer+200h
	lxi	h,ccp
	lxi	b,200h		;Move 200h bytes
	call	movbyt
	lxi	h,ccp-200h	;Initial DMA address
	push	h
	xra	a
	push	a		;Save first sector -1
mwwlod	pop	psw		;Restore sector
	pop	h		;Restore DMA address
	inr	a
	sta	mwsectr
	cpi	6		;Past BDOS ?
	rz			;Yes, all done
	inr	h		;Update DMA address by 1024	call	mwdrv		;Select drive
	jc	zret		;Select error

	call	mwstat		;Get drive status
	ani	dready		;Check if drive ready
	jnz	zret

	call	mwhome		;Home drive

	lxi	d,dphmw0	;Start of hard disk DPH's
	lda	mwcurl
	mov	l,a
	mvi	h,0
	dad	h
	dad	h
	dad	h
	dad	h
	dad	d		;(hl) = pointer to DPH
	mvi	c,4		;Return sector size of 1024
	ret

mwdrv	sta	mwcurl
	call	mwdlog
	mov	a,c
	sta	mwdrive		;Save new selected drive
mwsel	mvi	a,dmanoop
	jmp	mwprep		;Execute disk command

mwdlog:	mvi	c,0
mwl 0
	call	mwseek		;Recal slowly
	jmp	mwreset		;Back to fast stepping mode

mwbad:	lxi	h,mwbtab	;Return pointer to bad sector location
	ret

mwbtab:	dw	0		;Track 0
	dw	19		;Head 2, sector 0  = (2 * SPT + 0) + 1

mwseek	call	mwptr		;Get track pointer
	mov	e,m		;Get old track number
	inx	h
	mov	d,m
	dcx	h
	mov	m,c		;Store new track number
	inx	h
	mov	m,b
	mov	l,c		;Build cylinder word
	mov	h,b
	shld	dmarg0		;Set command channel cylinder number
	mov	a,d
	inr	a
	lxi	h,0ffffh
	jnz	mwskip0
a
	ret

mwsec	mov	a,c		;Load sector number
	dcr	a		;Range is actaully 0-16
	call	mwdspt		;Figure out head number -> (c)
	adi	mwspt		;Make sector number
	sta	mwsectr
	mov	a,c
	sta	mwhead		;Save head number
	ret

mwdspt	mvi	c,0		;Clear head counter
mwdsptx	sui	mwspt		;Subtract a tracks worth of sectors
	rc			;Return if all done
	inr	c		;Bump to next head
	jmp	mwdsptx

mwreset	lhld	chan		;Save the command channel for a while
	shld	tempb
	lda	chan+2
	sta	tempb+2
	out	reset		;Send reset pulHead settle delay
	inx	h
	mvi	m,sectsiz	;Sector size code
	inx	h
	mvi	m,dmalcon	;Load constants command
	call	mwissue		;Do load constants
	pop	h		;Restore the track number
	shld	dmarg0
	push	psw		;Save status
	lhld	tempb		;Restore memory used for the channel pointer
	shld	chan
	lda	tempb+2
	sta	chan+2
	pop	psw
	ret

mwread	mvi	a,dmaread	;Load disk read command
	jmp	mwprep

mwwrite	mvi	a,dmawrit	;Load disk write command

mwprep:	sta	dmaop		;Save command channel op code

	mvi	c,band1
	 bytes
	inr	h
	inr	h
	inr	h
	shld	dmadma
	push	h
	push	psw
	call	mwwread		;Read in a sector
	jnc	mwwlod
	ret			;Return with error

mwwread	mvi	c,retries	;Retry counter
mwwerr	push	b		;Save the retry count
	call	mwread		;Read the sector
	pop	b
	rnc
	dcr	c		;Update the error count
	jnz	mwwerr		;Keep trying if not too many errors
	stc			;Set error flag
	ret

mwldrv	sta	mwcurl		;Save current logical drive
	call	mwreset		;Reset controller card
	jc	zret		;Controller failure

	lda	mwcurl
lx:	sui	mwlog
	rc
	inr	c
	jmp	mwllx

mwstat	mvi	a,dmassta	;Sense status operation code
	jmp	mwprep		;Execute disk command

mwhome	call	mwreset		;Reset controller, do a load constants
	lxi	h,dmarg1	;Load arguments
	mvi	m,steprcl	;Load step delay (slow rate)
	inx	h
	mvi	m,headdly	;Head settle delay
	call	mwissue		;Do load constants again
	call	mwptr		;Get pointer to current cylinder number
	mvi	m,0ffh		;Fake at cylinder 65535 for max head travel
	inx	h
	mvi	m,0ffh
	lxi	b,0		;Seek to cylinder	mvi	c,stepout
	jmp	mwskip

mwskip0:mov	h,b		;(hl) = new track, (de) = old track
	mov	l,c
	call	mwhlmde
	mvi	c,stepout
	mov	a,h
	ani	80h		;Check hit bit for negitive direction
	jnz	mwsout		;Step in
	mvi	c,0
	jmp	mwskip
mwsout:	call	mwneghl
mwskip:	shld	dmastep
	lda	mwdrive
	ora	c
	sta	dmasel0

	mvi	a,dmanoop	;No-operation command for the channel
	call	mwprep		;Step to proper track
	lxi	h,0		;Clear step counter
	shld	dmastep
	ret

mwdma	mov	h,b		;Set DMA address
	mov	l,c
	shld	dmadmse to controller
	lxi	h,dmachan	;Address of command channel
	shld	chan		;Default channel address
	xra	a
	sta	chan+2		;Clear extended address byte
	shld	40h		;Set up a pointer to the command channel
	sta	42h
	lhld	dmarg0		;Save the track number
	push	h
	lxi	h,dmasel1	;Load arguments
	lda	mwdrive		;Get the currently selected drive
	ori	03ch		;Raise *step and *dir
	mov	m,a		;Save in drive select register
	lxi	d,5		;Offset to dmarg1
	dad	d
	mvi	m,stepdly	;Load step delay
	inx	h
	mvi	m,headdly	;lhld	dmarg0
	lxi	d,precomp
	call	mwhlcde
	jc	mwpreps

	mvi	c,band2
	lxi	d,lowcurr
	call	mwhlcde
	jc	mwpreps

	mvi	c,band3		;cylinder > low_current
mwpreps	lda	mwhead		;Load head address
	sta	dmarg2
	cma			;Negative logic for the controller
	ani	7		;3 bits of head select
	rlc			;Shove over to bits 2 - 4
	rlc
	ora	c		;Add on low current and precomp bits
	mov	c,a
	lda	mwdrive		;Load drive address
	ora	c		;Slap in drive bits
	sta	dmasel1		;Save in command channel head select
	lda	mwsectr		etwo
sidea:	pop	psw		;Discard adjusted sector
	pop	b		;Restore sector requested
	pop	d		;Restore address of xlt table
sideone:xchg			;hl <- &(translation table)
	dad	b		;bc = offset into table
	mov	l,m		;hl <- physical sector
	mvi	h,0
	ret

sidetwo:call	fdgsid		;Check out number of sides
	jz	sidea		;Single sided
	pop	psw		;Retrieve adjusted sector
	pop	b
	cma			;Make sector request positive
	inr	a
	mov	c,a		;Make new sector the requested sector
	pop	d
	call	sideone
	mvi	a,80h		;Side two boad controller RAM
	mvi	a,0ffh		;Start 1791
	sta	dreg
	mvi	a,clrcmd	;1791 reset
	sta	cmdreg
	mvi	a,1		;Set 2D initialized flag
	sta	flopflg

flopok:	call	flush		;Flush buffer since we are using it
	lda	fdlog		;Select new drive
	mov	c,a
	call	fdsel
	call	fdlhome		;Recalibrate the drive
	lxi	h,1		;Select sector 1 of track 2
	shld	truesec
	inx	h
	shld	cpmtrk
	xra	a		;Make sure we are doing a read
	sta	rdwr
	call	fill		;Fill in buffer with sector
	jc	zret		;Test for error return
	call	fdsta	dblsid		;Check double sided bit
	mov	m,a		;Save sides flag
	lxi	d,dpb128s	;Base for single sided DPB's
	jz	sideok
	lxi	d,dpb128d	;Base of double sided DPB's
sideok:	xchg
	pop	d		;(HL) -> DPB base, (DE) -> &DPH.DPB
	pop	psw		;Offset to correct DPB
	ral
	ral			;Make 0, 10, 20, 30
	mov	c,a
	mvi	b,0		;Make offset
	dad	b		;(hl) is now a DPB pointer
	xchg			;Put proper DPB address in DPH.DPB
	mov	m,e
	inx	h
	mov	m,d
	lxi	h,15		;Offset to DPB.SIZ
	dad	d
	mov	c,m		;Fetch sector size code
fdget:o proper entry
	pop	d
	mov	a,m		;Set up flags
	ora	a
	ret

fdinit:	dw	0		;Initialization bytes loaded onto 2D/B
	dw	1800h		;Head loaded timeout
	dw	0		;DMA address
	db	0		;Double sided flag
	db	0		;Read header flag
	db	07eh		;Drive select constant
	db	0		;Drive number
	db	8		;Current disk
	db	0		;Head loaded flag
	db	9		;Drive 0 parameters
	db	0ffh		;Drive 0 track address
	db	9		;Drive 1 parameters
	db	0ffh		;Drive 1 track address
	db	9		;Drive 2 parameters
	db	0ffh		;Drive 2 track addre	*
* Xlts is a table of address that point to each of the xlt	*
* tables for each sector size.					*
*								*
*****************************************************************

xlts:	dw	xlt128		;Xlt for 128 byte sectors
	dw	xlt256		;Xlt for 256 byte sectors
	dw	xlt512		;Xlt for 512 byte sectors
	dw	xlt124		;Xlt for 1024 byte sectors

*****************************************************************
*								*
* Xlt tables (sector skew tables) for CP/M 2.0. These tables	*
* define the sector it
	ora	h		;	and sector
	mov	h,a
	ret

fdldrv:	sta	fdlog		;Save logical drive
	mov	c,a		;Save drive #
	mvi	a,0		;Have the floppies been accessed yet ?
flopflg	equ	$-1
	ana	a
	jnz	flopok

	mvi	b,17		;Floppies havn't been accessed
	lxi	h,fdboot	;Check if 2D controller is installed
	mvi	a,(jmp)
clopp:	cmp	m		;Must have 17 jumps
	jnz	zret
	inx	h
	inx	h
	inx	h
	dcr	b
	jnz	clopp
	lxi	d,fdinit	;Initialization sequence
	lxi	h,fdorig+7e2h	;Load address
	lxi	b,30		;Byte count
	call	movbyt		;Lt		;Get status on current drive
	sta	fdldst		;Save drive status
	ani	0ch		;Mask in sector size bits
	push	psw		;Used to select a DPB
	rar
	lxi	h,xlts		;Table of XLT addresses
	mov	e,a
	mvi	d,0
	dad	d
	push	h		;Save pointer to proper XLT
	call	fdget		;Get pointer to proper DPH
	pop	d
	lxi	b,2		;Copy XLT pointer into DPH
	call	movbyt
	lxi	d,8		;Offset to DPB pointer in DPH
	dad	d		;HL <- &DPH.DPB
	push	h
	call	fdgsid		;Get pointer to side flag table entry
	lda	fdldst		;Get drive status
	ani	lda	fdlog		;Return proper DPH
	lxi	d,dphfd0
	jmp	retdph

fdsel2:	sta	fdlog
	mov	c,a
	jmp	fdsel

fdlhome:mvi	c,0		;Select side 0
	call	fdside
	jmp	fdhome		;Do actual home

fdssec:	push	b		;Save sector number
	mov	a,b		;Check side select bit
	rlc			;Move high bit to bit zero
	ani	1
	mov	c,a
	call	fdside		;Call select side 0 = side A, 1 = Side B
	pop	b
	jmp	fdsec

fdgsid:	lxi	h,fdlsid	;Side flag table
	lda	fdlog		;Drive number
	push	d
	mov	e,a		;Make offset
	mvi	d,0
	dad	d		;Offset tss
	db	9		;Drive 3 parameters
	db	0ffh		;Drive 3 track address
	db	9		;Current parameters
	db	0		;Side desired
	db	1		;Sector desired
	db	0		;Track desired

	db	0		;Header image, track
	db	0		;Sector
	db	0		;Side
	db	0		;Sector
	dw	0		;CRC

fdlog:	db	0
fdldst:	db	0		;Floppy drive status byte

fdlsid:	rept	maxfd
	db	0ffh		;Double sided flag 0 = single, 1 = double
	endm
	endif

	if	(maxfd ne 0) or (maxdm ne 0)

*****************************************************************
*							translation that occurs when mapping CP/M	*
* sectors to physical sectors on the disk. There is one skew	*
* table for each of the possible sector sizes. Currently the	*
* tables are located on track 0 sectors 6 and 8. They are	*
* loaded into memory in the Cbios ram by the cold boot routine.	*
*								*
*****************************************************************

xlt128:	db	0
	db	1,7,13,19,25
	db	5,11,17,23
	db	3,9,15,21
	db	2,8,14,20,26
	db	6,12,18,24
	db	4,10,16,22

xlt256:	db	0
	i	m,gstat		;Set up read status
	inx	h
	lda	lldrv		;Get last selected drive
	mov	m,a		;Store drive in command
	inx	h		;Skip over returned status
	inx	h
	inx	h
	call	docmd		;Issue command
	lda	llss		;Get side bit of last operation
	ani	80h
	rrc			;Move to bit 7
	mov	c,a
	lxi	h,dmchan+1	;Point to drive
	mov	a,m		;Load drive
	ora	c
	ani	4		;Mask upper drive select bit for 5 1/4
	rlc
	rlc			;Move to bit 4
	ora	m		;Put together with lower drive bits
	ora	c
	mov	c,a
	inx	h
	mvi	a,10h		;Doubleh
	cmc
	ret

;
;	Execute a DJDMA command, no command status is returned
;
;	Entry:
;		DE = offset to the halt status
;		HL = pointer to the start of the command
;
;	Returns:
;		nothing
;

dmdoit:	mvi	a,bracha	;Branch channel command
	sta	dmchan
	shld	dmchan+1	;Load command vector
	xra	a		;Clear extended address
	sta	dmchan+3

	dad	d		;Offset to the halt status
	mov	m,a		;Clear the halt status indicator

	out	dmkick		;Start the controller

dmwait:	ora	m		;Wait for the operation comp**************
*								*
* The follwing equates are for the HDDMA hard disk controller	*
*								*
*****************************************************************

	if	maxmw ne 0	;HDDMA controller present ?
	if	st506		;Specifications for a Seagate Technology 506
cyl	equ	153		;Number of cylinders
heads	equ	4		;Number of heads per cylinder
precomp	equ	64		;Cylinder to start write precomensation
lowcurr	equ	128		;Cylinder to start low current
stepdly	equ	30		;Step delay (0-12.7 milliseconds)
sors
				; 1 =  256 byte sectors
				; 3 =  512 byte sectors
				; 7 = 1024 byte sectors (default)
				; f = 2048 byte sectors

				;Define controller commands
dmaread	equ	0		;Read sector
dmawrit	equ	1		;Write sector
dmarhed	equ	2		;Find a sector
dmawhed	equ	3		;Write headers (format a track)
dmalcon	equ	4		;Load disk parameters
dmassta	equ	5		;Sense disk drive status
dmanoop	equ	6		;Null controller operation

reset	equ	54h		;Reset controller
attn	equ	55h		;Send a controller attention

chan		*
*****************************************************************

mwdst:	db	maxmw*mwlog	;Number of logical drives
	dw	mwwarm		;Warm boot
	dw	mwtran		;Sector translation
	dw	mwldrv		;Select logical drive 1 (First time select)
	dw	mwdrv		;Select logical drive 2 (General select)
	dw	mwhome		;Home current selected drive
	dw	mwseek		;Seek to selected track
	dw	mwsec		;Select sector
	dw	mwdma		;Set DMA address
	dw	mwread		;Read a sector
	dw	mwwrite		;Write a sector
	if	heads > 2	;Test if drive  density bit
	ana	m
	rlc			;20h
	rlc			;40h
	rlc			;80h for density bit
	ora	c
	mov	c,a
	inx	h
	mvi	a,3		;Sector length mask
	ana	m		;And in
	rlc			;Move to bits 2 & 3
	rlc
	ora	c
	mov	c,a
	inx	h
	mvi	a,4		;Mask for double sided bit
	ana	m
	rlc			;8
	rlc			;10
	rlc			;20
	ora	c
	ret

dmwrite	mvi	a,wrsect
	db	01		;Ugh...
dmread	mvi	a,rdsect
	lxi	h,dmchan
	lxi	d,lltrk-1
	mvi	b,4
cload	mov	m,a
	inx	h
	inx	d
	ldax	d
	dcr	b
	jnz	cload
	dcx	h
	call	docmd
	lda	dmchan+4
	cpi	80lete status
	jz	dmwait

	ret

dmwcon:	db	writem			;Write track size
dmntrk:	dw	0			;Number of tracks + desync
	db	0			;X-address
	dw	2			;Two bytes
dmloc0:	dw	0			;Local controller address

	db	writem			;Write stepping rate data
dmspar:	dw	0			;Pointer to the stepping parameters
	db	0
	dw	8
dmloc1:	dw	0

	db	dmhaltc			;Controller halt
	db	0			;Status

;
;	Driver variables
;

lltrk	db	0
llss	db	1
lldrv	db	0
dmlog	db	0

	endif

***************************************************teprcl	equ	30		;Recalibrate step delay
headdly	equ	0		;Settle delay (0-25.5 milliseconds)
	endif

	if	st412		;Specifications for a Seagate ST412
cyl	equ	306
heads	equ	4
precomp	equ	128
lowcurr	equ	128
stepdly	equ	0
steprcl	equ	30
headdly	equ	0
	endif

	if	cm5619		;Specifications for an CMI 5619
cyl	equ	306
heads	equ	6
precomp	equ	128
lowcurr	equ	128
stepdly	equ	2
steprcl	equ	30
headdly	equ	0
	endif

sectsiz	equ	7		;Sector size code (must be 7 for this Cbios)
				; 0 =  128 byte sect	equ	50h		;Default channel address
stepout	equ	10h		;Step direction out
stepin	equ	0		;Step direction in
band1	equ	40h		;No precomp, high current
band2	equ	0c0h		;Precomp, high current
band3	equ	80h		;precomp, low current
track0	equ	1		;Track zero status
wflt	equ	2		;Write fault from drive
dready	equ	4		;Drive ready
sekcmp	equ	8		;Seek complete

*****************************************************************
*								*
* Drive Specification Table for the HD DMA hard disk controller *
*						is big enough for a bad spot map
	dw	mwbad		;Return bad sector map info
	else
	dw	nobad
	endif

*****************************************************************
*								*
* The following are the lowest level drivers for the Morrow	*
* Designs Hard Disk DMA controller.				*
*								*
*****************************************************************

mwwarm	xra	a
	call	mwdrv		;Select drive A
	call	mwhome		;Home and reset the drive
	lxi	b,0		;Make sure we are on track 0
	call	mwseek
	xra	adb	1,2,19,20,37,38
	db	3,4,21,22,39,40
	db	5,6,23,24,41,42
	db	7,8,25,26,43,44
	db	9,10,27,28,45,46
	db	11,12,29,30,47,48
	db	13,14,31,32,49,50
	db	15,16,33,34,51,52
	db	17,18,35,36

xlt512:	db	0
	db	1,2,3,4,17,18,19,20
	db	33,34,35,36,49,50,51,52
	db	5,6,7,8,21,22,23,24
	db	37,38,39,40,53,54,55,56
	db	9,10,11,12,25,26,27,28
	db	41,42,43,44,57,58,59,60
	db	13,14,15,16,29,30,31,32
	db	45,46,47,48

xlt124:	db	0
	db	1,2,3,4,5,6,7,8
	db	25,26,27,28,29,30,31,32
	db	49,50,51,52,53,54,55,56s a  diskette for 128 byte sectors,	*
* single density, and single sided.				*
*								*
*****************************************************************

dpb128s:dw	26		;CP/M sectors/track
	db	3		;BSH
	db	7		;BLM
	db	0		;EXM
	dw	242		;DSM
	dw	63		;DRM
	db	0c0h		;AL0
	db	0		;AL1
	dw	16		;CKS
	dw	2		;OFF
	db	1		;128 byte sectors

*****************************************************************
*								*
* The following DPB defines a diskette for 256 byte sectors,	*
* double density, a*******************************************

dpb512s:dw	60		;CP/M sectors/track
	db	4		;BSH
	db	15		;BLM
	db	0		;EXM
	dw	280		;DSM
	dw	127		;DRM
	db	0c0h		;AL0
	db	0		;AL1
	dw	32		;CKS
	dw	2		;OFF
	db	3		;512 byte sectors

*****************************************************************
*								*
* The following DPB defines a diskette as 1024 byte sectors,	*
* double density, and single sided.				*
*								*
*****************************************************************

dp1024s:ddb	1		;EXM
	dw	242		;DSM
	dw	127		;DRM
	db	0c0h		;AL0
	db	0		;AL1
	dw	32		;CKS
	dw	2		;OFF
	db	1		;128 byte sectors

*****************************************************************
*								*
* The following DPB defines a diskette as 256 byte sectors,	*
* double density, and double sided.				*
*								*
*****************************************************************

dpb256d:dw	104		;CP/M sectors/track
	db	4		;BSH
	db	15		;BLM
	db	0		;EXM
	dw	486		;DSM
	dw	255		;DRM
	db	0f0h		;AL0te sectors

*****************************************************************
*								*
* The following DPB defines a diskette as 1024 byte sectors,	*
* double density, and double sided.				*
*								*
*****************************************************************

dp1024d:dw	128		;CP/M sectors/track
	db	4		;BSH
	db	15		;BLM
	db	0		;EXM
	dw	599		;DSM
	dw	255		;DRM
	db	0f0h		;AL0
	db	0		;AL1
	dw	64		;CKS
	dw	2		;OFF
	db	4		;1024 byte sectors

	endif

******************************
	db	9,10,11,12,13,14,15,16
	db	33,34,35,36,37,38,39,40
	db	57,58,59,60,61,62,63,64
	db	17,18,19,20,21,22,23,24
	db	41,42,43,44,45,46,47,48

*****************************************************************
*								*
* Each of the following tables describes a diskette with the	*
* specified characteristics.					*
*								*
*****************************************************************

*****************************************************************
*								*
* The following DPB definend single sided.				*
*								*
*****************************************************************

dpb256s:dw	52		;CP/M sectors/track
	db	4		;BSH
	db	15		;BLM
	db	1		;EXM
	dw	242		;DSM
	dw	127		;DRM
	db	0c0h		;AL0
	db	0		;AL1
	dw	32		;CKS
	dw	2		;OFF
	db	2		;256 byte sectors

*****************************************************************
*								*
* The following DPB defines a diskette as 512 byte sectors,	*
* double density, and single sided.				*
*								*
**********************w	64		;CP/M sectors/track
	db	4		;BSH
	db	15		;BLM
	db	0		;EXM
	dw	299		;DSM
	dw	127		;DRM
	db	0c0h		;AL0
	db	0		;AL1
	dw	32		;CKS
	dw	2		;OFF
	db	4		;1024 byte sectors

*****************************************************************
*								*
* The following DPB defines a diskette for 128 byte sectors,	*
* single density, and double sided.				*
*								*
*****************************************************************

dpb128d:dw	52		;CP/M sectors/track
	db	4		;BSH
	db	15		;BLM
	
	db	0		;AL1
	dw	64		;CKS
	dw	2		;OFF
	db	2		;256 byte sectors

*****************************************************************
*								*
* The following DPB defines a diskette as 512 byte sectors,	*
* double density, and double sided.				*
*								*
*****************************************************************

dpb512d:dw	120		;CP/M sectors/track
	db	4		;BSH
	db	15		;BLM
	db	0		;EXM
	dw	561		;DSM
	dw	255		;DRM
	db	0f0h		;AL0
	db	0		;AL1
	dw	64		;CKS
	dw	2		;OFF
	db	3		;512 by***********************************
*								*
* The following equates relate the Morrow Designs DJDMA		*
* controller.							*
*								*
*****************************************************************

	if	(maxdm ne 0) or (maxmf ne 0)
dmchan	equ	50h		;Default channel address
dmkick	equ	0efh		;Kick I/O port address

rdsect	equ	20h		;Read sector command
wrsect	equ	21h		;Write a sector command
gstat	equ	22h		;Get drive status
dmsdma	equ	23h		;Set DMA address
intrqc	equ	24h		;Set Interrupt reh
	mov	m,d
	call	mfgdph
	push	h
	call	dmstat		;Get status
	pop	h
	ani	80h		;Check density bit
	mvi	c,3		;512 byte sectors
	rnz
	mvi	c,2		;256 byte sectors
	ret

mfgdph	lda	mflog
	lxi	d,dphmf0
	jmp	retdph

mfpcon:	db	0		;Physical configuration byte
mflog:	db	0

mfscon:	db	0, 0, 0, 0	;Saved physical configuration bytes

mfs:	db	10h		;North Star CP/M 1.4
	db	0		;Single density, 35 tracks, single sided
	dw	dpbmf0		;1K groups

	db	90h		;North Star CP/M 1.4
	db	n$dubl		;Double density, 3groups

	db	0d0h		;North Star CP/M 2.x (fake 40 track)
	db	n$dubl+n$2side	;Double density, 35 tracks, double sided
	dw	dpbmf3		;2K groups

	db	0		;End of configuration table

mfxltd	db	 1, 2, 3, 4
	db	21,22,23,24
	db	 5, 6, 7, 8
	db	25,26,27,28
	db	 9,10,11,12
	db	29,30,31,32
	db	13,14,15,16
	db	33,34,35,36
	db	17,18,19,20
	db	37,38,39,40

mfxlts	db	 1, 2
	db	 3, 4
	db	 5, 6
	db	 7, 8
	db	 9,10
	db	11,12
	db	13,14
	db	15,16
	db	17,18
	db	19,20
	endif

*************************ess
	mvi	m,dmsdma	;Set DMA address
	inx	h
	mov	m,c		;Low byte first
	inx	h
	mov	m,b		;High byte next

docmd	xra	a
	inx	h
	mov	m,a
docmd2	inx	h
	mvi	m,dmhaltc
	inx	h
	mov	m,a
	out	dmkick
tests	ora	m
	jz	tests
	ret

dminit:	lxi	h,dmchan	;See if controller will halt
	mvi	m,dmhaltc
	inx	h
	mvi	m,0
	out	dmkick		;Start controller
	lxi	d,0		;Set up timeout counter
dminwt	mov	a,m
	ora	a
	jnz	dmiok		;Controller has responded
	dcx	d		;Bump timeout counter
	mov	a,d
	ora	e
	jnz	dminwt
	se 0's table
	lxi	h,dparam+1		;Drive parameter table

dmstr0:	push	psw			;Save the drive count
	mov	a,m			;Load flags
	ora	a			;Does the drive need to be calibrated?
	jnz	dmstr1			;No, do not fiddle around
	push	h			;Save the parameter table pointer
	push	d			;Save the controllers table pointer
	dcr	m			;Set to calibrated mode (0ffh)
	dcx	h			;Back up to the track size byte
	shld	dmntrk			;Set the number of tracks pointer
	inx	h
	inx	h
	shld	dmspar			;Set the stepping constants pointer
	xchg		ome	xra	a
	mov	c,a		;Put a zero into (c) for track zero

dmseek	mov	a,c		;Enter with track in (c)
	sta	lltrk		;Save for use later
	ret

dmsec	lda	llss		;Load sector
	ani	80h		;Save side select bit
stores	ora	c
	sta	llss
	ret

dmside:	mov	a,c		;Move side bit into (a)
	ani	1
	rrc			;Move around to bit 7
	mov	c,a		;Resave in (c)
	lda	llss
	ani	7fh		;Mask out old side select bit
	jmp	stores

dmsel:	mov	a,c		;Move drive into (a)
	sta	lldrv
dmden:	ret			;Double density only

;
; Return s5 tracks, single sided
	dw	dpbmf1		;1K groups

	db	0b0h		;North Star CP/M 2.x
	db	n$dubl		;Double density, 35 tracks, single sided
	dw	dpbmf2		;2K groups

	db	0f0h		;North Star CP/M 2.x
	db	n$dubl+n$2side	;Double density, 35 tracks, double sided
	dw	dpbmf3		;2K groups

	db	0e5h		;North Star CP/M 1.4
	db	n$dubl		;Double density, 35 tracks, single sided
	dw	dpbmf1		;1K groups

	db	0a0h		;North Star CP/M 2.x  (fake 40 track)
	db	n$dubl		;Double density, 35 tracks, single sided
	dw	dpbmf2		;2K ****************************************
*								*
* Common routines for the DJDMA with 8 and 5 1/4 inch drives	*
*								*
*****************************************************************

dmsel2:	mov	c,a		;Move drive into (c)
	lxi	h,dmchan
	mvi	m,setlog	;Set logical drives
	inx	h
	mov	m,b		;Drive in (b)
	push	b
	call	docmd
	pop	b
	jmp	dmsel

dmssec:	push	b		;Save sector number
	mov	a,b
	rlc
	ani	1
	mov	c,a
	call	dmside
	pop	b
	jmp	dmsec

dmdma	lxi	h,dmchan	;Default channel addrtc			;Set error flag
	ret

dmiok	push	h		;Set drive parameters
	call	dmparm
	pop	h
	dcx	h		;Back to start of command
	mvi	m,setcrc	;Set CRC error retry count to one
	inx	h
	mvi	m,1
	xra	a
	jmp	docmd2		;Do command

;
;	Set floppy drive parameters
;
;	This routine reads the dparam table and if the a drive has not
;	previously been calibrated then that drives track count,
;	stepping rate, and head settling time are loaded.
;

dmparm:	mvi	a,8			;Eight drives
	lxi	d,1340h			;Start with driv		;Set the local parameter table pointer
	shld	dmloc0
	inx	h			;Offset to the stepping parameters
	inx	h
	inx	h
	inx	h
	shld	dmloc1
	lxi	h,dmwcon		;Write the drive constants out
	lxi	d,17			;Halt status offset
	call	dmdoit
	pop	d			;Retrieve the table pointers
	pop	h

dmstr1:	lxi	b,10			;Bump parameter table pointer
	dad	b
	xchg
	lxi	b,16			;Bump controller tables pointer
	dad	b
	xchg

	pop	psw			;Retrieve drive count
	dcr	a			;Bump count
	jnz	dmstr0			;Set up next drive

	ret

dmhtatus in the (a) register in the form:
;
;			7  6  5  5  3  2  1  0
;			^  ^  ^  ^  ^  ^  ^  ^
; Density --------------+  |  |  |  |  |  |  |
; Side select -------------+  |  |  |  |  |  |
; Double sided ---------------+  |  |  |  |  |
; 5 1/4 -------------------------+  |  |  |  |
; Sector size MSB ------------------+  |  |  |
; Sector size LSB ---------------------+  |  |
; Drive select MSB -----------------------+  |
; Drive select LSB --------------------------+
;

dmstat	lxi	h,dmchan
	mvquest
dmhaltc	equ	25h		;Halt command
bracha	equ	26h		;Channel branch
setcha	equ	27h		;Set channel address
setcrc	equ	28h		;Set CRC retry count
rdtrck	equ	29h		;Read track command
wrtrck	equ	2ah		;Write track command
serout	equ	2bh		;Serial ouput through bit banger serial port
senabl	equ	2ch		;Enable serial input
trksiz	equ	2dh		;Set number of tracks
setlog	equ	2eh		;Set logical drives
readm	equ	0a0h		;Read from controller memory
writem	equ	0a1h		;Write to controller memory

dmfstp	equ	3*341/10 logical drives
	dw	dmwarm		;Warm boot
	dw	dmtran		;Sector translation
	dw	dmldrv		;Select drive 1
	dw	dmselr		;Select drive 2
	dw	dmhome		;Home drive
	dw	dmseek		;Seek to specified track
	dw	dmssec		;Set sector
	dw	dmdma		;Set DMA address
	dw	dmread		;Read a sector
	dw	dmwrite		;Write a sector
	dw	nobad		;No bad sector map

dmtrck	equ	22*128		;Amount of code on track 0

dmwarm:	call	dmselr		;Select drive 0
	lxi	h,dmchan	;Set up branch
	mvi	m,bracha
	inx	h
	mvi	m,(low dmwchn)	;Low addressirst track DMA address - boot loader
	db	0
	db	rdtrck		;Read track command
	db	0		;Track 0
	db	0		;Side 0
	db	0		;Drive 0
	dw	dmwsec		;Sector load/status map
	db	0
dmwst:	db	0		;Track read status
	db	dmsdma
	dw	ccp+dmtrck	;DMA address for track 1
	db	0
	db	rdtrck
	db	1		;Track 1
	db	0		;Side 0
	db	0		;Drive 0
	dw	dmwsec+26	;Map is loaded right after track 0 status map
	db	0
	db	0		;Track read status
	db	dmsdma
	dw	buffer		;Sector 3 gets loaded in system buffer
	db	0
	db	rdsect
	db	1		v	a,m		;Get # of CP/M sectors/track
	ora	a		;Clear cary
	rar			;Divide by two
	sub	c
	push	psw		;Save adjusted sector
	jm	dmside2
dmsidea:pop	psw		;Discard adjusted sector
	pop	b		;Restore sector requested
	pop	d		;Restor address of xlt table
dmside1:xchg			;hl <- &(translation table)
	dad	b		;bc = offset into table
	mov	l,m		;hl <- physical sector
	mvi	h,0
	ret

dmside2:call	dmstat
	ani	20h
	jz	dmsidea
	pop	psw		;Retrieve adjusted sector
	pop	b
	cma			;Make sector request positive
	inrt a DPB
	rar
	lxi	h,xlts		;Table of XLT addresses
	mov	e,a
	mvi	d,0
	dad	d
	push	h		;Save pointer to proper XLT
	call	dmget
	pop	d
	lxi	b,2		;Number of bytes to move
	call	movbyt		;Move the address of XLT
	lxi	d,8		;Offset to DPB pointer
	dad	d		;HL <- &DPH.DPB
	push	h
	call	dmstat
	ani	20h		;Check double sided bit
	lxi	d,dpb128s	;Base for single sided DPB's
	jz	dmsok
	call	sethigh		;Set controller to know about fast steping
	lxi	d,dpb128d	;Base of double sided DPB's
dmsok:	xchg			;HL <-	;Fast stepping rate constant is 3 ms * 34.1
dmfset	equ	15*341/10	;Fast settling rate constant is 15 ms * 34.1

n$dubl	equ	80h		;Double density
n$2side	equ	40h		;2 sided drive

serin	equ	03eh		;Address of serial input data, (status - 1)

*****************************************************************
*								*
* Device Specification Table for the Disk Jockey DMA floppy	*
*								*
*****************************************************************

	if	maxdm ne 0
dmdst:	db	maxdm		;Number of byte
	inx	h
	mvi	m,(high dmwchn)	;High address byte
	inx	h
	mvi	m,0
dmwbad:	lxi	h,dmwend-1	;Pointer to end of command structure
	call	docmd		;Read in tracks
	lda	dmwst		;Get track read status
	ani	40h
	jz	dmwbad		;Loop on 'terrible' errors like no disk
	lxi	b,300h		;3/4 K bytes of sector 3 needs to be moved
	lxi	d,buffer	;Sector 3 is in our buffer
	lxi	h,ccp+1300h	;  and this is where we want it to go...
	call	movbyt
	xra	a
	ret

dmwchn:	db	dmsdma		;Set track 0 DMA address
	dw	ccp-512		;F;Track 1
	db	3		;Side 0, sector 3
	db	0		;Drive 0
dmwend:	db	0		;Read status
	dw	0		;Room for the halt

dmwsec:	dw	0ffffh, 0ffffh			;Do not load boot loader
	dw	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	;22 sectors to be loaded
	dw	0, 0ffffh, 0ffffh, 0ffffh	;First 2 sectors on track 2

dmselr:	sta	dmlog
	mvi	b,0		;8 inch logical drives start at zero
	jmp	dmsel2

dmtran:	inx	b
	push	d		;Save table address
	push	b		;Save sector #
	call	dmget
	lxi	d,10
	dad	d
	mov	a,m
	inx	h
	mov	h,m
	mov	l,a
	mo	a
	mov	c,a		;Make new sector the requested sector
	pop	d
	call	dmside1
	mvi	a,80h		;Side two bit
	ora	h		;	and sector
	mov	h,a
	ret

dmldrv:	sta	dmlog
	call	dminit		;Test for a drive
	jc	zret
	lxi	h,1		;Select sector 1 of track 2
	shld	truesec
	inx	h
	shld	cpmtrk
	xra	a		;Make sure we are doing a read
	sta	rdwr
	call	fill		;Flush buffer and refill
	jc	zret		;Test for error return

	call	dmstat		;Get status on current drive
	ani	0ch		;Mask in sector size bits
	push	psw		;Used to selec DBP base, DE <- &DPH.DPB
	pop	d		;Restore DE (pointer into DPH)
	pop	psw		;Offset to correct DPB
	ral
	ral
	mov	c,a
	mvi	b,0
	dad	b
	xchg			;Put DPB address in DPH
	mov	m,e
	inx	h
	mov	m,d
	lxi	h,15
	dad	d
	mov	c,m
dmget:	lda	dmlog
	lxi	d,dphdm0
	jmp	retdph

;
;	The current drive is double sided.  Thus is it safe to set the
;	stepping rate to 3 ms with 15 ms settling.
;

sethigh:lhld	dmlog			;Get the current drive number
	mvi	h,0			;Drive number is a byte
	dad	h			;Ten bytes per parameter table entry
	mov	d,h
	mov	e,l
	dad	h
	dad	h
	dad	d
	lxi	d,dparam+1		;Parameter table address
	dad	d			;Skip the track size byte
	mvi	m,0			;Force reparamitization of this drive
	inx	h			;Offset to the Stepping rate constant
	mvi	m,(low dmfstp)		;Fast stepping rate constant
	inx	h
	mvi	m,(high dmfstp)
	lxi	d,5			;Skip over the reserved fields
	dad	d
	mvi	m,(low dmfset)		;Fast settling rate constant
	inx	h
	mvi	m,(high dmfset)
	call	dmparm			;Set drive parameters for the SA850
	ret DMA address
	dw	dmread		;Read a sector
	dw	dmwrite		;Write a sector
	dw	nobad		;No bad sector map

mftrck	equ	9*512		;Amount of code on track 0

mfwarm:	call	mfsel2		;Select drive 0
	lxi	h,dmchan	;Set up branch
	mvi	m,bracha
	inx	h
	mvi	m,(low mfwchn)	;Low address byte
	inx	h
	mvi	m,(high mfwchn)	;High address byte
	inx	h
	mvi	m,0
mfwfal:	lxi	h,mfwend-1	;Pointer to end of command structure
	call	docmd		;Read in tracks
	lda	mfwst		;Check out drive status
	ani	40h		;Test for ok
	jz	mfwfal	db	0		;Track read status
	dw	0		;Room for the halt

mfwsec:	dw	0ffh, 0, 0, 0, 0	;Do not load boot loader
	dw	0, 0ffffh, 0ffffh, 0ffffh, 0ffffh ;first two sectors loaded

mfssec:	dcr	c		;Minnie floppy sectors start at zero
	lda	dblflg		;Get double sided flags
	ora	a
	jz	dmssec		;Nope, single sided
	mvi	b,80h		;Set high bit for double sided select
	jmp	dmssec

dblflg:	db	0

mfseek:	xra	a		;Clear double sided select
	sta	dblflg
	lda	mfpcon
	ani	n$2side
	jz	dmseek		;Only single sided

	movh drives start at drive 4
	jmp	dmsel2

mftran:	lda	mfpcon
	ani	n$dubl
	lxi	h,mfxltd	;Point to double sided sector translation table
	jnz	mftdubl		;Single density sector translation
	lxi	h,mfxlts
mftdubl:dad	b		;Add offset sector number to table
	mov	l,m		;Pick up sector number from table
	mvi	h,0		;MSB of sector number equal 0
	ret

mfldrv:	sta	mflog
	call	dminit		;Test for a controller
	jc	zret

	lda	mflog		;Get proper physical configuration byte
	mov	c,a
	mvi	b,0
	lxi	h,mfscon
	dad	bz	mfl9		;Non zero

	mvi	a,90h		;Double density default configuration
	call	dmstat		;If zero then determine sector size
	ani	80h		;Check density bit
	jnz	mfl9		;Its double density
	mvi	a,10h		;Single density default configuration byte

mfl9:	mov	c,a		;Move configuration byte into (c)

	lxi	h,mfs		;Address of configuration table -> (hl)
mfl2:	mov	a,m		;Get an entry
	ora	a		;Check for end of the table
	jz	zret		;Yes, select error
	cmp	c		;Check if entry matches selected drive
	jz	mfl3
	inx	h		;

	endif

*****************************************************************
*								*
* Drive specification table for DJDMA 5 1/4 inch drives		*
*								*
*****************************************************************

	if	maxmf ne 0
mfdst:	db	maxmf		;Number of logical drives
	dw	mfwarm		;Warm boot
	dw	mftran		;Sector translation
	dw	mfldrv		;Select drive 1
	dw	mfsel2		;Select drive 2
	dw	dmhome		;Home drive
	dw	mfseek		;Seek to specified track
	dw	mfssec		;Set sector
	dw	dmdma		;Set		;Failed, loop
	xra	a		;Return no error
	ret

mfwchn:	db	dmsdma		;Set track 0 DMA address
	dw	ccp-512		;First track DMA address - boot loader
	db	0
	db	rdtrck		;Read track command
	db	0		;Track 0
	db	0		;Side 0
	db	0		;Drive 0
	dw	mfwsec		;Sector load/status map
	db	0
mfwst	db	0		;Track read status
	db	dmsdma
	dw	ccp+mftrck	;DMA address for track 1
	db	0
	db	rdtrck
	db	1		;Track 1
	db	0		;Side 0
	db	0		;Drive 0
	dw	mfwsec+10	;Map is loaded right after track 0 status map
	db	0
mfwend:	a,c		;Move selected track in (a)
	sbi	35		;Subtract by track by number of tracks
	jc	dmseek		;Less than track 35

	mov	d,a		;Save adjusted track number
	mvi	a,34
	sub	d		;Adjust to count tracks back out
	mov	c,a		;Resave new track number

	mvi	a,0ffh		;Set double sided flag
	sta	dblflg
	jmp	dmseek

mfsel2:	sta	mflog

	mov	c,a		;Get proper physical configuration byte
	mvi	b,0
	lxi	h,mfscon
	dad	b
	mov	a,m
	sta	mfpcon
	mov	a,c		;Shhh, pretend that nothing happened

	mvi	b,4		;5 1/4 inc
	mvi	a,n$dubl
	mov	m,a
	sta	mfpcon

	lxi	h,1		;Select sector 1 of track 0
	shld	truesec
	dcx	h
	shld	cpmtrk
	xra	a		;Make sure we are doing a read
	sta	rdwr
	call	fill		;Flush buffer and refill
	jc	zret		;Test for error return
	lda	buffer+5ch	;Get diskette configuration byte

	push	psw		;Save configuration byte
	lxi	h,1
	shld	cpmtrk		;Load track 1 sector 1
	call	fill		;This is to fix bug with DJDMA firmware on
	jc	zret		; returning single density status on track 0
	pop	psw

	ora	a
	jnSkip onfiguration byte
	inx	h		;Skip drive type
	inx	h		;Skip DPB address
	inx	h
	jmp	mfl2

mfl3:	inx	h
	mov	a,m		;Pick up drive type
	sta	mfpcon
	mov	e,a

	push	h
	lda	mflog		;Get proper physical configuration byte
	mov	c,a
	mvi	b,0
	lxi	h,mfscon
	dad	b
	mov	m,e
	pop	h

	inx	h
	mov	a,m
	inx	h
	mov	h,m
	mov	l,a		;DPB address -> (hl)
	push	h		;Save DPB address
	call	mfgdph		;Get DPH
	lxi	d,10		;Offset to DPB address in DPH
	dad	d
	pop	d
	mov	m,e		;Store DPB address in DPH
	inx	