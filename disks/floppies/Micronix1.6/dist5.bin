ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееРеееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее ш) < ; : 9 8 7 6 5 4 3 2 1 0 / . - , + * ) ( ' & % $ # " !               w v u t s r q p o n m l k j i h g f e d c b a ` _ ^ ] \ [ Z Y X W V U T S R Q P O N M L K J I H G F E D C B A @ ? > =                                                                                                                                                                                                              1ъY                                                                                                 ¤Ѓ Mz{|          1%h1%h¤Ѓ Ђ	uvwxy      1h1h¤Ѓ Ђrst          1h1h¤Ѓ Ђpq            1h1
h¤‘ :h              1ьg1яg¤Ѓ  ^_            1тg1тg¤Ѓ ЂWXYZ[\]  1иg1кg¤Ѓ ЂUV            1Юg1Яg¤Ѓ  ST            1Цg1Цg¤Ѓ ЂMNOPQR    1Мg1Оg¤Ѓ Ђ	HIJKL      1Аg1Бg¤Ѓ  EFG          1ёg1№g¤Ѓ  =>?@ABCD1®g1Їg¤Ѓ  ;<            1¤g1¤g¤Ѓ Ђ9:            1›g1›g¤‘  3              1ђg1“g ш   чцхфіІ±°
	нмлкйизжедгвбаЯЮЭЬЫЪЩШЧЦХФУТСРПОНМЛКЙИЗЖЕДГВБАїѕЅј»є№ё·¶µґіІ±°Ї®­¬«Є©Ё§¦Ґ¤ЈўЎ џћќњ›љ™—–• ‘ ’ “ ” • – —  ™ љ › њ ќ ћ џ                                                                                                                                                                1ъY                                                                                                 ¤Ѓ   БВ            1µh1µh¤Ѓ   яѕїА          1Їh1°h¤Ѓ   јЅ            1Єh1Єh¤Ѓ   ¤є»            1ўh1ўh¤Ѓ   
·ё№          1›h1њh¤Ѓ   €µ¶            1—h1—hяБ   Аґ            20y1ёi¶Ѓ   Х°±Іі        1‹h2cy¤Ѓ   Ђ®Ї            1~h1~h¶Ѓ  
©Є«¬­      1th1th¤Ѓ  Ј¤Ґ¦§Ё    1gh1jh¤Ѓ  ў              1^h1_h¤Ѓ  Ђљ›њќћџ Ў1Sh1Th¤Ѓ Ђ—™          1Gh1Ih¤Ѓ  ЋЏђ‘’“”•1=h1>h¤‘   …              12h15hяБ   0                1ъY1%f¤Ѓ  Ѕ ѕ             1иf1иf¤Ѓ  » ј             1Яf1Яf¤Ѓ  µ ¶ · ё № є     1Чf1Шf¤Ѓ  І і ґ           1Пf1Пf¤Ѓ  Ї ° ±           1Иf1Иf¤‘  Є               1Ѕf1їf¤Ѓ  › њ ќ ћ џ   Ў   1¶f1ёf¤‘ x–               1Їf1±f¤Ѓ ЂЊ Ќ             1©f1©f¤Ѓ  ‰ Љ ‹           1Јf1¤f¤Ѓ  † ‡ €           1њf1њf¤Ѓ  „ …             1—f1—f¤Ѓ  Ѓ ‚ ѓ           1‘f1‘f¤Ѓ   Ђ             1‹f1Њf¤Ѓ  Ђ| } ~           1…f1†f¤Ѓ Ђхц            1i1i¤Ѓ   lуф            1i1i¤‘   hр              1i1i¤Ѓ   дежз        1i1i¤Ѓ   ¬вг            1i1i¤Ѓ   Ааб            1эh1эh¤Ѓ   aЮЯ            1шh1шh¤Ѓ   ^ЫЬЭ          1тh1тh¤Ѓ   їЩЪ            1мh1нh¤Ѓ   №ЧШ            1еh1еh¤Ѓ   {СТУФХЦ    1Эh1Яh¤Ѓ   XПР            1Шh1Шh¤Ѓ   hЛМНО        1Сh1Уh¤Ѓ   ИЙК          1Лh1Мh¤Ѓ   iЖЗ            1Гh1Гh¤Ѓ   ГДЕ          1јh1Ѕh¤Ѓ  z {             1}f1}f¤Ѓ Ђx y             1wf1wf¤Ѓ  v w             1rf1rf¤Ѓ  t u             1lf1mf¤Ѓ  r s             1gf1gf¤Ѓ Ђp q             1^f1^f¤Ѓ  n o             1Yf1Yf¤Ѓ  l m             1Tf1Tf¤Ѓ Ђj k             1Nf1Nf¤Ѓ  Бc d e f g h i   1Gf1If¤Ѓ Ђa b             1?f1?f¤Ѓ  `               1:f1:f¤‘  ђ               1&f15fяБ   Ђ Х –          2‹y2‡yяБ   `                2)y1VjяБ   0                1%f1%f¤Ѓ   v&'            1’i1’i¤Ѓ   X"#$%        1€i1€i¤Ѓ   П !            1Ѓi1Ѓi¤Ѓ   =            1zi1zi¤Ѓ       1ri1si¤Ѓ   Т            1ii1ji¤Ѓ   )        1ai1bi¤Ѓ   
            1[i1[i¤Ѓ c	
    1Ti2@y¤Ѓ   "            1Ni1Oi¤Ѓ   Y        1Fi1Gi¤Ѓ              1@i1Ai¤Ѓ   kэюя          1;i1;i¤Ѓ   Зыь            15i15i¤Ѓ   %щъ            10i10i¤Ѓ   чш            1%i1'i¤‘  "              1…g1€g¤‘ Ђ              1zg1|g¤Ѓ Ђ
        1qg1qg¤Ѓ Ђ	  1eg1ig¤Ѓ  ь э ю я    1Zg1\g¤Ѓ   х ц ч ш щ ъ ы   1Qg1Rg¤Ѓ  Ђ
п р с т у ф     1Fg1Ig¤Ѓ  й к л м н о     1<g1=g¤Ѓ  ж з и           12g13g¤Ѓ  д е             1*g1*g¤Ѓ  в г             1g1g¤Ѓ ЂЪ Ы Ь Э Ю Я а б 1g1g¤Ѓ ЂШ Щ             1g1g¤Ѓ ЂЦ Ч             1g1g¤‘ ЂП               1щf1ьf¤Ѓ  ї А Б В Г Д Е Ж 1рf1тf¤Ѓ   Ztu            1	j1
j¤Ѓ   іpqrs        1j1j¤Ѓ   mno          1эi1эi¤Ѓ   Mijkl        1чi1чi¤Ѓ   Ѕfgh          1сi1сi¤Ѓ   ™cde          1зi1зi¤Ѓ   	_`ab        1бi1бi¤Ѓ   )\]^          1Ыi1Ыi¤Ѓ   жZ[            1Хi1Хi¤Ѓ   W
TUVWXY    1Кi1Оi¤Ѓ   
NOPQRS    1Гi1ДiяБ   `M              1ѕi1Pj¤‘   ЂD              1ёi1єi¤Ѓ   :;            1±i1±i¤Ѓ   О89            1Ґi1Ґi¤‘ m0              1љi1ћiяЃ   зГДЕЖ        1ѓj1„jяЃ   $АБВ          1|j1}j¤Ѓ  b
є»јЅѕї    1tj1vj¤Ѓ  Яё№            1nj1oj¤‘    ¶              1cj1fj¤‘   ©              1[j1]jяБ   Р                1Vj1іj¤Ѓ   Р™љ›њќћџ1Pj1Rj¤Ѓ   ””•–—        1Gj1Hj¤Ѓ   !’“            1Aj1Aj¤Ѓ   |ђ‘            1;j1;j¤Ѓ   ГЌЋЏ          15j15j¤Ѓ   А‹Њ            1/j1/j¤Ѓ   ѓ…†‡€‰Љ    1$j1%j¤Ѓ   ‚ѓ„          1j1j¤‘   Ѓ~              1j1j                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                яЃ   %фх            2‡y2‡y¶‘   ем              1¤j1¦j¶‘   Ґв              1ќj1ћj¶‘   Т Р              1”j1—j¤Ѓ   ВЗ              1Њj1Џj                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 .              ..              usr                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             .              ..             man                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Built-In Commands
Entering Upm                               Control Characters
Customizing the Environment                Submit Files
Auto Entry                                 Text Files
Printers                                   Upm and the Background
Printer Handshaking                        Trace Mode
Policing the Printer                       Exiting Upm
System-Wide LST Device                     Bugs
.fi

.bd
.ti -5
Overview

.bd
Upm
provides a close functional replica of the environment which
appl .               ..             man1          G man2          | man3          ‡ man4                                                                                                                                                                                                                                                                                                                                                                                                                                          ications programs written to run under CP/M expect.
Most CP/M programs
(such as Micropro's WordStar word processing program)
will run unchanged under upm.

The intended purpose of
.bd
upm
is to bridge the gap between multi-user UNIX and the
large amount of special-purpose software available
for the CP/M operating system -- giving
true multi-user function for CPM software,
and making up for the lack of some of these applications
running directly under UNIX.

There is no significant difference between the way .              ..             upm.1          who.1          words.1        as.1           df.1           print.1        change.1       sum.1          cmp.1          entab.1        compare.1      copy.1         make.1         crypt.1        include.1      date.1         unique.1       dcheck.1       diff.1        
 cat.1         	 far.1          find.1         form.1         mail.1         grep.1         lord.1         ln.1           login.1       0 lib.1         / lpr.1          application programs
are run under
.bd
upm and the way they are run under CP/M.
All documentation for these programs is valid.
(However, some CPM documentation is oriented toward floppy disks.
It may contain such phrases as "insert the working diskette into
drive A". With Micronix, just as with a hard-disk CPM system,
the user must realize that no insertion is needed.)

.bd
Upm
is intended to be a means whereby applications
software written for CP/M may be run unchanged directly under Micronix.
Under Micro.in 15
.rm 79
.ta 5
.he "     upm (1)                           4/6/83                           upm (1)"
.fo "					       -#-"
.ti -5
NAME
.br
.bd
upm -
CP/M 2.2 for Micronix


.ti -5
SYNTAX
.br
upm [upm arguments] [cpm program] [program arguments]


.ti -5
DESCRIPTION
.br
.bd
Upm
duplicates as closely as possible
Digital Research's CP/M 2.2 operating system.
It is essentially a rewrite of CP/M using
Micronix system calls.
It allows CP/M tools (such as "WordStar")
and Micronix tools (such as "edit")
to be nix there are no records, no extents, no
disk drives
in the CP/M sense, no file control blocks (FCBs), disk parameter
blocks (DPBs), allocation vectors, etc., but
.bd
upm
does a good job of pulling the wool over the eyes of
most CP/M programs.

Some CP/M programs do not work under
.bd
upm,
however, because of system dependence.
For example, programs containing the
8080 instructions
"in", "out", or "hlt"
will not work.
The instant one of these instructions is encountered,
the operating system will be notifieused interchangably on the same files.
Moreover, since Micronix runs on a Z-80,
.bd
upm
need not emulate an 8080. All CPM programs run at full speed.
(The name "upm" was coined from the words UNIX and CP/M.)

This is a long document (about 20 pages).
Its sections, in order of appearance, are:
.nf

Overview                                   Select Errors
Getting Started                            File Names
Running Modes                              Bios Jump Table
Drive-Directory Correspondence             d
and the offending program will be terminated.
In a multi-user system such as Micronix,
all access to the hardware must be very tightly
controlled and coordinated.
If the above instructions were allowed,
user programs could usurp the operating system's
control over its resources.
If a CP/M program goes awry it will
have only a local effect - the rest of the operating system will
continue running.  Corrective action, if required,
can be taken from another terminal on the system.
(See the section on "exiting upm" below.)


.ti -5
.bd
Getting Started

.bd
Upm
runs on the Micronix operating system, whose file structure
is quite different from that of CP/M.
The first thing you'll need to do to run your CP/M
package is to copy it over to Micronix using the
.bd
far
(Floppy ARchiver)
command.
(See
.bd
far
in Section 1 of the Micronix Reference Manual.)
Be sure you are in the directory that you want the programs to reside in.
Insert your CP/M floppy diskette into floppy drive A and
type:

	% far fla -xv

for 8" disk files on a disk are globbed together
in a single huge directory.
You can do the same thing under Micronix if you want,
but sooner or later you will want to take
advantage of the Micronix hierarchical directory structure to
better organize your work.
So to use
.bd
upm
most effectively,
you should understand the relationship
between CP/M drive letters and Micronix directories.

CP/M organizes its information by drive letter (A: - P:).
Since the corresponding structure in Micronix is the directory,
.bd
upm
ma          ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _                                                                                                                                                                                                                                                                                                                                                                                 intains a table of CP/M drive letters and the names
of the Micronix directories to which they correspond.

The special command "="
displays the drive-directory relationships currently in effect.

For example,

.bd 100
	A> =

	A: -> /cpm
	B: -> ./
.bd 0

tells you that the A drive corresponds to the directory /cpm,
and the B drive corresponds to the directory "./" (the current
directory).  (If these directory names seem mysterious, type
the command "help pathnames".)

You may change the drive designation poiettes, or

	% far mfa -xv

for 5 1/4" diskettes.  (mfa2 for double-sided diskettes)

The
.bd
far
command copies all of the files on the CP/M
diskette over to the Micronix file system
and places them in your current directory.

Now, type

	% upm

and you're off and running!
There's still a lot more to learn, however, so as soon
as the novelty wears off, read on.


.bd
.ti -5
Running Modes

.bd
Upm
has two modes: DIRECT and INTERACTIVE.
If you intend to run only one CP/M application program, use the
DIRECT monters with a command of the form:

.bd
	B:dirname

wherein B may be replaced by any of the letters A through P,
and dirname (directory name) must contain at least one slant
character ("/").
.bd
Upm
recognizes a directory name
by the presence of at least one "/".
If the directory name doesn't already contain a slant,
you can always add one by putting a ./ at the beginning.
As an example:

If you want to set drive B to the subdirectory called "letters", type

	A> B:./letters

Remember that "./letters" means "de.

If you intend to run a series of CP/M programs, use the
INTERACTIVE mode.

To enter INTERACTIVE mode, type

	% upm

(You can also log in directly to upm.
When used this way, upm is called the "cpm shell",
since it looks as though you have simply logged onto
a hard-disk CP/M system. See
.bd
chsh
in Section 1 of the Micronix Reference Manual.)

To enter DIRECT mode, simply type the program name after
the shell prompt,
just as though it were a Micronix program.
For example, you can enter Wordstar directlystart in the current directory (.)
and look in the subdirectory (/) called letters."
(If you had typed B:letters, it would have looked like a request
to execute a program called letters from drive B.)


.bd
.ti -5
Entering upm

Perhaps it would help to understand this idea of drive-directory
designations if we walk through some typical examples of entering
.bd
upm.


Typing

	% upm

.nf
returns

.bd 50
    Morrow Designs upm
    N Bytes free

    A: -> ./

    A>
.bd 0

.fi
Now drive A corresponds
to the cu from the Micronix
shell by typing

	% ws

The shell will set up the emulator
for you. (Just how it is set up is detailed below
in the section on "auto entry").

You can also get into the direct mode by typing

	% upm program_name

By itself, this has no advantage over the more direct approach.
But it allows you to include other arguments to
.bd
upm
on the command line. This is discussed in more detail below.


.bd
.ti -5
Drive-Directory Correspondences

CP/M uses a "flat" directory structure,
where all therrent directory (./).	You may now re-designate this "drive"
and/or designate others.

One common setup is to address the directory /cpm
(where many of the CP/M application programs live)
as drive A, and the user's current directory as
drive B.

.bd 2
    A> a:/cpm
    A> b:./

returns

.bd 2
    A: -> /cpm
    B: -> ./

The above display is automatic.	 It is also possible to request a
display of the Micronix-upm relationship by entering an equal (=)
sign after
the A> prompt.


.ti -5
.bd
Customizing the environment

Drive designation modifiers may be used as commands to
.bd
upm
(in INTERACTIVE mode),
on the command line,
or in a
.bd
upm
"startup" file called ".upm".

.bd
Upm
can be customized to come up in any configuration you choose.
There are three places
.bd
upm
takes its configuration information from
(in order of appearance):

.ta 5
.in +5
.ti -5
1)	In the .upm file in the current directory or the
user's home directory.

.ti -5
2)	The command line (entered to the right of the word "upm").

.ti -5
3)	Int follow.

A possible .upm file might contain:
.sp
.in +5
.bd 7
A:/cpm
.br
B:./
.br
.bd
LST:/dev/ttyC,1200
.br
B:
.in -5

Which means:

.in +5
Make CP/M drive A refer to Micronix directory "/cpm".

Make CP/M drive B refer to Micronix directory "./" (your current
directory).

Arrange to have printed output sent to ttyC at
1200 baud.

Select drive B.
.in -5

With the preceeding .upm file in existence,
you need only type "upm", and	the .upm file
will be scanned
and
everything will be set up as described.

This eractive commands (only in INTERACTIVE mode, of course).

.in -5
An example  of drive-directory designators on the command line follows:

	% upm  a:/cpm  b:./  b:	 a:ws

This means: run
.bd
upm,
set drive A to the Micronix directory "/cpm",
set drive B to the directory "./" (your current directory),
select drive B as the "current drive",
then run ws from the A drive.

The order of events from the time
.bd
upm
is called is as follows:
.sp
.in +5
.ta 5
.ti -5
1)	An attempt is made to read the .upm startup filspares you the hassle of repeatedly typing in drive designation
commands each time you enter
.bd
upm.

It's also possible to specify more information on the command line.
Consider:

.ti +5
.bd
	% upm  a:/cpm  b:./  lst:output	 b:  a:ws document

This command tells the system to:

.in +5
1) Start
.bd
upm.
.br
2) Set drive A to /cpm
.br
3) Set drive B to ./
.br
4) Arrange to have printed output written onto the file "output" on
the currently logged drive.
.br
5) Select drive B
.br
6) Run WordStar
.br
7) Passe in the
current directory.
If this fails,
an attempt is made to read this file
in the user's home directory.
The .upm startup file may contain drive designators,
drive select commands,
a LST: redirection command,
a CP/M program name and arguments.
The CP/M program may be given as a Micronix file name
OR a CP/M program name.
The commands found in the .upm file are executed in the order they appear.

.ti -5
2)	The command line is scanned for drive designators,
drive select commands,
a LST: redirection comman the argument "document" to WordStar
.in -5


Admittedly, it would be a bit cumbersome to type
this entire command every time. Instead,
you could use the
.bd
alias
command to make a "shorthand" command line.

Simply create a shell startup file named ".sh" in your
home directory containing (amoung other things):

.bd
alias ws "upm a:/cpm b:./ lst:output b: a:ws"

The shell (command interpreter)
will read this file each time you log in.

When you want to run WordStar, type:

	% ws document

and the above commd and a
CP/M program name and its arguments (if any).
The commands found on the command line are executed in the order
they appear.
(Drive selection occurs first; program execution second).
.bd 4
If both a startup file (i.e., .upm) and command line arguments are present,
the arguments take precedence.  If two .upm files have been set up,
the one in the current directory takes precedence over
the one in the home directory.

So, for example, if a .upm file sets drive B: to one directory
and a command line aand is run for you.


.ti -5
Auto Entry

As mentioned above, it is often enough to
type the name of a CPM program after the shell prompt.
Here is what happens when you type

	% prog

.in +5
.ti -5
1.	The shell looks through each directory in its "search path"
(see below) for a command called "prog".  If found, it is run.

.ti -5
2.	If not found, the shell appends ".com" to the name,
getting "prog.com", and looks for that file.

.ti -5
3.	If prog.com is found, the shell sets up
upm as follows: drive A is setrgument sets it to another, the command line will win.
This lets you selectively override your standard settings.

.ti -5
3)	A choice is made.
If no CP/M program name was specified on the command line
or in the startup file,
.bd
upm
goes into INTERACTIVE mode
and gives a CP/M prompt (e.g. "A>").
If a program was specified, that program is immediately run.
.in -5

The features described above may be used to customize
.bd
upm,
and can be used to advantage in conjunction with shell
startup files.
Some examples to the directory in which the
file was found. Drive B is set to the user's current directory.
Drive B is selected as the current drive. Finally, the command
is executed from the A drive.
.in -5

So for example,
suppose that "ws.com" is in the directory /cpm.
If you type

	% ws document

then the shell silently expands this into

	% upm  a:/cpm  b:./  b:	 a:ws  document

and runs it.

If you get the response "command not found", then the file
ws.com was not in the shell's search path,
that is, ws.com was not in your current directory or in any
of the directories where the shell ordinarily looks for commands.
To remedy this, you could give the command

	% path .  /bin	/usr/bin  /cpm

This tells the shell to look first in "." (your current directory),
then in "/bin", then in "/usr/bin", and finally in "/cpm".
Better still, put this command in your .sh file, so that you
don't have tp retype it each time you log in.

The default path, ie, the path you get if you don't say otherwise,
is  ".	/bin  /usr/bin".   You have done this, anyone who uses upm on your system
will automatically use the same printer. BUT,
this doesn't police simultaneous access to the printer. If users
are located within shouting distance, or if it is very unlikely
that two people will ever be printing simultaneously, then this
is enough. Otherwise, read on.

You can arrange to have characters from the LST: device
sent to a file and saved up for later access.
This can be useful if you want to print something
again and again, or if you want to prican change this to anything you
want with the path command.

Note: The shell's automatic upm set-up does not work for all CP/M
programs. For instance, the Logicalc program lc.com insists that it
be on the "currently logged drive", (whereas WordStar can be on either
the currently logged drive or the A drive).
So the best way to run logicalc is to put the following alias in
your .sh file:

	alias lc "upm  a:/cpm  b:./  lc"

Then logicalc will run happily as long as you remember that your
spreadsheet files arent
later or on another machine.  Entering

	A>LST:file

is the command to accomplish this.
Characters sent to the LST: device are written to the
file named after LST:.
"File" may be any arbitrary Micronix file name.
It need not contain a slant.
(Be careful though, as any previous contents
of this file will be lost.)
If the file did not previously exist,
it will be created.

Once you have saved your output in a file, you can send it to the printer
with the "spool" program by typing the command

	A> spool fil on your B drive.


.ti -5
.bd
Printers

Or how to select the best way to talk to your printer.

There have to be half a dozen ways one could set up
a printer with
.bd
upm.

First, consider your environment:
Are you going to be running single user all the time?
Are many users going to be using one printer?
Will you be printing software listings or text?

Next consider your requirements:
Are you going to use special forms that will be changing?
Will you run many small files or a few large ones?
Do you want te

Spool is a upm program that invokes the Micronix lpr program.
This will send files to the printer in first-come-first-served
order, making sure that different users do not interfere with
each other. There is more information on this below.

You can send characters direct to a
"character special file" (or in other words to some other port).

	A>LST:/dev/ttyC

channels characters coming from the
LST: device to "ttyC" into which might be plugged a printer.
If you get the message "File or device busy",
that'o allow simultaneous printer access or lock out
later users, returning the message "Busy"?
Are you going to print many copies of a single large file?

Let's try to sort all of this out.

Most all CP/M applications programs send their printer
output to the LST: device.

.bd
Upm
can be taught to take those characters sent to
the LST: device and do any of a number of things
with them.
If you don't tell it otherwise (the default condition),
characters go into the LST: device and appear
on the controlling termins the case.
You'll be able to access the tty as soon as
whoever has it right now releases it.
If you get the message "Permission denied",
you should get your local super-user (possibly yourself)
to execute the commmand:

	# chmod a+w /dev/ttyC

to enable writing to the device.
Ttys
used like this should
.ul
not
be listed in the /etc/ttys file as
"login" ports.
You need to choose which ports you will use to log in on
and which ports you will use as printers.
In addition, you can specifiy the baud rate of youal (on your screen).
This is normally not very useful or beautiful.

The easiest way to send these characters to a printer is to:
.in +5
1. Attach the printer to one of the I/O ports on the
back of the Decision, say to ttyC, and then,
.br
2. Put the word "lst" on the ttyC line of the Micronix configuration
file /etc/ttys. (Also, put the baud rate on this line.)
.in -5
All this is explained in detail in the documents called
"printers" and "ttys" (type the commands "help printers"
and "help ttys").

Once you r printer.
(Default is whatever the device was set to before.)
It is always a good idea to specify your baud rate.
Also be sure your hardware and software baud rates agree:

	A>LST:/dev/ttyD,1200

would send characters to ttyD at a rate of 1200 baud.


.bd
.ti -5
Printer Handshaking

Micronix supports Clear-to-Send (CTS) and X-on, X-off handshaking.
If it asks (as WordStar does), you should tell your CP/M program to do
.ul
no
handshaking,
as Micronix will be handling that end of things.
X-on, X-off handshaking is always there and
you don't have to specify it.
If you don't use it, it doesn't get in the way.

CTS handshaking, however, needs to be carefully set up.
Note that the Morrow Designs Wunderbuss I/O
(found in Decision I table top models)
has CTS coming out on
.ul
pin-8
of the 25-pin connectors.
This is not standard.
The CTS pin is normally ignored.
If you specify the CTS type of handshaking described
below, no data will be transmitted until the
signal on pin-8 on the Wunderbuss IO (pin-5 on the Mult/IO)m all instances of upm
which are sending characters to their respective LST devices.
(Note that if a user has specified a LST device in his own .upm file,
it will override the system-wide LST device.)

This is accomplished by making an entry in the /etc/ttys file.
The /etc/ttys file is scanned by upm for a line containg the
word "lst".
If such a line is found, then upm arranges
that LST characters will be sent to the device
named by the first word on that line.

We desperately need an example of this simp is TRUE.
(See the help files on "printers", "setup", and "cables" for details.)

The following command line

	A>LST:/dev/ttyB,9600,cts

would send characters through the CP/M LST device
to
ttyB at 9600 baud with CTS handshaking.


.bd
.ti -5
Policing the Printer

If you want only one person to be able to access your
printer at a time, type:

	# chmod u+l /dev/ttyC

(The # is a super-user shell prompt. You should log in as "root"
(the super-user) to execute this command.)
This will set the single write lockle concept.
Suppose your "/etc/ttys" file contains:

	ttyA login 9600
	ttyB login 9600
	ttyC lst   1200

Any upm program run on the system will send its LST output
to ttyC as specified.

The Micronix /etc/ttys file as shipped has such an entry.


.bd
.ti -5
Select Errors

It is not possible to get a CP/M
SELECT ERROR under
.bd
upm.

If you select a drive which has as yet no corresponding
directory,
.bd
upm
inquires with the line

	Select a directory for drive D:

for instance.

You should respond by typing  bit,
after which only one user will be able to access the printer (ttyC)
at a time.
Other users will get the message "File or device busy."
With the lock bit set,
once a user gains access to the printer, he will hog it
until he either A) exits from upm, or B) types the command

	A> LST:

to release the printer (by re-assigning it to "nothing").

If you want many users to be able to use the printer
at once (and do your own policing), type:

	# chmod u-l /dev/ttyC

to clear the lock bit.
In this state, the uthe name of a
Micronix directory (/a/tom/letters, for example).
.bd
Upm
will continue
badgering you until you do.

This feature can be used to change directories right
in the middle of a program (WordStar as a good example):

.in +5
Change the logged drive to drive E: (previously
undefined).
.bd
Upm
will ask you for a directory name.
Respond with the name of the directory you want to reference.
Drive E: will now correspond to that new directory
(and you didn't have to get out of WordStar do to it).
.in -5

sers will have to decide amongst
themselves when to print.
You'll also probably have to move the paper to "Top of form"
manually after printing.
If two users try to print at once, the characters will be intermingled
(very ugly).

If you prefer to have software make the use decisions
for you (set up a spooling printer), use the
.bd
spool
program.
It is recommended that you prepare your printed
copy by formatting it, sending it to an output file (as described
above), then type the command

	A> spool file

.bd
.ti -5
.bd
File Names

.bd
Upm
intervenes in all file transactions originated
by the CP/M program.
When the CP/M program thinks it is opening a CP/M file,
it is really opening a Micronix file.
.bd
Upm
handles conversion back and forth between CP/M FCB's and Micronix
file path names.
It maintains a table of correspondences between CP/M drives and
Micronix directories.
For example, a CP/M program might read from a file named

	B:TEST.DOC

Here "B" indicates CP/M drive B and "TEST.DOC" is the
CP/M file name.

Spool
is good at handling large
printing jobs done on the same type
of paper
with printers which never fail, etc.
.bd
Spool
works in a deferred bulk fashion.
If you want immediacy, use the direct tty method
outlined above.
(The full path name of the spool program is /cpm/spool.com.
It simply invokes the Micronix
.bd
lpr
program. See lpr in section 1 for more details.)

.ti -5
.bd
The system-wide LST device.

It is possible to designate a particular
device on the system to be the recipient
of all output froSuppose for a moment that
.bd
upm
is currently remembering
the correspondence

	B: -> /a/hubert

then the above CP/M file name would be translated to:

	/a/hubert/test.doc

We see here that "B:" got translated to "/a/hubert/"
and TEST.DOC got translated to "test.doc".


.bd
.ti -5
File Names

CP/M file names are all upper case.
.bd
Upm
converts these to all lower case
Micronix file names as seen in the above example.

(If a "/" appears in a CP/M file name,
it will be converted to a "|" because
"/" has special meaning in Micronix file names.)

It should be noted that some files
may be inaccessible from
.bd
upm
because they have "CP/M impossible names".
This is no great stumbling block, however,
as one can simply rename the Micronix file(s).
(See
.bd
mv
in Section 1 of the Micronix Reference Manual.)

For file names to be accessible from
.bd
upm
the rules are:

.in +5
All lower case letters.

Maximum eight character filename.

Maximum three character extension (optional).

Names without an extension may be at my implemented as a CP/M
"transient" command.
It is listed as a built-in command here because it wouldn't work
otherwise.

.ti -8
TYPE	Types the contents of a file.

.ti -8
USER	Move to another area within the same directory.
UNIMPLEMENTED.
.br
All files are considered to be "USER 0"
for the purposes of CP/M programs.

.ti -8
A:	Select a drive.

.ti -8
A:/directory
.br
Set a new drive-directory correspondence.

.ti -8
LST:file
.br
Send LST: output to a file

.ti -8
LST:tty
.br
Send LST: directly to another tost eight characters long.
and should
have
.ul
no
final
".".

No question marks (?) or asterisks (*) may be used as a character
in the name.
.in -5

.ti -5
Examples of valid upm accessible file names:

.nf
	a.doc	example.txt	ppp

	z.f	prog.c		peter
.fi


.ti -5
.bd
BIOS Jump Table

.bd
Upm
also contains a "BIOS jump table"
bearing a striking resemblance to the original,
and corresponding in function. (If you've never heard of a BIOS
jump table, ignore this section.)
The two BIOS calls,
"read sector" and "wrty.
(X-on X-off handshaking will be used by default.)

.ti -8
LST:tty,speed
.br
Send LST: directly to a tty
.ul
and
set the speed.
(Again X-on, X-off handshaking used by default.)

.ti -8
LST:file,speed,cts
.br
Send LST: output to a file and set the speed and CTS handshaking.
Output is inhibited until the CTS line (pin-8 on the Wunderbuss or pin-5
on the Mult/IO)
is driven
.bd
TRUE.

.ti -8
LST:|program
.br
Send (pipe) the LST: output to another program.
Note that if this command is
entered from the shell,
ite sector,"
are considered illegal as they have no corresponding function
in the Micronix environment.
All the other BIOS calls are allowed, however,
some are silently ignored. (See the
.ul
CP/M 2.2 Operating System Manual
for more information on the CP/M BIOS.)
The BIOS calls having to do with character I/O
are fully implemented.
If you've never heard of a BIOS jump table, ignore this section.


.ti -5
.bd
Built-In Commands

Here is a summary of the available built-in commands under
.bd
upm.
Some of thesethe command line must be in quotation marks or else
the shell will interpret the pipe incorrectly; i.e:
entering

.bd
upm lst:|lpr

will be parsed into two commands by the shell.
You can convey the intended meaning
by enclosing the upm LST redirection argument in quotes, thusly:

.bd
upm "lst:|lpr"

.ti -8
LST:	Disconnect LST:.
LST: reverts to the default (characters appear on your screen).
.in -6


.ti -5
.bd
Control characters

The control characters discussed below are
effective only when the "standard"  are also discussed at length elsewhere
in this document.

Note that character case is insignificant under CP/M
but matters to Micronix.
In the following table, CP/M-ish things
are given
in upper case; Micronix-ish things in lower case.


.in +6
.ti -8
=	Displays drive-directory correspondences.

.ti -8
!command
Run a Micronix command.
Any valid shell command may appear after the exclamation point.
Note that there is a long setup time and lots of overhead
involved here.

.ti -8
ERA	Erases specified files.

CP/M
console I/O calls are used.
They will not be understood if the CP/M BIOS jumps
or CP/M direct I/O calls are used to generate the output
or request input.

^P - printer toggle.

Normally console output is sent only to the console.
If you type ^P, console output will be sent to both
the LST device and the console.
If you type ^P again, console output is once again
sent only to the console.

^S - suspend console output.

If, while console output is occurring, a ^S is received,
it is interpreted as an inst.ti -8
DIR	Displays file names in the directory.

.ti -8
exit	Leave upm.
This is the only way to get out of upm INTERACTIVE mode
(short of killing the process from another terminal).

.ti -8
REN	Renames a specified file.
Exactly as in standard CP/M.
REN new = old.

.ti -8
SAVE	Save memory contents in a file.
.br
UNIMPLEMENTED.
.br
If you want to patch files, see the Micronix utility
.bd
ddt
(in Section 1 of the Micronix Reference Manual).

.ti -8
STAT	Print additional information about files.
This is usuallruction to temporarily
suspend further output.
When in suspended mode, any character will restart the output,
except ^C which will cause upm to exit immediately.

^C - abort.

A ^C as the first character of an input line will cause
an exit from upm.

^R - retype current input line.

.ti -5
.bd
Submit files.

Standard CP/M submit file format is implemented.
IMPORTANT:
Submit file operation works only in upm's INTERACTIVE mode.
From the user's point of view, operation under upm is identical to
operation under CPM.

Here is the way submit files work internally, under both CPM and upm.
Please note that that this is
OPTIONAL TECHNICAL material, needed only by programers with special
requirements.
We repeat it here only because it is very hard to find this in the
CPM documentation.

.in +5
The submit file is named "A:$$$.SUB"

Upm checks for the presence of a submit file
just before issuing its prompt ( "X>" ).
A submit file consists of a series of records.
Each record represents one CP/M command.
Each record is 12 are able to do something
else on the system while waiting.
See also the section on background processes
in "sh" in section 1 of the Micronix reference manual.
It is also possible to run a non-interactive CP/M
program in the background at reduced priority
so that the subjective response time is not as
adversely affected.

	% asm program &

Would cause the named program's assembly proccess
to be initiated, but you
would immediately regain control of the console.
Note that this command must be issued from the8 bytes in length.
The records are in reverse order within the submit file.
Last record first, first record last, etc.

The first byte of each record gives the length of the
command line found in the following 127 bytes.

The following 127 bytes contain the CP/M command
exactly as one would enter it from the console.

Standard CP/M reduces the length of its submit file
by one record upon executing each command.

Upm doesn't actually change the size of the file,
but keeps track of where it is.
.in -5


.bd
. shell.

	% nice 5 asm program &

Would cause the same action as above but at a reduced priority level.
(The default "nice" is 0.)


.ti -5
.bd
Trace Mode

.bd
Upm
incorporates a trace mode for use in tracking down trouble,
or to analyze CP/M system call usage (or for any other
reason which comes up).

To run
.bd
upm
in "trace mode", type:

	% upm -v

(The -v stands for verbose.)
Each CP/M call made by the CP/M program
running under emulation will be displayed
on your screen as a single character.

Below isti -5
Text Files

Herein are some practical suggestions on the handling of text files
and the successful transportation thereof between CP/M and Micronix.
Also included is a description of the differences in their formats.

CP/M text files and Micronix text files are identical,
.ul
except
for the following:

.in +5
.ti -5
.ta 5
1.	At the end of each line of a Micronix text file there is a single
NEWLINE character; at the end of each line of a CP/M text file
there is a RETURN character followed by a NEWLINE  a table of the CP/M calls and the associated characters.


.nf
.ta 8
CPM call    CPM call  Upm trace
 name	     number    letter	  Description
--------    --------  ---------   -----------
RESET           0       A         system reset
CONIN           1       B         console input
CONOUT          3       D         console output
READER          3       D         reader input
PUNCH           4       E         punch output
LIST            5       F         list output
DIRECTIO        6       G         direcharacter.

.ti -5
2.	A CP/M file's length must be an even multiple of 128 bytes.
A Micronix file's length may be any number of bytes
(both are constrained to maximum file sizes).
CP/M text files are padded with ^Z characters at the end
to round them out to an even multiple of 128.
Micronix text files are not.

.in -5
There is a convenient utility for converting a text file back and forth
between the two formats.
(See
.bd
clean
in Section 1 of the Micronix Reference Manual.)
To make a text file suitable forct I/O
GETIO           7       H         get I/O byte
SETIO           8       I         set I/O byte
PRINTSTRING     9       J         print string
READBUF        10       K         read console buffer
CONSTAT        11       L         get console status
VERSION        12       M         return version number
DISKRESET      13       N         reset disk system
SELECTDISK     14       O         select disk
OPEN           15       P         open file
CLOSE          16       Q         close file
FIRST          Micronix, enter:

.bd
	% clean filename

To make a text file suitable for CP/M or
.bd
upm,
enter:

.bd
	% clean -u filename

The name
.bd
clean
comes from the idea of cleaning out the excess RETURN characters
and ^Z characters at the end; "-u" stands for "unclean".


.ti -5
.bd
Upm and the Background

Non-interactive CP/M programs may be run in the background.
The asm assembler is an example of a non-interactive program.
Running something in the background means you don't have
to wait for it to finish, but 17       R         search for first
NEXT           18       S         search for next
DELETE         19       T         delete file
READSEQ        20       U         read sequentially
WRITESEQ       21       V         write sequentially
MAKE           22       W         make file
RENAME         23       X         rename file
LOGIN          24       Y         return login vector
CURDISK        25       Z         return current disk
DMA            26       [         setD MA address
GETADDR        27       \         get addr (alloc)
PROTECT        28       ]         write protect disk
GETRO          29       ^         get read/only vector
SETFILE        30       _         set file attributes
PARMS          31       `         get addr (disk parms)
USERCODE       32       a         set / get user code
READRANDOM     33       b         read randomly
WRITERANDOM    34       c         write randomly
SIZE           35       d         compute file size
SETRANDOM      36       e         set random record
.fi
.ta 5


.tnse,
but this is often harmless.)


.ti -5
.bd
SEE ALSO
.br
.bd
Upm
tutorial in User Reference Manual

.ul
CP/M 2.2 Operating System Manual
.br
   by Digital Research, (C) 1976, 1977, 1978

clean (1), far (1), ls (1), chmod (1), ps (1), mv (1)


.bd
.ti -5
CREDITS
.br
CP/M is a trademark of Digital Research.

.br
WordStar
is a trademark of  MicroPro International Corporation.

UNIX is a trademark of Bell Laboratories.

.bd
upm
is a product of the Morrow Designs software group.
i -5
.bd
Exiting upm

You may leave INTERACTIVE mode by typing "exit" as a
command.

Exit from
.bd
upm's
DIRECT mode occurs immediately upon completion of the
called application program.

The appearance is that the CP/M program was run
directly under Micronix and then returned directly to Micronix.

If a program "bombs, freezes up, locks up, crashes," etc., what can you do?
(Sometimes you can restore control by hitting DELETE or RUBOUT, but
if you are running under upm, that will not work.)
One feature of M.in 10
.rm 79
.he "          who (1)                        4/6/83                         who (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
who

.in -5
.bd
SYNTAX           
.in +5
.br
.bd
who


.in -5
.bd
DESCRIPTION      
.in +5
.br
.bd
Who
prints a list of the currently logged-in users of Micronix.


.in -5
.bd
FILES
.in +5
.br
/etc/utmp	(current user information)
icronix is that a single crashed program cannot bring
the whole system down.
The system manager can "kill" the abberant program
from another terminal. Here is what the system manager should do:

Remember that each terminal is called tty-something, such as ttyA, ttyB, etc.
Let's say that the crashed program is running on ttyB.
Log in as "root" on another terminal, and type the command "ps a".
This will give the Process Status of tasks running on the system.
The "a" means "tell me about All the tasks, not jus.in 10
.rm 79
.he "          words (1)                      4/6/83                       words (1)
.fo "                                           -#-"
.bd
NAME
.br
.in +5
.bd
words
- count words in standard input or files


.in -5
.bd
SYNTAX           
.in +5
.br
.bd
words
.in -5


.bd
DESCRIPTION
.in +5
.br
.fi
The number of words in each of the named files
is printed alongside the file name.
If no file names are specified, or if "-" is given as a file name,
the standard input is read up to an end-of-filt the ones
belonging by this terminal". A list of tasks will appear, including
those belonging to ttyB. Note the numbers of all the tasks associated
with ttyB. You want to kill all of them (not just the ones called "upm").
Say that tasks number 4, 6, and 7 are listed as belonging to ttyB.
You should type

	# kill 4 6 7

The # is the super-user shell prompt, not something you type.
Unless you have logged in as the super-user (who is usually called
"root") you won't be able to kill someone else's programs.
The and
the number of words encountered is printed.
A word is defined as a contiguous string of non-blanks
separated by blanks characters.
A blank is a space, tab, or newline character.


.in -5
.bd
EXAMPLE
.br
.in +5
.nf
To count the words in a number of files:
.sp
.in +8
.bd
words file1 file2 file3
.in -8


.in -5
.bd
SEE ALSO
.in +5
.br
chars (1), lines (1)



                                                                                                                                is will terminate the offending program, and will also log the
user out. The user can then log back in and proceed.


.ti -5
.bd
BUGS

Here is a collation of all the sort of things which
are
.ul
not
likely to work under
.bd
upm:

8080 Instructions:

	hlt, in, out


Hardware specific programs:

	Hard disk formatters.
	Floppy disk formatters.
	Modem programs.


CP/M specific programs:

	MOVCPM, SYSGEN, STAT

(Note that STAT is simulated by
.bd
upm.)


CP/M specific calls (the CP/M calls 27 and 31 return nonse.in 10
.rm 79
.he "          as (1)                         4/6/83                          as (1)
.fo "                                          -#-"
.bd
NAME
.br
.in +5
as - A-natural assembler for 8080
.sp 2
.bd
.ti -5
SYNTAX  
.br
as -[o* x] [files]
.sp 2
.bd
.ti -5
DESCRIPTION
.br
as assembles A-Natural narrative assembly language for the Intel 8080
to standard format relocatable object images.
Since the output of the 8080 code generator is is A-Natural,
as is required to produce relocatable
images suitable for binding with link.

The flags are:

.ta 5
.in +5
.ti -5
-o*	write the output to the file *.
Default is xeq.
Under some circumstances,
an input filename can
take the place of this option,
as explained below.

.ti -5
-x	place in the object image only those symbols that are undefined
or that are to be made globally known.
Currently,
this happens anyway;
the flag is present for compatibility with other assemblers.

.in -5
If [files] are present,
they are concatenated in order and used
as the inputodes call for the value of the symbol table entry indexed by
the symbol code minus 4 to be added to the word.

Each symbol table entry consists of a value word, a flag byte,
and a nine-byte name padded with trailing NULs.
Meaningful
flag values are 0 for undefined. 4 for defined,
5 for defined text relative,
and 6 for defined data relative.
To this is added 010 if the symbol is to be globally known.
.sp 2
.bd
.ti -5
SEE ALSO
.br
link, cp2, obj
                                                                file instead of the default
STDIN.

If -o is
absent, and one or more files are present 
and the first filename
ends in 's',
then as behaves as if -o were specifed using
the first filename,
only with the trailing 's' changed to 'o'.
Thus,

	as file.s

is the same as

	as -o file.o file.s

A relocatable object image consists of an eight word header followed by a
text segment,
a data segment,
the symbol table,
and relocation information.
The header consists of the value 0x1499,
the number of sytmbol table bye.in 10
.rm 79
.he "          df (1)                         4/6/83                          df (1)
.fo "                                           -#-"
.bd
NAME
.br
.in +5
.bd
df
- disk free space


.in -5
.bd
SYNTAX        
.br
.in +5
.bd
df device ...


.in -5
.bd
DESCRIPTION   
.br
.in +5
.bd
Df
finds and prints the number of free blocks on each named device,
each of which is assumed to contain a file system.

This command is somewhat analogous to the CP/M STAT command. 


.in -5
.bd
EXAMPLE
.br
.in +5
s,
the number of bytes of object code defined by the text segment,
the number of bytes defined by the data segment,
three zero words,
and the data segment offset,
which always equals the text segment size.
All words in the object image are written less significant byte first.
The text segment is relocated relative to location zero,
the data segment is relocated relative to the end of the text segment.

Relocation information consists of two byte streams,
one for the text segment and one for the data sement,.bd
df /dev/root

.in -5
.bd
SEE ALSO
.br
.in +5
dcheck (1), icheck (1), ncheck (1), fsck (1)
                                                                                                                                                                                                                                                                                                                                                                                                
each teminated by a zero control byte.
Control bytes in the ramge [1, 31] cause the many bytes in the
corresponding segment to be skipped;
bytes in the range [32, 63] skip 32 bytes plus
256 times the control byte minus 32, plus the number of bytes
specified by the relocation byte following.

All other control bytes control relocation of the next word in the 
corresponding segment.
The 1-weight bit and 2 weighted bit are both
always zero for the 8080; the symbol code is the control byte right
shifted two pl.in 10
.rm 79
.he "          print (1)                      4/6/83                       print (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.bd
print
- prints files 


.in -5
.bd
SYNTAX          
.in +5
.bd 2
print file1 file2 ...  
.sp
print [-N] [-lN] [-wN] 


.in -5
.bd
DESCRIPTION
.br
.in +5
.fi
.bd
Print
produces output suitable for redirection to a printer.
It also produces a heading at the top of each page,
including the file name and the page number of the file.
.sp
The aces.

A symbol code of 47 is replaced by a code obtained from the byte or bytes
following in the relocation stream.
If the next byte is less than 128,
then the symbol code is its value plus
47;
otherwise the code is that byte minus 128 times 256, plus 175 plus the value o the next
relocation byte after that one.

A symbol code of zero calls for no further relocation;
1 means that a change in text bias must be added to the word;
2 means that a change in data bias must be added;
3 is not used.
Other symbol cfollowing flags may also be used:
.sp
.in +10
.ta 10
.ti -10
-N	Causes column N to be printed.

.ti -10
-lN	Print N lines per page.    

.ti -10
-wN	Print page N columns wide.

.in -10


.in -5
.bd
EXAMPLE
.br
.in +5
.nf
To print a file:
.sp
.in +8
.bd
print file
.sp
.in -8
or to print with flag values:
.in +8
.sp
.bd
print -4 -l188 -w132 file
.sp 2
.in -8
.in -5
.bd
SEE ALSO
.in +5
.br
lpr (1)
.in 10
.rm 79
.he "          change (1)                     4/6/83                      change (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
change -
make global changes in a stream
.sp 2
.in -5
.bd
SYNTAX           
.in +5
.br
.bd
change from [to]
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
Change
reads the standard input up to an end-of-file.
It writes the standard output exactly as
it was read, except that all instances of the regular expression
.bd
from 
are replaced file is an initial sub-sequence of the other, that fact is 
also noted.  If the 
.bd
-l 
option is used, the byte number (decimal) and the differing bytes
(octal) are printed for each difference.

.in -5
.bd
SEE ALSO
.in +5
.br
diff (1), common (1)
                                                                                                                                                                                                                                                                with 
.bd
to. 
If no replacement pattern is specified,
all instances of the regular expression are
eliminated.
The rules for regular expressions and
replacement patterns are
exactly as in 
.bd
edit.
.sp 2
.in -5
.bd
EXAMPLE
.in +5
.br
To make a global replacement:
.sp
.ce
.bd
change lead gold <input >output
.sp 2
.in -5
.bd
SEE ALSO
.in +5
.br
edit (1), find (1)
.sp
Brian Kernighan and P. J. Plauger
.ul
Software Tools
, Addison West Publishing Company, 1976.

.in 10
.rm 79
.he "          entab (1)                      4/6/83                       entab (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
entab
- replaces blanks by tabs 


.in -5
.bd
SYNTAX        
.in +5
.bd
entab
.in -5


.bd
DESCRIPTION
.in +5
.fi
.bd
Entab
acts as a filter, copying the standard input
to the standard output unchanged with the exception that
groups of
blanks are replaced by a tab where possible.
.bd
Entab 
assumes tabs are every eight positions, at .in 10
.rm 79
.he "          sum (1)                        4/6/83                         sum (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.bd
sum 
- compute check sums
.sp 2
.in -5
.bd
SYNTAX         
.in +5
.br
sum [-r] [files]
.sp 2
.in -5
.bd
DESCRIPTION   
.in +5
.br
.bd
Sum 
computes and prints a check sum and block count for each named file.
(Blocks are 512 bytes long.)
If no file names are given, it computes a check sum for the standard input.
.sp
If the -r option is uscolumns
9, 17, 25, etc.
.bd
Entab
is useful for
speeding up printing and communication over slow paths,
or to effect file compression.
.bd
Detab
is its inverse.


.in -5
.bd
EXAMPLE
.br
.in +5
To compress a file in which there are many spaces:
.sp
.in +8
.bd
entab <file >output
.in -8


.in -5
.bd
SEE ALSO
.in +5
.br
detab (1)
.br
Brian Kernighan and P. J. Plauger
.ul
Software Tools
, Addison West Publishing Company, 1976.
ed,
.bd
sum
recursively descends the
file hierarchy, summing each file as it goes.
In recursive mode, special files and directories are not summed.

As an example, check sums can be used to verify the integrity of 
a file over the phone.
Sums are in the range 0 to 65,535.
If two files have identical check sums, it is quite likely
that they are identical.
                                                                                                                                .in 10
.rm 79
.he "          compare (1)                    4/6/83                     compare (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
compare -
compare two files for equality
.sp 2
.in -5
.bd
SYNTAX           
.in +5
.br
.bd
compare file1 file2


.in -5
.sp
.bd
DESCRIPTION
.in +5
.br
.bd
Compare
reads the two named files, line by line, and announces
any differing lines, including the line number.
.sp 2
.in -5
.bd
EXAMPLE
.in +5
.br
To find the differing line in two.in 10
.rm 79
.he "          cmp (1)                        4/6/83                         cmp (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
cmp -
compare two files


.in -5
.bd
SYNTAX          
.in +5
.br
.bd
cmp [-l] file1 file2


.in -5
.bd
DESCRIPTION    
.in +5
.br
.bd
Cmp
compares two given files.
Nothing is printed if they are identical.
If a difference is encountered, 
.bd
cmp 
announces the byte number and
line number at which the difference occurred.
.sp
If one  nearly identical files:
.sp
.ce
.bd
compare version1 version2
.sp 2
.in -5
.bd
NOTES
.in +5
.br
The algorithm is very poor if lines have been
added or deleted to one of the files.
Compare will then report that all of the
following lines differ when in fact only
a small change may have been made
between the two files.
.sp 2
.in -5
.bd
SEE ALSO
.in +5
.br
diff (1) for a more sophisticated text comparator.

Brian Kernighan and P. J. Plauger
.ul
Software Tools
, Addison West Publishing Company, 1976.
.in 10
.rm 79
.he "          copy (1)                       4/6/83                        copy (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.bd
copy -
copy input characters to output


.in -5
.bd
SYNTAX        
.in +5 
.bd
copy
.in -5


.bd
DESCRIPTION
.in +5 
.br
.bd
Copy
simply copies its standard input to its standard output unchanged,
up to an end of file. 


.in -5
.bd
EXAMPLE
.br
.in +5 
.nf
To copy one file to another:
.sp
.in +8
.bd
copy <source >destination
.in -8


.inword.

Note:
this is not a very sophisticated encryption scheme
(NSA would have it overnight).

You can increase the complexity of the encryption by
using multiple passes of 
.bd
crypt, 
each with a different keyword.
.sp 2
.in -5
.bd
EXAMPLES
.in +5
.br
To encrypt a file:
.sp
.nf
.bd
	crypt bandersnatch < file > encrypted
.sp
.fi
To read the encrypted file
.sp
.nf
.bd
	crypt bandersnatch < encrypted
.sp
.fi
Encrypt a file with three keywords:
.sp
.nf
.bd
   crypt honeybee < file | crypt Beaumont | crypt os -5
.bd
NOTES
.br
.in +5 
.fi
On some systems, (but not Micronix), due to I/O  conventions
non-text files would be mangled if copied with the above example.
In this instance, use the 
.bd
cp 
program.


.in -5
.bd
SEE ALSO
.br
.in +5 
cp (1), concat (1)
.br
Brian Kernighan and P. J. Plauger
.ul
Software Tools
, Addison West Publishing Company, 1976.
                                                                                                                                car > encrypted
                                                                                                                                                                                                                                                                                                                                                                                                .in 10
.rm 79
.he "          make (1)                       4/6/83                        make (1)
.fo "                                           -#-"
.bd
NAME
.br
.in +5
make - automated program construction
.sp 2
.bd
.ti -5
SYNTAX
.br
make object ...
.sp 2
.bd
.ti -5
DESCRIPTION
.br
The problem of keeping the assembly instructions straight
for large programs composed of many modules is reduced
to the one-time job of writing a complete description file.

The make program reads the file
.ul
makef.in 10
.rm 79
.he "          include (1)                    4/6/83                     include (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.bd
include
- file inclusion


.in -5
.bd
SYNTAX       
.in +5
.bd
include


.in -5
.bd
DESCRIPTION
.br
.in +5
.fi
The standard input is copied to the standard output with
the exception of each line beginning with:
.br
.sp
.in +8
.bd
include filename
.in -8
.br
.sp
which is replaced by the contents of the named file.
Includes may be nested; tile
in the current directory.  Makefile consists of a number
of lines describing interdependencies among
program modules
and the formulas necessary to contruct these modules.

Each named target module is then contructed.

Make then "walks" the tree of dependencies,
updating target files as necessary.

Lines in the makefile take the form:

	product : ingredients ; formula

Where "product" is the name of a target file,
"ingredients" is a space-separated list of files upon which
"product" depends.



hat is, an included file may invoke
another file for inclusion.
If a named file is not openable, an error message is printed
and the program terminates abruptly.


.in -5
.bd
EXAMPLE
.br
.in +5
.nf
As a compiler preprocessor:
.sp
.in +8
.bd
include <program.z >program.tm1
.in -8


.in -5
.bd
SEE ALSO
.in +5
macro (1)
.br
Brian Kernighan and P. J. Plauger
.ul
Software Tools
Addison West Publishing Company, 1976.
.in 10
.rm 79
.he "          crypt (1)                      4/6/83                       crypt (1)
.fo "                                           -#-"
.bd        
NAME
.br
.in +5
.bd
crypt - file encryption
.sp 2
.in -5
.bd
SYNTAX
.in +5    
.br
crypt key
.sp 2
.in -5
.bd
DESCRIPTION   
.in +5
.br
.bd
Crypt 
reads from its standard input and writes to its standard output,
encrypting as it goes, according to the key.
.bd
Crypt 
is its own inverse; to read an encrypted file, all you need
to know is the key .in 10
.rm 79
.he "          date (1)                       4/6/83                        date (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
date
- print or set the date and time of day
.sp 2
.in -5
.bd
SYNTAX          
.in +5
.br
.bd
date [year] [month] [date] [hour:[minute:[second]]]
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
Only the super-user may set the time.
If no argument is given, the current date and time are printed.  
Otherwise, all of the arguments are taken together with the present
date and time to produce a new date and time.  The systems'
idea of the time is set.

.bd
[year], [date], [hour], [minute], 
and 
.bd
[second] 
are each given
as decimal numbers.

.bd
[month] 
is the name of a month, in English; case is ignored. The first 
three letters of the name of the month must be given.

If any specification is omitted, the current value of that specification
is used in its stead.  
A common error is to attempt to set the day of the week.
This is not permissableORS        
.in +5
.br
When a file turns up for which the link-count and the number of directory 
entries disagree, the
relevant facts are reported.
A dangerous situation occurs when there are more entries than links;
if entries are removed, the link-count drops to 0 and the remaining 
entries point to thin air -
they should be removed. 

When there are more links than entries,
some disk space may be wasted but the situation is
not dangerous.  If the 
.bd
-f
option is given, 
.bd
dcheck
will try to ratify t in the command line.
.sp 2
.in -5
.bd
EXAMPLES
.in +5
.br
.nf
.bd 2
		date 25 Dec 1983
.sp
		date 14:45


.fi
.in -5
.bd
NOTES
.in +5
.br
The clock is subject to hardware-induced problems that may cause 
the time to be off occasionally.
                                                                                                                                                                                                                                                                he situation.


.in -5
.bd
NOTES
.in +5
.br
Extraneous diagnostics may be produced if 
.bd
dcheck 
is applied to an active file system.


.in -5
.bd
SEE ALSO
.in +5
.br
fsck (1), ncheck (1), icheck (1)
                                                                                                                                                                                                                                                                .in 10
.rm 79
.he "          unique (1)                     4/6/83                      unique (1)
.fo "                                           -#-"
.bd
NAME
.br
.in +5
.bd
unique
- eliminate adjacent duplicate lines in an 
.nf
         I/O stream
.fi


.in -5
.bd
SYNTAX            
.in +5
.br
.bd
unique [-n]
.in -5


.bd
DESCRIPTION
.br
.in +5
.bd
Unique
reads the standard input and writes the standard output.
All  but  one  of  each  set  of  adjacent  duplicate  lines
are eliminated.  Otherwise,
the .in 10
.rm 79
.he "          diff (1)                       4/6/83                        diff (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
diff
- find differences in lines of text files


.in -5
.bd
SYNTAX           
.in+5
.br
.bd
diff [-e] file1 file2


.in -5
.bd
DESCRIPTION    
.in +5
.br
.bd
Diff
is a file comparator intended for use with text files.  It 
attempts to find a minimal set of differences between
lines of the given files.

Differences are reported by lintext is copied through unchanged.
If the 
.bd
-n 
option is given, a count of the number of duplicates
of each line is printed along with the text of the line.


.in -5
.bd
EXAMPLE
.br
.in +5
.nf
To eliminate all duplicate lines in a file:
.sp
.in +8
.bd 2
sort <file >temp
unique <temp >output
.in -8


.in -5
.fi
.bd
NOTES
.br
.in +5
In  order  to  assure  adjacency, the file  in  question  must  be 
presorted.


.in -5
.bd
SEE ALSO
.in +5
.br
sort (1)
es of the form

.in +8
.bd
N a R,S

.bd
N,M d R

.bd
N,M c R,S

.in -8
Where N and M are line numbers in file1; R and S are line numbers
in file2.

Following each line of this type
is a list of the affected lines in file1 marked by "<"
and a list of the affected lines in file2 marked by ">".

If the 
.bd
-e 
flag is given, the output takes the format of a command
script for 
.bd
edit 
to change the first file into the second.


.in -5
.bd
ERRORS         
.in +5
.br
There are limitations on the size of files.in 10
.rm 79
.he "          dcheck (1)                     4/6/83                      dcheck (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
dcheck
- file system directory consistency check


.in -5
.bd
SYNTAX         
.in +5
.br
.bd
dcheck [-f] file system ....


.in -5
.bd
DESCRIPTION   
.in +5
.br
.bd
Dcheck
reads the directories in a file system and compares the link-counts in
each i-node
with the number of directory entries by which it is referenced.


.in -5
.bd
ERR.
An "Out of memory" error message is printed if the problem is too large.

Spurious blanks lines are sometimes generated in
output produced under the -e option.
.sp 2
.in -5
.bd
EXAMPLE
.br
.in +9
.bd 5
diff apple pear
.sp 
4 a 7, 9
.br
> A text line
.br
> another text line
.br
> a third text line
.sp
.in
.in 5
.in +5
.bp
means that one of the changes required is to add lines 
after line number 4 in the first file.

After the addition is done, the lines will become
lines 7 thru 9 in the second file.
.in 15
.rm 79
.he "          cat (1)                        4/6/83                         cat (1)
.fo "                                           -#-"
.bd
.ti -5
NAME
.br
.bd
cat
- concatenate and print


.ti -5
.bd
SYNTAX       
.br
.bd
cat file ...


.ti -5
.bd
DESCRIPTION 
.br
.bd
Cat
reads each file in the order given and writes it to the standard output.
Thus,

.ce
.bd
cat file

prints the file and

.ce
.bd
cat file1 file2 > file3

concatenates the first two files and places the result in the third.
aken.

.ti -10
.bd
-p	Print.
Each named file is sent to the standard output (most likely your terminal). 

.ti -10
.bd
-r	Replace.
Each named file is copied
.ul
to
the floppy.
If no file names are given, no action is taken.
If a file of the same name already exists on the floppy, it is
silently overwritten.

.ti -10
.bd
-t	Table.
Print a table of contents of the floppy diskette.
If any files are named, only those named and present are listed.
 
.ti -10
.bd
-x	Extract.
Each named file is copied 
.ul
from
theIf no files are given or if "-" is given as a file name, 
.bd
cat
reads the standard input up to an end-of-file.

.ti -5
.bd
NOTES
.br
Beware of 
.ce
.bd
cat a b > a 

and 
.ce
.bd
cat a b > b

they destroy the input 
files before reading them!


.bd
.ti -5
SEE ALSO
.br
clean (1)

                                                                                                                                 diskette
.ul
to
the current Micronix directory.
If no file names are given, 
.ul
the entire contents
of the diskette
are extracted.

.ti -10
.bd
-v	Verbose.
Be verbose about it.
Each operation is printed along with the affected file name.
Files deleted are preceded by a "d", 
those replaced are preceded by an "r",
those extracted are preceded by "x".
The percentage of the diskette that is occupied,
along with the number of bytes still available,
is reported when far is finished.

.in -10
At most, one of th.in 10
.rm 79
.he "          far (1)                        4/6/83                         far (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
far
- floppy archiver


.in -5
.bd
SYNTAX          
.in +5
.br
.bd
far device [flags] [files]


.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
Far
provides a simple interface to CP/M floppy diskettes.
It is the primary means of incorporating new software into the system.
It is also used heavily for backing up files on diskettes, and recoverine flags -
.bd
d, t, r, x 
- may be present.
If none are present, 
.bd
-t 
is assumed.
.bd
-v
may be used in combination with any of these.

The file list may contain wild card matching patterns
to be applied to the set of file names in the CP/M
diskette's directory.  Refer to the section "Argument Expansion" in the
.bd
sh
program writeup in this manual.
.in -5
.sp2
.bd
EXAMPLES
.br
.in +5
You receive a new CP/M software package in the mail on diskette
and want to run it under Micronix.
To copy its entire cog
them as necessary.
"Device" is
assumed to be
the name of a Micronix special file
(such as /dev/fla)
corresponding to a floppy drive that contains a CP/M diskette.
.bd 
Far
can copy files in either direction, and can also be used to read the directory
of a CP/M floppy.  When the -v flag is used, it reports the amount of space
still available on the diskette.

Names such as /dev/fla may be abbreviated as fla.  You can check the names of
the storage devices by entering 

.bd
        cd /dev;dir (return)

Notntents to Micronix,
insert the diskette into floppy drive A and
type:

.ce
.bd	
far fla -xv

To copy a file from a diskette, changing its name in the process:

.ce
.bd
far dja -p filename > newname


To copy only the ".doc" files over from a CP/M mini-floppy:

.ce
.bd
far mfa -xv "*.doc"


To copy a file from diskette into a file that is elsewhere than your
current directory: 

.ce
.bd
far flb -x "name" > /dir/...
(path from root to desired location; you could also specify a new name)
.sp2
.in -5
The followe the different names for 5.25" floppy drives: mfa and mfa2.  Use mfa
to copy to or from diskettes that are formatted as single-sided.  Use mfa2
for double-sided diskettes.  Both names will direct the far command to the
same physical device.  Using the wrong name by mistake won't hurt anything;
it'll just let you know that you should  use the other one instead.

The flags are:

.ta 10
.in +10
.ti -10
.bd
-d	Delete.  
Delete the named files from the floppy diskette.
If no file names are given, no action is ting discussion is intended primarily for users that are
having trouble getting 
.bd
far
to do what they want it to.
.in -5

One aspect of far command syntax somewhat complicates the issue of using it,
namely, the use of quotation marks.  An example should
help clear this up.  Let's say your current Micronix directory contains two files,
.bd
a.com 
and
.bd
a.bak.
Your CP/M floppy contains a file 
.bd
a.pil
that you wish to copy into your current directory.  Since this is the only file
on the floppy that begiЋ Џ ђ ‘ ’ “ ” • —  ™ љ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         .in 10
.rm 79
.he "          find (1)                       4/6/83                        find (1)
.fo "                                           -#-"
.bd              
NAME
.in +5
.bd
.br
find 
- find files
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
find pathname-list expression
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
Find 
searches each of the given pathnames for files matching the 
given expression.
If the pathname of a directory is given, 
all files in that directory and all of its subdirectories
(recursins with "a", you lazily enter 
.bd
far mfa -xv a*.
Next you are wondering what's wrong when you are faced with the message
"a.com not found on diskette / a.bak not found on diskette".  Of course
they weren't found.  You didn't even want Micronix to be looking for them.

What has happened is this:  Your command interpreter (shell) thought you meant
to search the current directory for a match to the wildcard argument before 
going out to the floppy for the copy.  It indeed found two matches
(a.com & a.bak), svely)
are searched.

The expression above is built from constructions
like the following:
.sp
.bd
.ti -3
-name filename
.br
True if the filename argument matched the current file name.
Normal shell argument syntax may be used if escaped
(watch out for '[', '?', '*', '^').

Examples: '-name a.out' would match all files named "a.out".
'-name "*.o" ' would match all files in the tree whose
name ends in ".o"
.sp
.bd
.ti -3
-perm onum
.br
Where onum is an octal number.
True if the file's permission flags match to Micronix went gleefully out to the floppy to copy them.
In vain, unfortunately.

The solution here is to use quotation marks around your filename(s).
Had you entered
.bd
far mfa -xv "a*"
, the shell would have left the command alone, and far would have gone
directly out to the floppy to find anything that began with an "a".  Success.

Now, just to set the record straight, there is a further complication that
may help you to understand how the shell operates.  Suppose the file on your
floppy is called 
.bdhe given number.

Example: ' -perm 777 ' would match all files whose permissions
are "wide open".
.sp
.bd
.ti -3
-type c
.br
True if the type of the file c, where c is b, c, d or f for block special,
character special directory or play file.

Example: ' -type f '.
.sp
.ti -3
.bd
-links
.br
True if the file has n links.

Example: '-links 1' would consider only files with exactly one
link.
.sp
.ti -3
.bd
-user name
.br
True if the file belongs to the user uname (login name or numeric 
user ID).

Example: ' -u
b.pil
instead of
.bd
a.pil.
If you enter
.bd
far mfa -xv b.pil 
(no quotes), the file will in fact be copied, contrary to the previous discussion.
Furthermore, everything on the floppy diskette will be copied, much to your 
chagrin.  This is because your shell took b.pil to your current Micronix directory,
looked to see if a file of that name was really there, and finding no such file,
it passed the command to Micronix as "
.bd
far mfa -xv
".  As noted above in the description of the x flag, if there is noser root ' would screen all files except those owned
by root.
.bp
.ti -3
.bd
-group name
.br
True if the file belongs to group gname (group name or numeric
group ID).

Example: '-group sales' would consider only files in group "sales".
.sp
.ti -3
.bd
-size n
.br
True if the file is n blocks long (512 bytes per block).
.sp
.ti -3
.bd
-inum n 
.br
True if the file has inode number n.
.sp
.ti -3
.bd
-atime n 
.br
True if the file has been accessed in n days.
.sp
.ti -3
.bd
-mtime n
.br
True if the
file has bee file specified,
the whole diskette gets copied.

In summary, you 
.ul
should
enclose the argument in quotes whenever you want to copy specific files from
the floppy to Micronix.  The only exception to this is a situation where you
have certain files already established on Micronix and you want to extract
only those floppy files that match the existing Micronix filenames.

                                                                                                                                        n modified in n days.
.sp
.ti -3
.bd
-exec command
.br
Always true.
If the command is complex it must be enclosed in quotes (").
If the sequence {} occurs in the command, the current
filename will be substituted for it.
.sp
.ti -3
.bd
-ok command
.br
Like -exec except that the generated command is written on the the 
standard output,
then the standard input is read and the command executed only upon the
response 'y'.
In other words, you are asked if it's ok to execute the command.
Expect to see something like: < rm /a/smith/books/3.1 > ok ?
.sp
.ti -3
.bd
-print
.br
Print the file name.
Always true,
causes the current pathname to be printed.
(Note that 'find' does its work silently and if you don't
tell it otherwise, nothing will be printed.)
.sp
.ti -3
.bd
-newer file
.br
True if the current file has been modified more recently than
the argument file.

If two of the above constructions appear one after the other,
then the effect is a logical AND of the two.
That is, a primitive will be processed only if all
dded between words in the text if necessary to achieve
this.  
Right adjust mode is on by default.
It can be cancelled by a .na command (See below).
Right adjust mode will remain in effect forever or until
a .na command is encountered.
This paragraph is done in right adjust mode.


.bd 100
 .bd n

Cause the next (or number of given) line(s) of text to be double-striken
for bold face appearance. (Default is 1.)  
With the mode commands that take a line count argument
(.bd, .ce, and .ul)
If you want to emof the previous primitives were successful.
.bp
.in -5
.bd
EXAMPLES
.in +5
.br
To remove all files named a.out
that have not been accessed in a week
.sp
.nf
find / -name a.out -atime +7 -exec "rm {}"
.sp
.fi
To simply list the names of all the file in a hierarchy:
.sp
.ti +5
find . -print
.sp 2
.in -5
.bd
FILES
.in +5
.br
/etc/passwd - to look up user names.

/etc/group - to look up group names.
.sp 2
.in -5
.bd
SEE ALSO
.in +5
.br
sh (1), filsys (5)
bolden, center, or underline
a large number of lines and don't want to bother
with counting them, the best way to do it is:

	.bd 1000

	text
	text
	text

	.bd 0

This paragraph is done in bold face.
Printer must have back spacing
ability, otherwise
overstrike
(Section 1) must be used.

Example:

	form file | overstrike | lpr & 
.bd 0


.bd
 .bp n

Begin page number n.
Jump to the top of the next page.
Set the page number to n (default is sequential order beginning with 1).


.bd
 .br

Cause br.in 15
.rm 79
.he "          form (1)                       4/6/83                        form (1)
.fo "                                           -#-"
.bd
.ti -5
NAME
.bd
.br
form
- format text


.ti -5
.bd
SYNTAX    
.br
.bd
form [-t] [-o output] [file ... ]


.bd
.ti -5
DESCRIPTION
.break
.fi
.bd
Form
is a general purpose text formatter with text filling, underline,
indenting, centering, and other useful capabilities.
This document was prepared using 
.bd
form.

The standard input is read and formatted eak.
The next input line will begin at the left margin.
Many commands cause a break.
Beginning a line with white space will cause a break.


.bd
 .ce n

.ce 100
.nf
.na
Center the next (or number of given) input line(s).
Each line here is centered.
Default is next line only.
.fi
.ad
.ce 0

.bd
 .fi

Set filled text mode.
All text lines will be filled out with blanks if necessary
so that the right margin is justified.
This paragraph is filled.
Fill mode is the initial default condition.


.bd
 .faccording to instructions
embedded in the input file; the result is written to the standard output.

If a list of files names is given, they are used as the input.
If "-o" followed by a file name appears on the command line,
then the output is written to the named file.

If "-t" appears on the command line, then the output
is made more suitable for a glass tty, i.e. long sequences of
blank lines are avoided.

Input consists of text lines interspersed with command lines 
destined to be printed.

If the firsto TEXT

Set the footer.
The specified text will be printed at the bottom of each page.
If the symbol # appears in the text, the page number
will be substituted for it.


.bd
 .he TEXT

Set the header.
The specified text will be printed at the top of each
following page.
If the symbol # appears in the text, the page number
will be printed in its stead.


.bd
 .in n

Set the indent.
The indent is set to the nth column.  The command ".in" is 
interpreted to mean no indent. Default is 0.


.bd
 .ls n

Set t character of a line is a period (.), 
.bd
form 
attempts to interpret the line as a command; in any 
case, the text of such lines will not appear in the output.
If a command is not recognized, it is ignored.
Only the first 2 characters of the command name
are significant, the rest are ignored.
So, for example, you may use .break or .br with the same effect.

The following commands are implemented:


.bd
 .ad

Turn on right adjust mode.
Causes the right edge of the text to be squared up.
Spaces are embehe line spacing to n lines.  The command
".ls 2" is interpreted  to mean double space.
The line spacing is set to 1 (default) initially.

.bd
 .na

.na
No adjust.
Turns off right adjust mode.
The right edge of the text will be ragged.
This mode gives a more human look as the average
typist does not produce copy with a squared up
right edge.
Adjust mode will remain off forever or until
an .ad command is encountered.
This paragraph is done with right adjust mode turned off.
.ad

.bd
 .nf

.nf
No fill.
Turnsў Ј ¤ Ґ ¦ § Ё © « ¬ ­ ®                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         .in 15
.rm 79
.he "          mail (1)                       4/6/83                        mail (1)
.fo "                                           -#-"
.bd
.ti -5
NAME
.br
.bd
mail
- send and receive mail


.ti -5
.bd
SYNTAX
.br
mail [-[yn]] [user]


.ti -5
.bd
DESCRIPTION
.br
Micronix has an inter-user mail system.
The
.bd
mail
program sends letters to the appropriate system user.
Letters are sent to another user by entering:

	% mail user_name

The user_name may be a "local" name or a "network" name.
Loc off fill mode.
With fill mode in effect, words are collected
until no more will fit on a line, then a new line is started.
In No Fill mode, each line is preserved in the output.
This paragraph was done in No Fill mode.
.fi

.bd
 .pl n

Page length.  
The page length is set to n lines long.
If no number (n) is specified, the page length is set to 66 lines (default).


.bd
 .rm n

Right margin. 
The right margin is set at column n.
If no number (n) is specified, it is set at column 60 (default).


.bdal names are simply login names (ie, the name by which a
user logs in). Network names look like machine_name%login_name.

To enter the letter, just begin typing.
Enter as many lines as necessary.
Letters are terminated by entering a single period, or a ^D at the
beginning of the last line.

The next time the user logs in, he will be greeted
with the message "You have mail".

To read his mail, he simply enters

.bd
	% mail

The letter is printed on-screen.  The user is then asked
if he wants to keep his mail
 .sp n

Space down n lines.
If no number (n) is given, spaces 1 line (default).


.bd
 .ta n

Set the tab.  Value (n) determines amount of tabbed spaces.  Entered with
^I sequence or TAB key. When used with the (.ti) command, 
it can be used to produce
"hanging" paragraphs.

	.ta 10
	.in 10
	.ti -10
	Melons<TAB>Watermelons, among the nation's
	best selling fruit can weigh up to umpteen
	pounds.
	

would produce something like:


.ta 10
.in 10
.ti -10
Melons	Watermelons, among the nation's.

The appropriate reply is "yes" to keep it, or "no" to delete it.  Kept
mail is stored in the "mbox" file in the user's home directory.

.ti -5
EXAMPLE
 % mail sales%ron
 Lunch Wednesday at 12:30?
 	-Jill
 .
 %

.ti -5
SEE ALSO
.br
network (4)
                                                                                                                                                                                                                                                                
best selling fruit can weigh up to umpteen
pounds.



.bd
 .ti n

Temporary indent.
The indent is set to a value (n) for the next line only.
This is quite useful for numbering paragraphs - a negative value produces a
"hanging" paragraph.


.bd
 .ul n

.ul 100
Cause the next (or number of given) input line(s) to be underlined.
The default is 1.
This paragraph is underlined.
Printer must have double-strike capability. If not,
see the
.bd
overstrike
program (Section 1) for instructions on using this pro.in 10
.rm 79
.he "          grep (1)                       4/6/83                        grep (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
grep
- find instances of a regular expression in a 
.nf
       stream
.fi


.in -5
.bd
SYNTAX          
.in +5
.bd
grep [-c] [-i] [-l] [-n] [-v] pattern [filename...]
.br
.in -5


.bd
DESCRIPTION
.in +5
.fi
Lines in each of the named files matching the regular expression
"pattern"
are written on the standard output.
The rules for reggram.

Example:

	form text | overstrike > /dev/ttyH


.ul 0


.ti -5
.bd
SEE ALSO
.br
edit (1), overstrike (1), diablo (1), lpr (1)




                                                                                                                                                                                                                                                                ular expressions
are 
as in 
.bd
edit.
.sp
The
following flags are meaningful in the command line:


.ta 10
.in +10
.ti -10
-c	Only a count of matching lines is printed for each file.
.ti -10
.sp
-i	The case of letters is ignored in comparisons.
.sp
.ti -10
-l	The names of files containing matching lines
are listed once, one on a line.
.sp
.ti -10
-n	Each matching line is preceded by its line number in its
respective file.
.sp
.ti -10
-v	All lines
.ul
not
matching the pattern are printed.
.br
.in -10


.in -5
.bd
EXAMPLE
.br
.in +5
.nf
To search for occurrences of a string in a file:
.sp
.ce
.bd
grep string file


.in -5
.bd
SEE ALSO
.in +5
.br
edit (1), change (1)



                                                                                                                                                                                                                                                                ats: "0x????????B", "0x????????D", 
"0x????????T", 0x????B", "0x????D", "0x????????U" and "0x????U".
These are compatible with the default output of rel (obj).

If there  are any circular dependencies among the modules, 
.bd
lord
writes "not completely sorted" to STDERR and outputs a 
partially-ordered list.
In general, rearrangements are made only when necessary, so an ordered
set of modules should pass through
.bd
lord
unchanged.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
.bd
Lord
returns success if no error mes.in 10
.rm 79
.he "          lord (1)                       4/6/83                        lord (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
lord
- order libraries
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
lord -[c* d* i r* s]             
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
Lord
reads in a list of module names, with associated interdepencies, from
STDIN, and outputs to STDOUT a topologically sorted list of module
names such that, if at all possible, no module depends onsages are printed, otherwise failure.
.sp 2
.in -5
.bd
EXAMPLE
.in +5
.br
To create a library of ordered object modules under Idris:
.sp
.ti +4
.bd
% rel *.0 | lord -c"lib libx.a -c" | sh
.sp 2
To order a set of objects using Micronix nm:
.sp 
.in +4
.bd
% nm *.o > nmlist
.br
.bd
% lord < nmlist -c"ar r libx.a" | \
.br
.bd
-d"??????T" -d"??????D" -d"??????B" -r"??????U" | sh
.in -4
.sp 2
.in -5
.bd
SEE ALSO
.in +5
.br
lib (1), obj (1)

NOTE: This program and documentation are products of Whitesmiths, Ltd.
 an earlier
module in the list.  Each module is introduced by a line containing
its name followed by a colon.  Subsequent lines are interpreted
as either:
.sp 2
.in +8
.ta 8
.ti -8
defs	- things defined by the module,

.ti -8
refs	- things referred to by the module, or

other stuff.

.in -8
Refs and defs have the syntax given by one or more formats entered
as flags on the command line.  Each character of the format must match
the corresponding character at the beginning of an input line; a ?
will match any .in 10
.rm 79
.he "          ln (1)                         4/6/83                          ln (1)
.fo "                                           -#-"
.bd
NAME
.br
.in +5
.bd
ln
- make links


.in -5
.bd
SYNTAX         
.br
.in +5
.bd
ln name1 name2


.in -5
.bd
DESCRIPTION   
.br
.in +5
A link is made between two files (name1 and name2).
Therefore, changes made to file name1 affect file name2 and vice-versa. A
file may have up to 255 links.


.in -5
.bd
ERRORS
.in +5
.br
Linked files must be on the same character except newline.  If all characters of the format
match, the rest of the input line is taken as a ref or def name.  Thus,
the format flag "-d0x????D" would identify as valid def any line
beginning with "0x", four arbitrary characters and a "D", so that
the input line "0x3ff0D_inbuf" would be taken as a def named "_inbuf".

The flags are:
.sp 2
.in +5
.ta 5
.ti -5
-c*	prepend the string * to the output stream.  Implies -s.
Each module name is output preceded by a space; the output stream 
is terminafile system, otherwise, a "Cross-device
link" error message is displayed.


.in -5
.bd
SEE ALSO
.in +5
.br
rm (1), cp (1), mv (1)
                                                                                                                                                                                                                                                                ted with a newline.  Hence,
.bd
lord
can be used to build a command line.
.sp
.ti -5
-d*	use the string * as a fromat for defs.
.sp
.ti -5
-i	ignore other stuff.  Default is to complain about any line
not recognizable as a def or ref.
.sp
.ti -5
-r*	use the string * as a format for refs.
.sp
.ti -5
-s	suppress output of defs and refs; output only module names
in order.
.in -5
.sp 2
Up to ten formats may be input for defs, and up to ten for refs.

If no -d flags are given, 
.bd
lord
uses the default def form.in 10
.rm 79
.he "          login (1)                      4/6/83                       login (1)
.fo "                                           -#-"
.bd
NAME
.br
.in +5
.bd
login 
- sign on


.in -5
.bd
SYNTAX           
.br
.in +5
.bd
login


.in -5
.bd
DESCRIPTION   
.br
.in +5
.bd
Login
is executed automatically by
.bd
init.
It requests a user name (and password if appropriate), performs the required
bookkeeping, executes the shell and begins the user's Micronix session.


.in -5
.bd
FILES
.br
.nf
.bd 5
	/etc/utmp		accounting
	/usr/adm/wtmp		accounting
	/etc/banner		The sign on message
	/etc/motd		message-of-the-day
	/etc/passwd		password file
.in +5
.sp
.fi
.in -5
.bd
SEE ALSO
.br
.in +5
init (1)
                                                                                                                                                                                                                                                                a two-byte header having the value
0177565, written less significant byte first,
followed by zero or more entries.

Each entry consists of a fourteen-byte name,
followed by a two-byte unsigned file length,
also stored less significant byte first, followed by the file contents proper.
If a name begins with a null byte,
it is taken as the end of the library file.

Note that this differs in several small ways from UNIX v. 6 format, which
has a header of 0177555, an eight-byte name, six bytes of miscellaneous
U.in 10
.rm 79
.he "          lib (1)                        4/6/83                         lib (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
lib
- maintains Whitesmith's format libraries


.in -5
.bd
SYNTAX        
.in +5
.br
.bd
lib lfile [flags] [files]


.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
Lib
performs all functions necessary to build and maintain object module
libraries.
It can also be used to collect arbitrary files into one bucket.
.bd
Lfile 
is the name of an exiNIX specific file attributes, and a two-byte file length.
Moreover, 
a file whose length is odd is followed by a null padding byte in the UNIX
format, but no padding is used in standard library format.

UNIX v.7 format is characterized by a header of 0177545,
a fourteen-byte
name, six bytes of UNIX specific file attributes, and a four-byte length.
Odd length files are also padded to even.


.in -5
.bd
RETURNS
.in +5
.br
.bd
Lib
returns success if no problems are encountered, else failure.
In most failures, sting library file or, in the case of replace
(-r), the name of the library to be created.

The flags are:

.ta 10
.in +10
.ti -10
-d	Delete the zero or more named files from the library.

.ti -10
-r	Replace the zero or more named files in an existing library or,
if no library 
.bd
lfile 
exists, create a library with the named files in the
specified order.

Named files that are not present in the library are 
appended to the end in the order specified.

.ti -10
-t	Lists files in the library in the order than error message is printed to STDERR and the library file
is not modified. Output from the 
.bd
-t 
flag, and verbose remarks, are written to
STDERR.


.in -5
.bd
EXAMPLE
.in +5
.br
To build a library and check its contents:

.in +8
.bd
lib clib -r one.o two.o three.o

.bd
lib clb -tv
.in -8

.bp
.in -5
.bd
NOTES
.in +5
.br
If all files are deleted from a library, a vestigial file
remains.  Modifying UNIX v.6 or UNIX v.7 format files causes all 
attributes of all file entries to be zeroed.

It does not cheey occur. 
If any files are named, only those named and present are listed.

.ti -10
-x	Extract any named files that are present in the library into files
of the same name.
If no files are named, all files are extracted.

.ti -10
-v	Be verbose about it.
Files retained unmodified are each listed with a
preceding "c".
Those deleted are preceded by a "d", 
those replaced are preceded by an "r" and those appended to the end 
are preceded by an "a".
For the 
.bd
-t 
option, each file is listed with its length inck for large files  (over 65534 bytes).


NOTE:
This program and documentation are products of Whitesmiths, Ltd., 
and are sold separately with the C compiler.

                                                                                                                                                                                                                                                                 bytes.

.ti -10
-6	Create a file with UNIX v. 6 format, if none exists. Effective only
with 
.bd
-r.

.ti -10
-7	Create a file with UNIX v. 7 format, if none exists.
Effective only with 
.bd
-r.
.bp
.in -10
At most, one of the flags [drtx] may be present.
If none are present, 
.bd
-t 
is assumed.
Similarly, at most one of the flags [67] should be present.
If none are present,
Whitesmith's library file format is assumed when a new library is 
created by 
.bd
-r.

The Whitesmith's library format consists of .in 15
.rm 79
.he "          lpr (1)                        4/6/83                         lpr (1)
.fo "                                           -#-"
.ti -5
.bd
NAME
.br
.bd
lpr
- line printer spooler


.ti -5
.bd
SYNTAX
.br
.bd
lpr [-igpqrs] file ...


.ti -5
.bd
SUMMARY
.br
(A less technical description follows.)

.bd
Lpr
causes each of the named files to be queued for printing.
If  no file names are given,  the standard input (generally  your
terminal) is used.

Options:

.in +5
.ti -5
-i	Print the file "in place" without copying.

.ti -5
-p	Pause before printing, send a message to the terminal,
and delay until the command "lpr -g" is entered.

.ti -5
-g	Go.  Starts the printer daemon up again after a pause.

.ti -5
-q	Display the printer queue.
The owner and size of each queued file is displayed on the standard output
(usually your screen).

.ti -5
-r	Remove all files in the queue owned by you.

.ti -5
-s	Stop the daemon.
The queued files are not removed.
.in -5

Alternate printers are accessed by namewith "print" below).

.ti -5
-p	Pause before printing.
When it comes your file's turn at the printer,
the daemon will send a message to your terminal
and delay until the command "lpr -g" is entered.
This is intended to allow the insertion of special forms or the like.

.ti -5
-g	Go.  Starts the printer daemon up again after a pause.

.ti -5
-q	Display the printer queue.
The owner and size of each queued file displayed on the standard output
(usually your terminal).

.ti -5
-r	Remove all your files in the qus such as "dpr", "xpr", etc.
See below for details.


.ti -5
.bd
DESCRIPTION
.br
In a single user system, the basic idea of printing
is very simple:
you have only one printer and a machine which is
able to run only one person's programs at a time.

In a multi-user system, things may not be so simple:
there may be more than one printer, and
two users may wish to use the same printer at the same time.
The lpr program addresses these difficulties.

.in +5
Here's how it works in principle.
(This indented sectioeue.
If the file being removed is also being printed,
the printing will be prematurely curtailed.

.ti -5
-s	Stop the daemon.
A fatal signal is sent to the daemon.
The queued files are not removed, so they will be started over
again next time an lpr command is executed.
If you want to remove the files, use lpr -r.

.in -5

.ti -5
.bd
EXAMPLES

The simplest way to print a file is:

	lpr filename

This does not perform such services as skipping over creases in
the paper, numbering the pages, etc. (Often, you n is optional material,
not needed by the ordinary user.)

Say that several users all wish to print files.
All of them type "lpr filename" at once.
Each one uses the same or a different
file name as is his or her preference.

Each of the several lpr programs creates a uniquely named file
in the "spooling directory" and copies the files
which the users wish to print into these files.

Each of the several lpr programs attempts to initiate a printer
"daemon". Because of locking mechanisms, only one succeeds.
(З И Й К Л М Н О Р С Т У Ф                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       A daemon is a process, just like the ones run from
terminals, except that it exists independently of any terminal.
It performs its tasks (see below) without human intervention.

All of the lpr programs finish loading their files into the
spooling directory.  Meanwhile, the daemon is still alive and
running.

It scans the spooling directory and observes that it has
several files waiting in line to be printed.

It determines which one is next in line and starts printing that one.

.in -5
Now on to the practicdo not want these
services, since they were performed by another program such as
"form" or Wordstar.)  If you do want these services, type

	print file | lpr

This sends the output of the print program (which names, dates,
ans paginates) to the spooler.

If you are using the "form" program (see
.bd
form
in this manual),
you can format and print at the same time by typing

	form file | lpr

(If you simply type "form file", the output goes to your screen.)

If you want to print directly from your screen, withal description.
.br
.bd
Lpr
options:

.in +5
.ti -5
-i	Print "in place".
Normally files to be printed are copied
into the spooler's directory.
With the the  -i option specified,
only the name of the file will be remembered
and it will be read and sent to the printer at print time.
It is therefore important that the file not be removed
before the print finishes.
Using lpr this way saves time if
you have an enormous file to print,
but does not work if the material to be printed
is not a file (see the example out going through
the formalities of creating a named file and running it through lpr
simply type

	lpr (ret)

Then type your text.  When you are finished, type

	(ret)
	(control-D)

Be aware that when you do this you will not have special effects
(like bold print)
and you will not have a disk file of the text.

To do a "form feed", type:

	lpr (ret)
	(ret)
	(control-D)

This causes a file to be queued which contains a single line-feed character.
Lpr generates a printer form-feed after each file it prints.


.ti -5
.bd
ALTERNATE PRINTERS
.br
The name by which the spooler is invoked is significant.
When invoked as "lpr", it uses the directory

	/usr/spool/lpr

for spooling, and it decides which device to write to by looking in the
configuration file "/etc/ttys" for a line containing the word "lpr".
For instance, if the following line occurs in /etc/ttys

	ttyC  lpr  1200

then the lpr program will write to port ttyC at 1200 baud.
(See ports (4) if you don't know what ttyC means.)

Suppose that you want to suppcall is restricted to the super-user.
Conventional use requires that all special devices be kept in the one
directory, "/dev".


.in -5
.bd
NOTES
.br
.in +5
Warning:  it is dangerous to have to separate nodes
with the same type and major/minor number.
If you want multiple names, use 
.bd
ln.


.in -5
.bd
SEE ALSO
.br
.in +5
ln (1), rm (1), mkdir (1), mode (1)
                                                                                                                                ort a second printer.
Say that it is connected to ttyD, runs at 9600 baud,
and requires hardware handshaking.
Think of a name for it such as "dpr" and put the following
line in the ttys file:

	ttyD  dpr  9600	  shake

(The order of the words is not significant.)
Finally, make a link to lpr named "dpr" by typing

	cd /bin
	ln lpr dpr

Now when you type the command "dpr file",
the spooler will write to
ttyD at 9600 baud, and it will use

	/usr/spool/dpr

for spooling. (It will create this directory automatic.in 10
.rm 79
.he "          man (1)                        4/6/83                         man (1)
.fo "                                           -#-"
.bd
NAME
.br
.in +5
.bd
man
- manual


.in -5
.bd
SYNTAX       
.br
.in +5
.bd
man [N] program name ...


.in -5
.bd
DESCRIPTION   
.br
.in +5
.bd
Man
prints documentation (if it exists) for each named program.
Complete on-line documentation is resident on the Micronix system.
.sp
The "N" option directs 
.bd
man
to a numbered or particular section of the fially,
so that you don't have to do it in advance.)


.ti -5
.bd
SEE ALSO
.br
print (1), form (1),
cables (4), ports (4), printers (4),
ttys (5)

.ti -5
.bd
FILES
.nf
/usr/spool/lpr - spooling directory
/usr/spool/lpr/pid - contains the daemon's process ID
/etc/ttys - To find out where to send the output
                                                                                                                                les.
.sp
Typing  
.sp
.ti +10
.bd
ls /bin
.sp
displays the system programs. Typing
.sp
.ti +10
ls /usr/man
.sp
displays the sections that contain the documentation for the
Reference Manual.
.sp 2
.in -5
.bd
EXAMPLE
.br
.in +5
The command line
.ti +8
.sp
.bd
man man

prints this page.
.sp 2
Entering
.ti +8
.bd
.sp
man 2 stty

prints the stty.2 file instead of stty.1.
                                                                                                                                . mknod.1       - man.1         , cc.1          + more.1        * od.1          ) help.1        ( cp1.1         ' cp2.1         & cpp.1         % ddt.1         $ fsck.1        # group.1       " hex.1         ! link.1        @ mount.1       ? ncheck.1      > newuser.1     = obj.1         < owner.1       ; ptc.1         : td.1          9 tee.1         8 umount.1      7 du.1          6 file.1        5 chmod.1       4 tty.1         3 wall.1        2 cu.1          1 su.1          P pilot.1       O rp.1          .in 10
.rm 79
.he "          cc (1)                         4/6/83                          cc (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
cc
- C and Pascal compiler

.in -5
.bd
SYNTAX           
.in +5
.br
.bd
cc [options] file ...

.in -5
.bd
DESCRIPTION    
.in +5
.br
.bd
Cc
is the Whitesmiths' C compiler supervisor; it accepts several 
types of arguments:

Those ending with ".p" are assumed to be Pascal source files and
are converted to ".c" files.
Arguments ending .in 10
.rm 79
.he "          mknod (1)                      4/6/83                       mknod (1)
.fo "                                           -#-"
.bd
NAME
.br
.in +5
.bd
mknod
- create special file


.in -5
.bd
SYNTAX         
.br
.in +5
.bd
mknod name type major minor


.in -5
.bd
DESCRIPTION    
.br
.in +5
Type is either b or c for block special or character special.
Major and minor are the major and minor device numbers, respectively.
A special file is created (mode 777) with the given name.
This with ".c" are taken to be C source files and
are compiled with each relocatable object module left in the file
named for the source with ".o" substituted for ".c".

In the same way, arguments whose names end with ".s" are taken to be
A-natural source files and are compiled to produce an ".o" file.

The following options are meaningful to 
.bd
cc:

.in +10
.ta 10
.ti -10
-c	Suppress the loading phase of the compilation, and force 
object file(s) to be produced for each source file.

.ti -10
-S	Produce A-natural output.
A-natural is Whitesmith's narrative assembly language
and is one of the intermediate products of a
C compiler run.
Normally the A-natural version exists only in a temporary
file which "cc" removes.
Each of the named ".c" files and ".p" files is compiled
into a similarly named ".s" file.

	cc -S prog.c

would produce a file "prog.s" containg the A-natural translation of the given C source program.

.ti -10
-i name	Passed on to 
.bd
cpp, 
the C compiler preprocessor. Name
is a prefix to be used onrial


Ritchie, D.M.,
.ul
C Reference Manual, 
(Addison-Wesley, 1976).


cpp (1), cp1 (1), cp2 (1), as (1), ld (1), lib (1)
                                                                                                                                                                                                                                                                                                                                                                                                 "# include <files>".

.ti -10
-o file	The result of the compilation will be written on the named file.
If no "-o" option is given, the output is written to "a.out"

.ti -10
-lX	Library inclusion.  The file "/lib/libX.a" will be included in
the linking phase of the compilation.  An example is included below.

.ti -10
-lS	Use the standard I/O library.  Note that this only affects the
loading phase of the compilation.  If you use the library, your programs
should include the line:

.ce
.bd
# include <stdio.h>.in 15
.rm 79
.he "          more (1)                       4/6/83                        more (1)
.fo "                                           -#-"
.bd
.ti -5
NAME
.br
.bd
more - file perusal filter for fast terminals


.ti -5
.bd
SYNTAX       
.br
.bd
more [file ...]


.ti -5
.bd
DESCRIPTION
.br
.bd
More
allows you to scroll through the named files on a video terminal,
one screenfull at a time.
At the bottom of the screen, it prints "--More--" and waits.
Press carriage return to continue, delete to qu

.ti -10
-cpm	Compile to run under CP/M.

.ti -10
-ws	Use the Whitesmiths' C library.

.ti -10
-xN	where N is a number.  Arguments of this type are passed on to
pass 2 of the compiler; see 
.bd
cp2.

.ti -10
.bd
-z	Strip out control Z's from 
C source files produced with the aid
of CP/M programs (for instance).
The -z flag arranges for a precleaning of your source files.
The "clean" utility is used to accomplish this.
(See clean in section 1 of the Micronix reference manual).
The source files are cleaned iit.
If no file names are given, the standard input is used.


.ti -5
.bd
EXAMPLES
.br


To view a couple of files one screenfull at a time:


	more file1 file2


To view some documentation without having to use
START/STOP control keys:

	man upm | more


                                                                                                                                                                                                                                                                n place.

.in -10

.ti -5
.bd
EXAMPLES
.br
To compile echo.c:

	cc echo.c -o echo -ws

To compile a program which uses the Standard I/O library.

	cc prog.c -o prog -lS

To compile a program to be run under the CP/M operating environment:

	cc prog.c -o prog.com -cpm

Or with the Standard I/O library and for CP/M:

	cc prog.c -o prog.com -cpm -lS

If you want to see what's going on:

	cc a.c -v

And the compiler passes and flags will be displayed as they are run.

If you have written you own library, put it.in 10
.rm 79
.he "          od (1)                         4/6/83                          od (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
od, hd
- octal or hex dump


.in -5
.bd
SYNTAX         
.in +5
.br
.bd
od [-bcdox] file

.in -5
.bd
DESCRIPTION   
.in +5
.br
.bd
Od
dumps file in one or more formats.
If no file name or "-" is given, the standard input is used.
The following flags are understood:


.in +10
.ta 10
.ti -10
-b	Interpret bytes in octal.

.ti -10
-c	Inte in /lib
and then:

	cc prog.c -o prog -lnew

To create an object module

	cc -c prog.c

(The -c stands for compile only (no link))


To construct an executable program from several previously
produced object modules:

	cc a.o b.o c.o d.o -o out -lS

To run a compile in the background (so you don't have to wait)

	cc prog.c -o prog -lS &




.in -5
.bd
SEE ALSO
.in +5
.br
Kernighan, B.W. and D.M. Ritchie,
.ul
The C Programming Language,
(Prentice-Hall,
1978).


Kernighan, B.W.,
.ul
Programming in C - A Tutorpret bytes in ASCII.

.ti -10
-d	Interpret words in decimal.

.ti -10
-h	Hex words

.ti -10
-o	Interpret words in octal (default).

.ti -10
-x	Interpret bytes in hexadecimal.
.sp 2
.in -10


.in -5
.bd
EXAMPLE
.sp
.nf
	od -bo file

                                                                                                                                                                                                                                                                .in 10
.rm 79
.he "          help (1)                       4/6/83                        help (1)
.fo "                                           -#-"
.bd
NAME
.br
.in +5
.bd
help
- help processor


.in -5
.bd
SYNTAX       
.br
.in +5
.bd
help [N] topic ...


.in -5
.bd
DESCRIPTION   
.br
.in +5
.bd
Help
prints documentation (if it exists) for each named topic.
Complete on-line documentation is resident on the Micronix system.

.bd
Help
is the same program as
.bd
man,
execpt that when it is called as "hel is the same as 1 except that 4 to 8 bytes of data 
are forced to a multiple of a four-byte boundary.

A bound of 3 is the same as 2, except that eight bytes of data
(doubles) are forced to a multiple of an eight-byte boundary.

.ti -10
-c	Ignore case distinctions in testing external identifiers
for equality, and map all names to lower case on output.  
By default, case distinctions do matter.

.ti -10
-e	Do not force loading of external references that are declared,
but never defined or used inp" it
looks first in /usr/help for a file with the same
name as the given topic.
Then, like
.bd
man,
it searches /usr/man/man0, ..., /usr/man/man9 in order.
These are the directories containing the corresponding
sections of the Micronix Reference Manual:

.nf
	/usr/man/man1	Programs
	/usr/man/man2	System Entries
	/usr/man/man3	Libraries and subroutines
	/usr/man/man4	Devices
	/usr/man/man5	File formats
	/usr/man/man6	Other programs (such as CP/M programs)
.fi


The "N" option directs 
.bd
help
to the corres an expression.  Default loads all declared
external references.

.ti -10
-l	Take integers and pointers to be four bytes long.  Default is 2 bytes.

.ti -10
-m	Treat each structure/union as a separate name space, and require x.m to mean
that x is a structure and m is one of its members.

.ti -10
-n#	Ignore characters after the first # in testing external identifiers
for equality.  Default is 7; maximum is 8.

.ti -10
-o file	Write the output to the specified file and write error messages to
Sponding section of the manual.


.in -5
.bd
EXAMPLE
.br
.in +5
The command line

.ti +8
.bd
help help

prints this page.


Entering

.ti +8
.bd
help 2 stty

prints the stty.2 file instead of stty.1.


.in -5
.bd
SEE ALSO
.br
.in +5

man (1)
                                                                                                                                                                                                                                                                TDOUT.  Default is STDOUT for output and STDERR for error messages.

.ti -10
-r#	Assign no more than 
.bd
# 
variables to registers at any one time,
where 
.bd
# 
is reduced modulo 4.  Default is three register variables.

.ti -10
-u	Take "string" as an array of unsigned characters, not an array of 
characters.

.in -10
If <file> is present, it is used as the input file instead of the default,
STDIN.
On many systems, the 
.bd
-o 
option and <file> are mandatory
because STDIN and STDOUT
are interpreted as .in 10
.rm 79
.he "          cp1 (1)                        4/6/83                         cp1 (1)
.fo "                                           -#-"
.bd       
NAME
.br
.in +5
.bd
cp1 - 
parse C programs


.in -5
.bd
SYNTAX         
.in +5
.br
.bd
cp1 <flags> <file>


.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
Cp1 
is the parsing pass of the C compiler.
It accepts a sequential file of
lexemes from the preprocessor, 
.bd
cpp, 
and writes a sequential file
of flow graphs and parse trees, suitable for input to text files, and hence become corrupted.


.in -5
.bd
EXAMPLE
.in +5
.br
.bd
Cp1 
is usually sandwiched between 
.bd
cpp 
and 
.bd
cp2, 
as in:
.sp
.nf
.bd 3
		cpp -x -o temp1 file.c
		cp1 -o temp2 temp1
		cp2 -o file.mac temp2


.fi
.in -5
.bd
SEE ALSO
.in +5
.br
cpp (1)
.br
.ul
C Compiler User's Manual 
for language definition.


NOTE: This program and documentation are products of Whitesmiths, Ltd. 
a machine-dependent
code generator, 
.bd
cp2.
The operation of 
.bd
cp1 
is largely independent of any target machine.
The flag options are:
.sp
.in +10
.ta 10
.ti -10
-a	Compile code for machines with separate address and data registers.
.sp
.ti -10
-b#	Enforce storage boundaries according to 
.bd
#, 
which is reduced modulo 4.  

A bound of 0 leaves no holes in structures or 
auto allocations. 

A bound of 1 (default) requires short, intermediate and 
longer data to begin on an even bound.  

A bound of 2.in 10
.rm 79
.he "          cp2 (1)                        4/6/83                         cp2 (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
cp2
- generate code for 8080 C programs      
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
cp2 -[flags] <file>
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
Cp2
is the code generating pass of the C compiler.  It accepts a
sequential file of flow graphs and parse trees from 
.bd
cp1
and writes a sequential file of A-Natural statements, suitable 
for input to the A-Natural assembler, 
.bd
as.

As much as possible, the compiler generates free-standing code; but
for those operations which cannot be done compactly, it generates inline
calls to a set of machine-dependent library routines.  The 8080  runtime
library is documented in Section IV of the C Reference Manual.

The flags are:
.sp 2
.in +5
.ta 5
.ti -5
-p	Emit profiler calls on entry to each function.  No profiler
is currently provided for the 8080.

.ti -5
-o *	Write the output file * and write.in 10
.rm 79
.he "          cpp (1)                        4/6/83                         cpp (1)
.fo "                                           -#-"
.bd 
NAME
.in +5
.br
.bd
cpp - 
preprocess defines and includes


.in -5
.bd
SYNTAX       
.in +5
.br
.bd
cpp <flags > <files>


.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
Pp 
is the preprocessor used by the C compiler, to perform 
.bd
#define, #include, 
and other functions signaled by a 
.bd
# 
before actual compilation begins.
It can be used to advantage, how the error messages to 
STDOUT.  Default is STDOUT for output and STDERR for error messages.

.ti -5
-x#	Map the three virtual sections, for Functions (04), Literals (02),
and Variables (01), to the physical sections Code (bit is one) and Data
(bit is zero).  thus, "-x4" is for separate I/D space, "-x6" is for
ROM/RAM code, and "-x7" is for compiling tables into ROM.  Default
is 6.

.in -5
If <file> is present, it is used as the input file instead of the
default STDIN.  On many systems, <file> is mandatory ever, with most language processors.
The flag options are:

.in +10
.ta 10
.ti -10
-c	Do not strip out
.bd
/* comments */ 
nor continue lines that end with 
.bd
\.

.ti -11
-dname	Define name; if the definition string (=def) is included, it
reads it in before the input; if "=def" 
is omitted, the definition is taken as "1".  The "name" and 
"=def" must be in the same argument - no blanks are permitted
unless the argument is quoted.  Up to ten definitions may be 
entered in this fashion.
.sp
.ti -10
-i 	Chanbecause STDIN is
interpreted as a text file, and hence becomes corrupted.

Files output from 
.bd
cp1
for use with 8080 code generator should be generated with: "-b0" to
eliminate holes in structures and auto allocation, and "-n8" for full
length external names.  A boundary of "-b1" (default) is also acceptable
if compact storage is less important than compatibility with data
structures on other machines.  Note that use of the
.bd
cp1
flags "-b2", "-b3", or "-1" will produce bizarre behavior and incorrect
cge the prefix used with
.bd
#include <file name> 
from the default ("") to the string prefix.  Multiple prefixes
to be tried in any order may be specified, separated by the "|"
character.

.ti -10
-o     	<File> can be specified with flag.  Writes the output to the 
specified file and writes error messages to STDOUT.
Default is STDOUT for output and STDERR for error
messages.
On many systems, the 
.bd
-o 
option is mandatory with 
.bd
-x
because STDOUT is interpreted as a text file, and hence becomes corrupode in
.bd
cp2,
often with no meaningful diagnostics.

Wherever possible, labels in the emitted code each contain a comment
which gives the source line from which the code immediately following
obtains.
.sp 2
.in -5
.bd
EXAMPLE
.in +5
.br
.bd
cp2
usually follows
.bd
cpp
and
.bd
cp1
as follows:
.sp
.in +5
.bd 3
cpp -x -o temp1 file.c
.br
cp1 -b0 -n8 -o temp2.80 temp1
.br
cp2 -o file.s temp2
.in -5
.sp 2
.in 
.in 5
.bd
SEE ALSO
.in +5
.br
as (1), cp1 (1), cc (1), cpp (1)

NOTE: This program and documentation ted.

.ti -10
-p?	Change the preprocessor control character from
.bd
# 
to 
.bd
?.

.ti -10
-s?	Change the secondary preprocessor control character from
.bd
@
to 
.bd
?.

.ti -10
-x	Put out lexemes for input to the C compiler 
.bd
cp1,
not lines of text.

.ti -10
-6	Put out extra newlines and/or SOH ('\') codes to
keep source line numbers
correct for UNIX/V6 compiler or ptc.

.in -10
.bd
Cpp 
processes the named file, or STDIN if none is named,
in the order specified,
writing the resultant text to STDOUT.
Pare products of Whitesmiths, Ltd. 
                                                                                                                                                                                                                                                                                                                                                                                                reprocessor actions are described in detail in the
Preprocessor section of the C Compiler User's Manual.  The 
presence of a secondary preprocessor control character 
permits two
levels of parameterization.
For instance, the invocation
.sp
.ce
.bd
cpp -c -p@
.sp
will expand 
.bd
define 
and 
.bd
ifdef 
conditionals, leaving all 
.bd
# 
commands and
comments intact.  Invoking 
.bd
cpp 
with no arguments would expand both 
.bd
@ 
and 
.bd
# 
commands.  The flag, 
.bd
-s#, 
effectively disables the secondary control character.


.in -5
.bd
EXAMPLE
.in +5
.br
The standard for writing C programs is
.sp
.nf
.bd 8
        /* name of program
         */
	#include <std.h>

	# define MAXN	100

	COUNT things[MAXN];
	etc.
.fi
.sp
The use of uppercase identifiers is not required by 
.bd
cpp,
but is strongly recommended to distinguish parameters
from normal program identifiers and keywords.


.in -5
.bd
NOTES
.in +5
.br
Unbalanced quotes (' or ") may not occur in a line, even in
the absence of the -x flag.  Flotaing constas on the left
and ASCII characters on the right.
If no address follows 
.bd
d, 
the next 128 bytes, starting at the given
location, are displayed.

Finally, if two addresses are given, that part of the file
which lies between the two addresses is
displayed.

Examples:
.nf
.sp
.bd
	d 0, ffff
.sp
.bd
	d
.sp
.bd
	d 55
.sp
.bd
	d a000
.sp 2
.fi
.ti -3
.bd
f - fill (requires three arguments)
.sp
.ti -3
.bd
f A, B, C
.sp
The portion of the file which
lies between addresses A and B (inclusive)
is overwritten with ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее                                                                                                                                                                                                                                                                a flood of the character C.

If C is large, then the low order byte of C
is used.

.ti 5
Example:

.bd
.ce
f 0, 3000, e5

writes E5s from 0 to 3000 hex.


.ti -3
.bd
r filename (Read)

The file on which 
.bd
ddt
is operating is changed to filename if possible.

.ti 5

Examples
.bd 5
.nf

		r new
		r /usrsrc/cmd/pbx.c
		r /etc/dtab
		r a/b


.fi
.ti -3
.bd
s (address) Substitute

Takes 0 or 1 arguments. if no argument is given, the currently remembered
file address is.in 10
.rm 79
.he "          ddt (1)                        4/6/83                         ddt (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
ddt 
- a program for examination and manipulation of 
.nf
      non-text files
.fi
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
ddt [file]
.sp 2
.in -5
.bd
DESCRIPTION    
.in +5
.br
.bd
Ddt 
can be a handy tool for programmers and others 
who need to manipulate arbitrary (i.e. non-ASCII text) files.

It is functionally analogous to CP/M's DDT used.  The 
.bd
substitute
command allows you to examine and optionallly change the file on a 
byte-by-byte basis.
After entering the 
.bd
substitute 
command you will be in "substitute" mode
until you exit
it by entering a single period on
a line.
If while in the substitute mode you press RETURN,
the byte you were looking at will remain unchanged
and you will be stepped to the next byte.
If you enter a byte value and then push RETURN,
the byte will be changed to the byte entered.
.sp 2
.in -3
.bd
/ (ad, 
but the Digital Research version works with memory, while this one
works on files.

Changes made to a file under 
.bd
ddt 
are immediately effective.
There is no intermediate buffer as with some editors.

Addresses (mentioned below)
are given in hexadecimal, (up to six digits long).
If the first character of an address is an 
.bd
' 
(apostrophe), the value of that number will be that of the ASCII 
character following.


The following are valid addresses:
.sp
.nf
.bd 2
0	6	b	B	'y	
c3b0 	78ba4  'A      FFdress)
.br
.bd
// (search)
.sp
.in +3
.bd
Ddt 
has the ability to search for patterns in a file.
When the "/" command is given, you will be asked to enter a 
series of bytes to search for.
If an address follows the "/", the search commences at the given
address in the file.
Without an address, the search commences at the current file address.

The "//" command is a shorthand to search again for the previously
given pattern.

FF	'/
.sp
.fi
Address list may be comma-separated or space-separated.

The following are valid address lists:
.sp
.nf
.bd
0,ffff	0,5,7	0,3000,'a	'a,'b,'c
.sp
.fi
No command takes more than three addresses.
Extra addresses are ignored.
.sp
.bd
Ddt 
always remembers the last file address accessed.
In most cases, if you give no address on the next
command, this old remembered address is used.
.bp
Commands:
.sp 
.ti -3
.bd
d - display
.sp
Takes 0, 1, or 2 arguments.
Displays the contents of the file in hex
byte.in 10
.rm 79
.he "          fsck (1)                       4/6/83                        fsck (1)
.fo "                                           -#-"
.bd       
NAME
.in +5
.br
.bd
fsck 
- file system check and repair
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
fsck [-t] [-n] filesystem
.sp 2
.in -5
.bd
DESCRIPTION 
.in +5
.br
.bd
Fsck 
is a complete Micronix file system maintenance package.
System crashes
may cause the
Micronix file systems
(as well as standard UNIX version 6 file systems)
to become internally inconsistent
in potentially dangerous ways to your data.
It is also possible for the physical device on which
a file system resides to develop unreadable spots.
The 
.bd
fsck 
program rectifies these inconsistencies and maintains the file system.

.bd
NOTE! 
Do not run
.bd
fsck
on an 
.ul
active 
file system.  As a rule of thumb, you should run fsck while in
single-user mode.

If information in the file system is changing
while 
.bd
fsck 
is taking its "snapshot" of the state of the file system,
it will get(5), icheck(1), dcheck(1), df (1), ncheck (1)
                                                                                                                                                                                                                                                                                                                                                                                                 the wrong idea and will try and fix
things that were not wrong in the first place.
By typing
.sp	
.ti +5
.bd
fsck filesystem
.sp
where 
.bd
filesystem 
is the name of the device on which the file system
in question lives, you can bring your file system completely up to par.

The device is referred to by its name as it appears in the /dev directory
(e.g. /dev/fla).

If no specification is made, 
.bd
fsck 
searches for and attempts
to fix all file system problems.
.sp 2
Options:
.sp
.in +5
.ta 5
.ti -5
-.in 10
.rm 79
.he "          group (1)                      4/6/83                       group (1)
.fo "                                           -#-"
.bd        
NAME
.in +5
.br
.bd
group 
- examine or change the group of a list of files
.sp 2
.in -5
.bd
SYNTAX   
.in +5
.br
group [-name] file ...
.sp 2
.in -5
.bd
DESCRIPTION    
.in +5
.br
Associated with each Micronix file is a group number.
The group number is used to determine group access permission.
If you are running a single user, informal, or vet	Test all of the blocks on the file system to
see that each is readable.  Systems on large disks may take some 
time to complete.
.sp
.ti -5
-n	No changes will be made.  
.bd
Fsck 
will only look and give you its professional opinion on what it would do
under the circumstances.
.sp 2
.in -5
.ti -7
.bd
Fsck 
can fix:
.sp
.in +5
.ti -5
-	Two files claiming the same block.  The block is copied 
and a copy is given to each file.
.bp
.ti -5
-	File containing a bad block.  An attempt is made to copy 
the bad blry low
user-population system, the whole concept of groups
may be irrelevant to you.

The 
.bd
group
command can be used to view the group names of files.
The relationship of group names to group numbers is entirely
established by the file "/etc/group" [see 
.bd
group 
(5)].
.sp
.bd
Group 
prints the group name for each file given.
If the file's group number has no name, the group number is printed in
decimal instead.

If the first argument to 
.bd
group 
is a group name preceded by a hyphen,
.bd
group 
attock; in any case, a new block is allocated to fill the 
spot.  The bad block is assigned to a file in the directory 
"badblocks".
.sp
.ti -5
-	Duplicates in the free list.
.sp
.ti -5
-	Allocated blocks in the free list.
.sp
.ti -5
-	Blocks missing from the free list.
.sp
.ti -5
-	Bad block in the free chain.  The free list is rebuilt from scratch.
.sp
.ti -5
-	File for which there is no directory entry (an orphan). 
An entry is made in the "lost+found" directory.
.sp
.ti -5
-	Missing directory self link "."empts to change 
the group of each of the named files to the given name.
.sp 2
.in -5
.bd
EXAMPLES
.sp
.in +5
.ti +5
.bd	
group file1 file2 file3

to discover which group each of these files belongs to.
.sp 2
.ti +5
.bd
group file1 file2 file3

to discover which group each of these file belongs to.
.sp 2
.ti +5
.bd
group -sales file1 file2 file3

to "give" each of the files to the group named "sales."
.sp 2
.in -5
.bd
SEE ALSO
.in +5
.br
group (5)
.sp 2
.in -5
.bd
FILES
.in +5
.br
/etc/group - group name <-.
.sp
.ti -5
-	Missing directory parental link "..".
.sp
.ti -5
-	Disconnected directory. Appropriate links are made to 
directory names in "lost+found," if necessary.
.sp
.ti -5
-	Imbalanced directory entry - link counts. Resolved in 
favor of the directory entries, i.e., the link count is changed.
.sp 2
.in -5
.ti -7
.bd
Fsck 
cannot fix:
.sp
.in +5
.ti -5
-	Bad blocks in the i-list or super block.
.sp
.ti -5
-	Ridiculous numbers in the super block.
.sp 2
.in 
.in 5
.bd
SEE ALSO
.in +5
.nf
.br
filesystem > group number relationships

                                                                                                                                                                                                                                                                                                                                                                                                .in 10
.rm 79
.he "          hex (1)                        4/6/83                         hex (1)
.fo "                                           -#-"
.bd
- translate object file to ASCII formats
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
hex -[flags] <ifile>
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
Hex
translates executable images produced by 
.bd
link 
to Intel standard hex format or to Motorola S-record object file 
format.  The executable image is read from <ifile>, if specified,
otherwise from the file xe of address.

.ti -5
e)	The checksum byte.

.in -5
An end record also begins with a ":" and is written as digit pairs
with a trailing checksum.  Its format is:

.in +5
.ti -5
a)	A zero byte "00".

.ti -5
b)	Two bytes for the start address, in the same format as the
load offset in a data record.

.ti -5
c)	A one byte "01".

.ti -5
d)	The checksum byte.

.in -5
.ul
S-Record Files

A file in Motorola S-record format is a series of records each
containing the following fields:

.bd
.ti +5
<S field><count><addr>q.

The flags are:
.sp 2
.in +5
.ta 5
.ti -5
-h	Do not start record for Intel hex files.

.ti -5
-m*	Insert the string *, instead of <ifile>, into the
Motorola SO record generated when -s is given.

.ti -5
-r##	Interpret the input file as "raw" binary and not as
object file.  Output is produced as described below, in either 
format, except
that the starting address of the module is specified by the long
integer ##.

.ti -5
-s	Produce S-record rather than the default hex format.

.ti -5
+#	Start output with <data bytes><checksum>

All information is represented as pairs of hexadecimal digits, each
pair representing the numerical value of a byte.

<S filed> determines the interpretation of the remainder of the 
line; valid S fields are "SO", "S1", S2", "S8", "S9". <count> indicates
the number of bytes represented in the rest of the line, so the total
number of characters in the line is <count> * 2 + 4.

<addr> indicates the byte address of the first data byte in the data
field. SO records have two zero bytes asthe #th byte.  # should be between 0 and
one less than the value specified by the -#flag. -4 +3 produces bytes
3, 7, 11, 1 5, ...; -2 +0 produces all even bytes; -1 +1 outputs all
odd bytes; 0 is the default which outputs all bytes.

.ti -5
-#	Output every #th byte. -2 outputs every other byte, -4 every
fourth; 1 is the default which outputs all bytes.

.in -5
Output is written to STDOUT.

.ul
Hex Files

A file in Intel hex format consists of the following records, in
the order listed:

.in +5
.ti -5
1)	A " their address field; S1 and
S2 records have <addr> fields of two and three bytes in length, 
respectively; S9 and S8 records have <addr> fields of two and three
bytes in length, respectively, and contain no data bytes. <addr> is
represented most significant byte first.

The SO record contains the name of the input file, formatted as
data bytes.  If input was from xeq, XEQ is used as the name.  S1 and
S2 records represent text or data segment bytes to be loaded.  They
normally contain 32 image bytes, output$" alone on a line to indicate the end of the (non-existent)
symbol table. If -h is specified, this line is omitted.
.bp
.ti -5
2)	Data records for the text segment, if any.  These represent
32 image bytes per line, possibly terminated by a shorter line.

.ti -5
3)	Data records for the data segment, if any, in the same format
as the text segment records.

.ti -5
4)	An end record specifying the start address.

.in -5
Data records each begin with a ":" and consist of pairs of hexadecimal
digits, each pair rep                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          resenting the numerical value of a byte.  The
last pair is a checksum such that the numerical sum of all the bytes
represented on the line, modulo 256, is zero.  the bytes on a data
record line are:

.in +5
.ti -5
a)	The number of image bytes on the line.

.ti -5
b)	Two bytes for the load offset of the first image byte.  The
offset is written more significant byte first so that it reads correctly
as a four-digit hexadecimal number.
	
.ti -5
c)	A zero byte "00".

.ti -5
d)	The image bytes in increasing order in increasing order of address;
the last record of each segment may be shorter.  The text segment
is output first, followed by the data segment.  S9 records contain
only a two-byte start address in their <addr> field; S8 records
contain a three-byte address.  The start address of an object file
is the start of the text section.

<checksum> is a single byte value such that the numerical sum of
all the bytes represented on the line (except the S field),
taken modulo 256, is 255 (0xFF).
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
.bd
Hex
returns success if no error messages are printed, that is, if
all records make sense and all reads and writes succeed; otherwise
it reports failure.
.sp 2
.in -5
.bd
EXAMPLE
.in +5
.br
The file hello.c, consisting of :
.sp
.ti +5
.bd
char *p {"hello world"};

when compiled produces the following Intel hex file:
.sp
.in +5
.bd
% hex hello.o
.br
.bd
$
.br
.bd
:0E000002006856C6C6F20776F726C640094
.br
.bd
:000000010
.bp
.in
.in 5
.bd
SEE ALSO
.in +5
.br
link (1), obj (1), cc (1), as (1), ce first
unused location past the initialized data area.

.ti -5
et*	If the symbol * is referenced, make it equal to the first
unused location past the text area.

.ti -5
-h	Suppress headers in output file.  This should be specified
only for stand-alone modules such as bootstraps.

.ti -5
-l*	Append library name to the end of the list of files to
be linked, where the library name is formed by appending * to "/lib/lib".
Up to ten such names may be
specified as flags; they are appended in the order specified.
p1 (1), cp2 (1), cpp (1)

NOTE: This program and documentation are products of Whitesmiths, Ltd.,
                                                                                                                                                                                                                                                                                                                                                                                                
.ti -5
-o*	Write output module to file *. Default is xeq.

.ti -5
-r	Suppress relocation bits.  This should not be specified if
the output module is to be input to 
.bd
link. 

.ti -5
-tb##	Set text bias to the long integer ##.  Default is location zero.

.ti -5
-t	Suppress symbol table.  This should not be specified if the output
module is to be input to
.bd
link.

.ti -5
-u*	Enter the symbol * into the symbol table as an undefined
public reference, usually to force loading of selected modules from
a libr.in 10
.rm 79
.he "          link (1)                       4/6/83                        link (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.bd
link
- combine object files
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
link -[flags] <files>
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
Link
combines relocatable object files in standard format for any target
machine, selectively loading from libraries of such files made
with
.bd
lib,
to create an executable image for
stand-alone execution, or ary.

.ti -5
-x*	Specify placement in the output module of the input .text and
.data sections.  The 2-weighted bit of # routes .text input, the
1-weighted bit, .data.  If either bit is set, the corresponding
sections are put in the text segment output; otherwise they go in the
data segment.  The default value used, predictably, is 2.

.in -5
The bss section is always assumed to follow the data section in
both the input and output files.  It is perfectly permissible for text
and data sections to overlap, as for input to other binary reformatters.

The flags are:

.in +5
.ta 5
.ti -5
-a	Make all relocation items and all symbols absolute.  Used
to prerelocate code that will be linked elsewhere, and is not to be
relocated.

.ti -5
-c	Suppress code output (.text and .data), and make all symbols
absolute.  Used to make a module that only defines symbol values for
specifying addresses in shared libraries, etc.

.ti -4
-db##	Set data bias to the long integer ##. Default is end of
text section, rounded up to required far as 
.bd
link
is concerned; the target machine may or may not make sense of this
situation (as with separate instruction and data spaces).

The specified <files> are linked in order; if a file is in library
format, it is searched once from start to end.  Only those library
modules are included which define public symbols for which there are
currently outstanding unsatisfied references.  Hence, libraries
must be carefully ordered, or rescanned, to ensure that all 
references are resolved.  By special dispstorage boundary for the 
target machine.

.ti -5
-dr#	Round data bias up to ensure that there are at least #
low-order binary zeros in its value. Ignored if -db## is specified.

.ti -5
-d	Do not define bss symbols, and do not complain about undefined
symbols.  Used for partial links, i.e., if the output module is to
be input to
.bd
link.

.ti -5
-eb*	If the symbol * is referenced, make it equal to the first unused
location past the bss area.
.bp
.ti -5
ed*	If the symbol * is referenced, make it equal to thensation, flags of the form "-1*"
may be interspersed among <files>.  These call for the corresponding
libraries to be searched at the points specified in the list of files.
No space may occur after the "-1", in this usage.

.ul
File Format

A relocatable object image consists of a header followed by a text
segment, a data segment, the symbol table, and relocation information.

The header consists of an identification byte 0x99, a configuration
byte, a short unsigned int containing the number of symbol tabl !#$%&'()*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                s
that byte minus 128, times 256, plus 175 plus the value of the next
relocation byte after that one.

A symbol code of zero calls for no further relocation; 1 means that a
change in the text bias must be added; 3 means that a change in bss
bias must be added.  Other symbol codes call for the value symbol
table entry indexed by the symbol code minus 4 to be added to the
item.

Each symbol table entry consists of a value int, a flag byte, and a
name padded with trailing NULLs.  Meaningful flag values are o fe bytes,
and six unsigned ints giving: the number of bytes of object code
defined by the text segment, the number of bytes needed by the bss
segment, the number of bytes needed for stack plus heap, the text segment
offset.  Byte order and size of all ints in the header are
determined by the configuration byte.

The configuration byte contains all information needed to fully
represent
the header and remaining information in the file.  Its value val
defines the following fields: ((val & 07) << 1) + 1 is the nor
undefined, 4 for defined absolute, 5 for defined text relative, 6
for defined data relative, and 7 for defined bss relative.  To this
is added 010 if the symbol is to be globally known.  If a symbol still
undefined after linking has a non-zero value, 
.bd
link
assigns the symbol a unique area, in the bss segment, whose length
is specified by the value, and considers the symbol defined.  This
occurs only if -d has not been given.
.sp 2
.in -5
.bd
RETURNS
.in +5
.bd
Link
returns success if no error messageumber
of characters in the symbol table name field, so that values [0, 8) 
provide for odd lengths
in the range [1, 15].  If (val & 010) then ints are four bytes;
otherwise they are two bytes.  If (val * 020) then ints are
represented least significant byte first, otherwise most 
significant byte first; order is assumed purely ascending or
purely descending. (val & 0140) >> 5 is the strongest for bounds
that are multiples of 0, 2, 4, 8 bytes.  If (val & 0200) no relocation
information is present in this fils are printed to STDOUT, that is,
if no undefined symbols remain and if all reads and writes succeed;
otherwise, it returns failure.
.sp 2
.in -5
.bd
EXAMPLE
.in +5
.br
To load the C program echo.o 
with separate I/D spaces for Micronix (UNIX/V6):
.sp
.ti +5
.bd
% link -1c.11 -rt -db0 /lib/Crts.o echo.o; taout

or with read-only text section:
.sp
.ti +5
.bd
% link -1c.11 -rt -dr13 /lib/Crts.o echo.o; taout
.bp
And to load the 8080 version of echo under CP/M:
.sp
.nf
.bd
A:link -hrt -tb0x0100 a:chdr.o echo.oe.

Relocation information consists of two successive byte streams, one
for the text segment and one for the data segment, each terminated by a zero
control byte.  Control bytes in the range [1, 31] cause that many bytes
in the corresponding segment to be skipped; bytes in the range [32, 63]
skip 32 bytes, plus 256 times the control byte minus 32, plus the
number of bytes specified by the relocation byte following.

All other control bytes control relocation of the next short or long
int in the correspondin a:clib.a a:mlib.a
.sp 2
.fi
.in -5
.bd
SEE ALSO
.in +5
.br
hex (1), lib (1), lord (1), obj (1), cc (1), as (1), cp1 (1),
cp2 (1), cpp (1)       

NOTE: This program and documentation are products of Whitesmiths, Ltd.,
                                                                                                                                                                                                                                                                g segment. If the 1-weighted bit is set in
such a control byte, then a change in load bias must be subtracted
from the int.  The 2-weighted bit is set if a long int is
being relocated instead of a short int.  The value of the control byte 
right-shifted two places, minus 16, constitutes a "symbol code".

A symbol code of 47 is replaced by a code obtained from the byte
or bytes following in the relocation stream.  If the next byte is less than
128, the symbol code is its value plus 47.  Otherwise, the code i.in 15
.rm 79
.he "          mount (1)                      4/6/83                       mount (1)
.fo "                                           -#-"
.bd        
.ti -5
NAME
.br
.bd
mount 
- mount a file system


.ti -5
.bd
SYNTAX
.br
mount [device] [directory] [-r]


.ti -5
.bd
DESCRIPTION
.br
.bd
Mount 
is used to extend the Micronix file system
to include additional storage devices.
If you think of the system of files as
a large tree, mounting is akin to hanging
an additional ornament off a particular bough.

"Device" refers to the device name as it appears in the /dev directory.
The device name can be entered as (for example) "/dev/fla", or you can
abbreviate it to simply "fla".
"Directory" is the position in the existing file system 
that you want the additional file system to begin. The optional
.bd
-r
flag means to mount the device as read-only.

.bd
Mount 
with no argument displays the current list
of mounted file systems.
It's advisable to just type "mount"
to take a look before proceedinnd repair,
use
.bd
mkfs
to create a fresh, EMPTY file system.

A file system may be mounted "read/write" or "read only".
The system is guaranteed to change the contents of
file systems mounted "read/write".
File systems mounted "read only" are guaranteed
to be unchanged.

You may request read only status with the "-r" flag.
Sometimes read only status is foisted upon you,
for instance, if you mount a write-protected floppy diskette.


.ti -5
.bd
EXAMPLES

Mounting a device and addressing a file on it:g.
That way you'll have a better idea of what's going on.

When you mount a device, you must specify a certain directory
that already exists.  Use 
.bd
mkdir
to establish a new directory, if necessary.

Typically, you would enter something like 

.bd
        mount fla /b

This will graft the file system of floppy drive A into the root directory
as directory "b".  From then on Micronix can access any of the files 
on the floppy through the path /b/...

It's somewhat traditional to mount devices
o

Suppose you have a floppy diskette with a directory "letters" containing 
a file "memo5".  The floppy drive is currently unmounted and you want to
edit memo5.

To mount the device (assume it is the first 8" floppy, named fla, 
and you already have a directory named f in the root directory):

.bd
	mount fla /f

To access the file for Micronix editing:

.bd
	edit /f/letters/memo5

Observe that this path name crosses a device boundary, from the root
device (probably an integrated hard disk) tn directories in the root directory.
"/f" or "/b" or "/c" or "/h", for example.
This is not compulsory.
It is done perhaps because it simplifies
the concept of the file system.

If you mount a device on a directory that already has entries in it,
it will appear that the existing entries are thrown away.  Never fear;
they are still there, and will reappear when the device is unmounted (
.bd
umount
).  This situation would occur in the example above if directory /b
already had files in it from some othe+,-./01245678                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      r device.

When the system is initially 
brought up, no devices are mounted (except the root device,
which technically isn't mounted, since it is the core to which
everything else is ultimately attached.  Leave this one to
to the semanticians.)  However, you can stick mount commands into
the
.bd
rc
file, so that whatever devices you want are automatically mounted
whenever you go from single- to multi-user mode.

A device may be mounted at most once.
If you mount and mount again with the same
devio the 8" floppy.  It's
entirely possible to mount a second floppy drive to the first floppy's
file system, say, alongside memo5 in this example.  You could mount it
as "g", for instance (
.bd
mount flb /f/letters/g
) and then address it as /f/letters/g/...  This path thus crosses two
device boundaries.  This can go on as long as you have devices and controllers,
but why?  It's better to just mount them all to the root.


To prepare a mini-floppy for use under Micronix:
 
.bd
	formatdj -i5 -t40 -sce, the second instance will fail,
yielding the message "File or device busy".

Mount refuses to mount a device which does not appear to contain a 
file system.
A quick check is made to see that the device in question
is reasonable.
If you thought the device did contain a file
system, but mount disagreed, you may run "fsck",
which sometimes has the power to turn a non-file-system
into a file-system and in any event will give it a good try.
With new diskettes or a hard disk file system that is corrupted beyo2 -b512 -d0

(5 inch, 40 track, 2 sides, 512 bytes, drive 0)

.bd
	mkfs /dev/mfa

(make file system on mini-floppy A)

.bd
	mount mfa /f

(mount the new file system)

.bd
	mkdir /f/newdir

(make a new directory on the diskette)

.bd
	cp * /f/newdir

(copy some files over)

.bd
	umount mfa

(dismount the mini-floppy)


.bd
.ti -5
NOTES

Regarding
.bd
5.25" floppy disk drives,
note that
there are two ways of addressing these devices in mount commands.
Since they are configured for double-sided use, you would normally
refer to them as "mfa2", "mfb2", and so on.  The exception to this rule
is the case where a diskette was formatted for single-sided
use.  When using such a diskette, refer to the device 
.bd
without
the "2", for example, as simply
.bd
mfa.

.bd
WHEN TO UNMOUNT?
you may ask.  When using either size of floppy drive, 
.bd 2
always unmount (umount command) before removing a floppy diskette from
the drive.
Therefore, if you need to switch diskettes, first unmount the device.in 10
.rm 79
.he "          newuser (1)                    4/6/83                     newuser (1)
.fo "                                           -#-"
.bd          
NAME
.in +5
.bd
newuser 
- add a user account to the system
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
newuser
.sp 2
.in -5
.bd
DESCRIPTION   
.in +5
.br
.bd
Newuser 
is largely interactive and fairly self-explanatory.

A menu-type display will ask you for the new user name
and for the name of a group to put him in.
It makes a directory for the new us,
then change diskettes, and finally remount.

In the unusual case of changing hard disk drives (that is, actually
unplugging one and plugging in another), unmount the first before
disconnecting it.

To those of you who recoil at the use of such a verbal construction as
"unmount", we apologize.  But if we asked you to dismount a device,
you'd just have silly images of spurs jangling while you drawl
"Whoa, there, old floppy."



.ti -5
.bd
SEE ALSO
.br
.bd
umount (1)
- to reverse the effects ofer, setting the owner and
group properly, makes a new entry in the "/etc/passwd" file and
possibly makes a new entry in the "/etc/group" file.
.sp
.bd
Newuser 
is intended to make it easy to add new users.
You may want to customize your "/etc/passwd" file, however.
.bd
Newuser 
utilizes locking, so that two newusers running
simultaneously will not interfere with each other.

FILES
/etc/passwd
/etc/group

.sp 2
.in -5
.bd
SEE ALSO
.in +5
.br
passwd (5), group (5), group (1), owner (1), passwd (1)
 
.bd
mount.
.br
.bd
fsck (1)
- to repair file systems.
.br
.bd
mkdir (1)
- to create a new directory.
.br
.bd
mkfs (1)
- to create a file system.
.br
.bd
rc (5)
- to automate selected mounts.
                                                                                                                                                                                                                                                                .in 10
.rm 79
.he "          obj (1)                        4/6/83                         obj (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
obj
- examine object files
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
obj -[flags] <files>
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
Obj
permits inspection of relocatable object files in standard form for
any target machine.  Such files may have been output by an assembler,
combined by link, or archived by
.bd
lib. Obj
can be used either t.in 10
.rm 79
.he "          ncheck (1)                     4/6/83                      ncheck (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
ncheck 
- generate names from i-numbers
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
ncheck [-i numbers] filesystem
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.bd
Ncheck 
generates a pathname vs. i-number list for the named file system.

If -i is specified along with a list of numbers, pathnames
are reported only for the i-numbers specified.
.sp 2
.io check their size and configuration, or to
output information from their symbol tables.

The flags are:
.sp
.in +5
.ta 5
.ti -5
-d	Output all defined symbols in each file, one per line.  Each
line contains the value of the symbol, a code indicating to what the
value is relative, and the symbol name.  values are output as the
number of digits needed to represent an integer on the target machine.
Relocation codes are: "T" for test relative, "D" for data relative,
"B: for bss relative, "A" for absolute, or "?n -5
.bd
EXAMPLES
.in +5
.ti +5
.bd
ncheck /dev/root

to generate a list of all the file names and their i-numbers
for the root file system.
.sp 2
.ti +5
.bd
ncheck -i 26 87 204 /dev/root

to look up path names for a few selected i-numbers.
.sp 2
.in -5
.bd
SEE ALSO
.in +5
.br
fsck (1), icheck (1), dcheck (1)
                                                                                                                                " for anything
.bd
obj
does not recognize.  Lowercase letters are used for local 
symbols, uppercase for globals.

.ti -5
-g	Print global symbols only.

.ti -5
-i	Print all global symbols with the interval in bytes between
successive symbols shown in each value field.  Implies the flags
-[d u v].

.ti -5
-o	Output symbol values in octal.  Default is hexadecimal.

.ti -5
-s	Display the sizes, in decimal, of the text segment, the
data segment, the bss segment, and the space reserved for the
runtime stack plus heap, followed by the sum of all the sizes.

.ti -5
-t	List type information for this file.  For each object file
the data file is: the size of an integer on the target machine, the
byte order it observes, the most restrictive storage bound it
enforces, and the maximum number of characters it permits in an external
name.  If the file is  library, the type of library is output and
the information above is output for each module in the library.
.bp
.ti -5
-u	List all undefined symbols in each file.  If -d is.in 10
.rm 79
.he "          owner (1)                      4/6/83                       owner (1)
.fo "                                           -#-"
.bd          
NAME
.in +5
.br
.bd
owner 
- file ownership
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
owner [-user] file ...
.sp 2
.in -5
.bd
DESCRIPTION   
.in +5
.br
Every Micronix file has associated with it a user I.D. number -
the "owner" of the file.

The 
.bd
owner 
utility program allows you to examine or change
this file owner number.
.bd 
NOTE:
Only the su also 
specified, each undefined symbol is listed with the code "U".  The
value of each symbol, if non-zero, is the space to be reserved for it
at load time if it is not explicitly defined.

.ti -5
-v	Sort by value; implies the -d flag above.  Symbols of
equal value are sorted alphabetically.

.in -5
If no flags are given, the default is -[d u]; that is, all symbols
are listed, sorted in alphabetical order on symbol name.  If more
than one of the flags -[d s t y] is selected, then type information
is outputper-user may change the owner of a file.

There is usually a name for each user I.D. number.
These names are kept in the system-wide file "/etc/passwd."

In order to discover who owns a file, type:
.sp
.ti +5
.bd
owner filename
.sp 
The program will look up the owner of the file
and attempt to express it as a user name.
If this is not possible, it will list the owner as a
numerical user I.D.
.sp 2
To change the owner of a file, type
.sp
.ti +5
.bd
owner -newowner filename
.sp
.bd
newowner 
may be a user nam first, followed by segment sizes, followed by the symbol list
specified with -d or -u.

<files> specifies zero or more files, which must be in relocatable
format, or standard library format, or in UNIX/V6 library format, or
UNIX/V7 library format.  If more than one file, or a library, is
specified, the name of ech separate file or module precedes any
information output for it, each name followed by a colon and a 
newline; if -s is given, a line of totals is also output.  If no
<files> are specified, or if e or a user I.D. number (names are recommended).

The 
.bd
owner 
program works equally well with list of files:
.sp
.ti +5
.bd
owner file1 file2 file3 file4 file5

reports on the ownership of each of the named files.
.bp
.in -5
.bd
EXAMPLES
.sp
.in +5
.ti +5
.bd
owner -root a.out	

makes file "a.out" belong to user "root".
.sp 2
.ti +5
.bd
owner a.out

reports who owns the file "a.out".
.sp 2
.in -5
.bd
FILES
.in +5
.br
/etc/passwd - user I.D. <-> name relationships

"-" is encountered on the command
line, xeq is used.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
.bd
Obj
returns success if no diagnostics are produced, that is, if all
reads are successful and all file formats are valid.
.sp 2
.in -5
.bd
EXAMPLE
.in +5
.br
To obtain a list of all symbols in a module:
.sp
.in +5
.bd 7
% obj alloc.o
.br
0x00000074T_alloc
.br
0x00000000U_exit
.br
0x000001feT_free
.br
0x000000beT_nalloc
.br
0x00000000U_sbreak        
.br
0x00000000U_write         
.in 
.in 5
.sp 2
.bd
SEE ALSO
.br
.in.in 10
.rm 79
.he "          ptc (1)                        4/6/83                         ptc (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
ptc
- Pascal to C translator
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
ptc -[flags] <file>
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
Ptc
is a program that accepts as input lines of Pascal text and produces
as output a corresponding C program which is acceptable to the
Whitesmiths, Ltd. C compiler.  If <file> is present, it is taken as
the +5
lib (1), link (1), lord (1), cc (1), as (1), cp1 (1), cp2 (1), cpp (1) 

NOTE: This program and documentation are products of Whitesmiths, Ltd.,
and are sold separately.
                                                                                                                                                                                                                                                                 Pascal program to translate; otherwise input is taken from STDIN.     

The flags are:
.sp 
.in +5
.ta 5
.ti -5
-c	Pass comments through to the C program.

.ti -5
-f	Set the precision for reals to single precision (float).
Default is double.

.ti -5
-k	Permit pointer types to be defined using type identifiers from
outer blocks.  Default is ISO standard, i.e., the type pointed to must
be defined in the same type declaration as the pointer type definition.

.ti -5
-m#	Make # the number of bits in MAXINT excluding the sign bit,
e.g., MAXINT becomes 32767 for -m15, 1 for -m, etc.  Default for
MAXINT is 32766 [sic].  Acceptable values for # are in the range
[0, 32).

.ti -5
-o*	Write the C program to the file * and diagnostics to STDOUT.
Default is STDOUT for the C program and STDERR for diagnostics.

.ti -5
-r	Turn off runtime array bounds checks.

.ti -5
-s#	Make # the number of bits in the maximum allowable set size,
i.e., the size of all sets whose base type is integer becomes the
specified power of two.  Acct incremental dump.
It uses a system-wide dump table to remember the times
directories were dumped.

Before beginning a major dump,
you should have a stack of formatted
diskettes.
These diskettes must be pre-formatted
but they need not contain file systems.
.bd
Td 
will notice that a diskette has no file system
and ask you if it should make one.
It will then call the 
.bd
mkfs 
program for you.

Unlike some other back-up systems, this program's back-ups are in 
file system
form, meaning it is easy to look teptable values are in the range [0, 32).
Default is 8 (256 elements).

.in -5
The CP/M operating system implementation on the Intel 8080 and Zilog
Z80 restricts the acceptable value for # to the range [0, 16]; for
maximum portability, this restriction should be honored.

Identifiers are mapped to uppercase to keep from conflicting with those
declared as reserved words in C.  Moreover, structure declarations may
be produced that contain conflicting field declarations; and
declarations are present for libraryhrough
a dump.

Options:
.sp 2
.in +5
.ta 5
.ti -5
-a	All. Dump all files. Normally only files under 1000 
blocks long are dumped.
.sp
.ti -5
-dN	Day. Dump only files newer than N days old.
.sp
.ti -5
-hN	Hour.  Dump only files newer than N hours old. Note: The -d 
and -h options are additive.
.bp
.ti -5
-i	Incremental.  Dump files changed since the last dump of 
the directory.
.sp
.ti -5
-u	Update.  Update the central dump table at the conclusion 
of a successful dump.
.sp
.ti -5
-v	Verbose.  Each file nam functions that may not be needed.
All of these pecadillos are forgiven by the use of appropriate C
compiler options.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
.bd
Ptc
returns success if it produces no diagnostics.
.sp 2
.in -5
.bd
SEE ALSO
.in +5
.br
cc (1), as (1), cp1 (1), cp2 (1), cpp (1)


NOTE: This program and documentation are products of Whitesmiths, Ltd.,
                                                                                                                                e is printed as it is dumped.
.sp 2
.in
.in 5
.bd
EXAMPLES
.in +5
.sp
.ti +5
.bd
td . /dev/dja

To do a full dump of the current directory onto a floppy A.
.sp 2
.ti +5
.bd
td -h2 /b/sally /dev/djb

Dump the last 2 hours work on floppy drive B.
.sp 2
.ti +5
.bd
td -a / /dev/djb

Full dump of the entire file system.
.sp 2
.ti +5
.bd
td -i -u newdir /dev/fla
.sp
Incremental dump of the directory "newdir" onto floppy drive A
(but with alternate sectoring).
.sp 2
.ti +5
.bd
td -d2 -h12 . /dev/dja

Dump of every.in 10
.rm 79
.he "          td (1)                         4/6/83                          td (1)
.fo "                                           -#-"
.bd     
NAME
.in +5
.br
.bd
td 
- tree dump (file backup)
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
td  [-a] [-dN] [-hN] [-i] [-u] [directory] [device]
.sp 2
.in -5
.bd
DESCRIPTION   
.in +5
.br
.bd
Td 
provides reasonably convenient back-up service.
.sp
.bd
Td 
dumps potentially all the files in the named
directory and in all of its sub-directories recursively.
thing that's changed since two and half days ago.
.bp
.nf
.bd 5
    mount /dev/dja /f
    cd /f
    dir
    cp file /a/fred/restored
    umount /dev/dja
.sp
.fi
Example procedure to restore a dumped file.
.sp 2
.in -5
.bd
FILES
.in +5
.br
/etc/dtab - the central dump table
.sp 2
.in -5
.bd
SEE ALSO
.in +5
.br
cptree (1), ncheck (1), mkfs (1)

                                                                                                                                .sp
.bd
Td 
is intended to provide the facility to save
files on floppy diskettes (although it can be used in other ways).

It doesn't matter if your dump won't all fit on one floppy diskette;
.bd
td 
allows you to change diskettes on the fly.
Each disk is filled to capacity, then the program asks
for operator service.
In this sense it does need a bit of babysitting.
.sp 
.bd
Td 
incorporates the facility to do incremental dumps.
That is, each new back up contains only files which have
changed since the las.in 10
.rm 79
.he "          tee (1)                        4/6/83                         tee (1)
.fo "                                           -#-"
.bd       
NAME
.in +5
.br
.bd
tee 
- a pipe fitting
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
tee [-a] [-i] [file ... ]
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
Tee 
reads the standard input and writes it unchanged to the
standard output, making copies in each of the named files.

Options
.sp
.in +5
.ta 5
.ti -5
.bd
-a	Append.  
Data is appended to the end of each named file, rather than being 
over-written.
.sp
.ti -5
.bd
-i	Ignore.	 
Interrupt signals are ignored.
.sp 2
.in
.in 5
.bd
EXAMPLE
.sp
.in +5
.ti +10
.bd
edit | tee record

will keep a record of the editor's responses to commands.
                                                                                                                                                                                                                                                                the file must be in your current 
directory and you have to use one or the other flag (it makes no difference which  
one you choose in this case).  Obviously, du will report only the size of this
one file, in the format
.br
.sp
.bd
        #####   filename

Next, if you specify a directory name, it too must be contained in the current
directory, or else you can give the path leading to it from the root directory
(e.g. du -a /usr/bin).  Du will begin at this directory and proceed down the
tree through.in 10
.rm 79
.he "          umount (1)                     4/6/83                      umount (1)
.fo "                                           -#-"
.bd           
NAME
.in +5
.br
.bd
umount 
- dismount a file system
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
umount special
.sp 2
.in -5
.bd
DESCRIPTION   
.in +5
.br
The named special file is dismounted.

The special file must have been previously mounted
with the 
.bd
mount 
command.

It is not permitted to dismount a file system with files still open.
Diagnost all the files and subdirectories contained within it.

If you don't give a file name or a directory, du assumes that you mean the current
directory.
.sp 
Options:

.ta 5
.in +5
.ti -5
-a	All.  This flag gives you the most detail, with a block count for each file.
There will also be subtotals for directories embedded in the list, so don't
be surprised if the bottom line doesn't look like the sum of all the numbers
above it.

.ti -5
-s	Summary.  Only a grand total is displayed.

.ti-5
Using neither flag pric: "Device busy".

Sometimes it is necessary to use the "change directory" command 
before dismounting a device. As an example:
.sp
.ti +5
.bd
cd /; umount /dev/dja 
.sp 2
.in -5
.bd
EXAMPLE
.in +5
.ti +5
.bd
umount /dev/dja

to dismount a floppy.
.sp 2
.in -5
.bd
SEE ALSO
.in +5
.br
mount(1) - to mount file systems








                                                                                                                                oduces an intermediate level of detail, where only
directory subtotals and a grand total are displayed.
.sp 2
.in
.in 5
.bd
EXAMPLES
.in +5
.br
To find out just how much space your whole system is using,
simply enter:
.sp
.ti +5
.bd
du -s /

To find out which directory has that enormous file in it:
.sp
.ti +5
.bd
du /
(to begin at the root directory, in this case)

To get the name of the offending file itself:
.sp
.ti +5
.bd
du -a directoryname

To get an overview of the top layer of directories in the f.in 10
.rm 79
.he "          du (1)                         4/6/83                          du (1)
.fo "                                           -#-"
.bd
NAME   
.in +5
.br
.bd
du 
- occupied disk space, in blocks (512 bytes per block)
.sp 2
.in -5
.bd
SYNTAX
.br
.in +5
du [-a] [-s] [name ...]
.sp 2
.in -5
.bd
DESCRIPTION
.in +5 
.br
.bd
Du 
is a very useful memory management tool that reports how much disk space
is currently being held by the various files in the system.  The flags
determine the level oile system:
.sp
.ti +5
.bd
du -s /*
.sp 2
.in -5
.bd
NOTES
.br
.in +5
If there are several links to the same file, the space used by that file is
counted only once.  Space used by directories themselves and by pointer blocks
is not counted, as these are considered overhead and in any event do not amount
to more than a few percent.  Du doesn't give special consideration to files
with large vacant areas within them; the empty space is counted as if it were filled.
.sp2
.in -5
.bd
SEE ALSO
.br
.in +f detail given in the reports.  (
.bd
-a = all files; -s = grand total; neither = directories
)
Du
is complementary to the
.bd
df
function, which reports free disk space available per device.

There are several combinations of flags (a, s, or neither) and arguments (file
or directory names), each of which produces a slightly different breadth of
coverage and level of detail.  The examples in the following section address the
practical uses of 
.bd
du.

First, if you specify a particular filename, 5
df (1),
ls (1)


                                                                                                                                                                                                                                                                                                                                                                                                .in 10
.rm 79
.he "          file (1)                       4/6/83                        file (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
file
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
file file1 ...
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
File 
attempts to guess the type of each named file.
Currently, the following types of files are recognized:

.in +5
A-natural source file

Block special file

C source file

CP/M text file

Character special file

Data

Directory

Empty

E proceeding, you should have a basic understanding of the Micronix file
protection system.

The file protection system allows or denies access to files according to
two criteria, namely, WHO wants to get into the file and HOW he wants to 
use it.  There are three categories of users and three types of access, so there
are nine bits altogether which define the accessibility of the file.  WHO is
represented in chmod commands by these symbols:
.br
.sp
.in +9
.ti -4
a - for "all", in other words, the restrictioxecutable

Pascal source file

Ratfor source file

Relocatable module

Software Tools archive

Text file

Text processor input

Whitesmiths library

.in -5


                                                                                                                                                                                                                                                                ns that you 
specify will apply to everyone in the system.  As you will see, "a" is not one
of the user categories mentioned above, but rather the sum of all three.
.sp   
.ti -4
u - for "user", in effect the owner or creator of the file.
The owner of a file may be changed by way of the "owner"
program.  Note that only the superuser (login "root") may use
the "owner" program.
.sp
.ti -4
g - for "group", which comprises users with the same group
code as the owner.  (See "group" in the Files section
of this m.in 10
.rm 79
.he "          chmod (1)                      4/6/83                       chmod (1)
.fo "                                           -#-"
.bd                            
NAME
.in +5
.br
.bd
chmod 
- change mode of files (accessibility for reading, writing, & execution; set
user/group number bit; set write lock bit)
.sp 2
.in -5
.bd
SYNTAX   
.in +5
.br
chmod mode file(s) 
.sp 2
.in -5
.bd
BRIEF DESCRIPTION
.in +5
.br
chmod performs three general functions as noted above: (A) setting up accessanual). 
.sp     
.ti -4
o - for "others", who is anyone else in the system not covered 
by u and g.  
.sp
.in -9
Now, as to HOW these various parties may wish to use the file in question,
there are these three categories:
.sp
.in +9
.sp    
.ti -4
r - to read the file;
.sp 
.ti -4
w - to write to the file;
.sp
.ti -4
x - to execute the file, in the case of a program or control string; or search,
in the case of a directory.
.sp
.in -9
There is a final set of symbols to consider, the operands +, -, and =.
"+ 
restrictions to files, (B) setting/resetting the user and group number bits,
which is typically used to get around access restrictions under special 
circumstances, and (C) setting/resetting the write lock bit, which prevents two
processes from writing to the file simultaneously.
The format
of access mode commands is:
.nf
.bd
.sp
	chmod [u g o a] [= - +] [r w x] filename(s)
.fi
.sp
The format of user/group bit commands is:
.sp
.nf 
.bd
	chmod [u g] [+ -] s filename(s)
.fi
.sp
Finally, the format of write " will add a privelege that had earlier been restricted.  "-" accomplishes
the reverse.  "=" enables only those HOW's listed after it, and disables
those not listed.  The general form that chmod expressions take is:
.sp
.bd       
	chmod WHO operand HOW filename(s)

When performing chmod, keep in mind that files are created without restrictions
of any sort.
.sp
.in -5
.bd
EXAMPLES A.  File Access
.sp
.in +5
To set up a new file so that only the owner has access (of all 3 types):
.br
.bd 
chmod go-rwx filenalock commands is
.sp 
.nf
.bd
        chmod [+ -] l filename(s)
.fi
.sp
You should also refer to the entry on the ls program in this section of the
manual, as it closely relates to the following explanation.  Use the "-l" flag
with the ls program to monitor the effects of chmod operations.
.sp 3
.bd
.ti -5
EXPLANATION A.  File Access
.sp
Read, write, and execute access are controlled through the "mode" argument, 
which may be an octal number (e.g. 677) or a combination of symbols as described
below.  Beforeme

To restore full priveleges to everyone in the system for a file that had 
previously been restricted:
.br
.bd
chmod a+rwx filename

To understand the difference between the + and = operands, consider the
following.  If the group now has read and execute priveleges only, and you
want to give them write ability as well:
.br
.bd
chmod g+w filename
will work, as will
.br
.bd
chmod g=rwx filename.
However, if you had entered 
.bd
chmod g=w filename, 
the read and execute priveleges would have been unintentio`abcdefgijklmno                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   (which must be entered by Mary) is:
.br
.bd
chmod u+s EXTRACT

The letter u means that Mary's user number will be attached to any file openings
requested by EXTRACT.  If the file PAYROLL was owned by someone other than Mary
but to which she had group priveleges, the letter g would be used in place of or
in addition to the u in the command above.

To reset the user/group number flags, repeat the command you used to set them, but
with a minus sign in place of the plus sign.
.sp 2
.in -5
.bd
EXPLANATION C. Senally revoked.

Multiple chmod operations for the same file may be strung together in one
command, using commas but no spaces.  Say you have a new (unrestricted) file
that you want to set up so that you have full priveleges, the group has read
only priveleges, and others cannot access it at all.  This could be your
command:
.br
.bd
chmod g=r,o-rwx filename
.sp 3
.in -5
.bd
EXPLANATION B.  Set User/Group Number Bit(s)
.in +5
.sp
As noted above, when you try to open a file (either directly or through a prograt Write Lock Bit
.sp
.in +5
This function is quite simple and straightforward.  Without the write lock bit
set, Micronix allows anyone with write access to a file to update it whenever
they please.  However, some files can become corrupted if write accesses become
interleaved.  As an example, a data base system written for a single user (such 
as Personal Pearl) should have its critical data files write-locked.  This is
accomplished by setting the write lock bit.  Enter:
.br
.sp
.bd
	chmod +l database

Thism 
you are executing) your user and group numbers are checked to see whether
access is permitted.  Now, suppose you execute a program owned by someone else,
but to which you have been granted execute priveleges.  However, within that program
is a command to read a file to which only the programmer has access.  You will
not be granted access, and a "permission denied" message is passed back to your unhappy 
process.

The chmod function being described here can often overcome this sort of problem
by replacing sets the lock flag on the database. (Since the lock
flag applies equally to user, group, and others, the
WHO part of the operand may be left out here.)
Using a minus sign in place of the plus in the above command will reset the bit,
thus removing the lock.
.sp3
.in -5
.bd
SEE ALSO
.in +5
group(5) ls(1) owner(1)
                                                                                                                                                                                                       your user and/or group number with the numbers of the owner of the
program.  See the example that follows for further information.
.sp 2
.in -5
.bd
EXAMPLE B.  Set User/Group Number Bit(s) 
.in +5

Programmer Mary has written a program EXTRACT that reads year-to-date information
from her company's payroll file (PAYROLL).  It is decided that each system user 
should be allowed to look at his own payroll record.  So Mary modifies the
program accordingly, and enters
.bd
chmod go+x EXTRACT 
to open up the prev.in 10
.rm 79
.he "          tty (1)                        4/6/83                         tty (1)
.fo "                                           -#-"
.bd                                    
NAME
.in +5
.br
.bd
tty
- get terminal name
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
tty
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
Tty 
is a simple program that attempts to look
up the full path name and number of the current "tty" device 
(teletypewriter or terminal).
Normally, this is the name of the Micronix (terminal)iously
restricted execute privelege to other users.

However, when John tries to run the program, all he gets is the message
"PAYROLL: Permission denied."  What has happened is that user John has tried
to open the payroll file, which Mary owns and to which he has no access priveleges.
The solution in this situation is to invoke chmod so that when EXTRACT goes
to read PAYROLL, PAYROLL will think EXTRACT's owner (Mary) is running the
program, regardless of who is actually running it.

The command in this case port you
logged in on.

To ascertain your device number, enter the 
.bd
tty
command.
A typical response is
.sp
.ti +5
/dev/ttyB
.sp
meaning that you are on "ttyB".

If no associated file name can be found, the message "not a tty"
is printed instead.
.sp 2
.in -5
.bd
FILES
.in +5
.br
/dev - Directory in which to search for file names.
                                                                                                                                .in 10
.rm 79
.he "          wall (1)                       4/6/83                        wall (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
wall 
- write to all users
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
wall
.sp 2
.in -5
.bd
DESCRIPTION
.br
.in +5
.bd
Wall 
reads the standard input up to an end of file,
then sends this to the terminal of each currently logged in user.
You can enter

.bd4
	wall [return]
	message...
	more message...
	^D [control-D]

to broadcast a met to the baud rate
you can use for the remote port -
1200 baud is the highest recommended.
If the remote machine is another Micronix machine,
additional commands apply.
You may copy a file from local to remote machine via:
.sp
.nf
.bd
	~%put file
.sp
.fi
Or from remote to local via:
.sp
.nf
.bd
	~%take file
.sp
.fi
Note only text files may be copied reliably.
This need not be a drawback, however, because
any file can be converted into a text file, transferred,
and then converted back again.

Both the sendinssage with your terminal as the standard input.
Alternatively, you can broadcast the contents of a particular file
by entering

.bd
	wall < filename

Its normal use is to inform users of immediate system status.
.ul2
Only the super-user may use 
.bd
wall.
.sp 2
.in -5
.bd
EXAMPLE
.in +5
.bd3
	wall
	System going down in 3 minutes -- Please prepare 
	^D

After which, each user would see:

.ti +10
.bd
Broadcast message ...

followed by what appears above.
.sp2
.bd
.ti-5
SEE ALSO
.br
su (1) for eng and receiving processes recognize
.sp
.nf
.bd
	~>file

	~>
.sp
.fi
as starting and ending delimiters for file diversion,
so that in order to copy a file from a foreign system
to the local one, all you have to do is get the foreign system
to generate:
.sp
.nf
.bd
	~>filename
	Text of file ...
	more file ...
	~>
.sp
.fi
That is, a beginning marker, the text of the file, and then an ending
marker.

To get out of 
.bd
cu 
type:
.sp
.nf
.bd
	~.
.fi
.sp 2
.in -5
.bd
EXAMPLE
.in +5
.br
To set up communication ovtering superuser mode.
                                                                                                                                                                                                                                                                                                                                                                                                er a modem, get your hardware set up
and then type:
.sp
.ti +8
.bd
cu /dev/ttyC -s 300

In this example the modem would be plugged into Micronix
port C (the third one).

Typically, one must reverse the transmit and receive lines
in the cable running from the computer to the modem.
One reverses the wires running to pins 2 and 3 of the connector
at one end or the other.
                                                                                                                                .in 10
.rm 79
.he "          cu (1)                         4/6/83                          cu (1)
.fo "                                           -#-"
.bd           
NAME
.in +5
.bd
cu 
- call up
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
cu device [-s speed]
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
Cu 
may be used to connect to other machines through your
Micronix machine.

When the 
.bd
cu 
command is given, 
one process is set up to handle sending characters to the remote
system,
one is set up to receive th.in 10
.rm 79
.he "          su (1)                         4/6/83                          su (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
su 
- set user identification
.sp 2
.in -5
.bd
SYNTAX
.in +5
.br
su [name]
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
Su 
allows you to change your effective user ID in 
midstream, so to speak.

The most common use of this program is to temporarily
become a super-user
in order to install a program,
change a system-wide file,
kill ofem.
Much of this is not obvious to the user.

When 
.bd
cu 
is ready it prints a "~".
Thereafter, whatever you type will be immediately sent
to the remote port, and whatever is received from it is
sent to your terminal.
So, typically, you press a single key on your terminal,
Micronix takes it and re-transmits it to the remote machine,
which will usually send it back, at which point
Micronix receives it and sends it to your terminal
and you see the character on your screen!

There is definitely an upper limif an errant process
or other administrative task.

If no name is given, "root" is the default.  This puts you in super-user mode.
If "root" has a password, non super-users will receive a password prompt.

Another use for
.bd
su
is to grab
someone else's terminal without the delays of logging them out,
logging yourself in, and so on.  Any time enter su with a password-protected
name, you will receive a password prompt.
.sp
.in -5
.bd
EXAMPLE
.in +5
.br
su - to enter super-user mode.  

.ti-5
NOTE: Since the super-user has powers that are beyond the reach of normal users,
"root" should definitely be password-protected.  Use super-user with
caution and only when necessary.  System defenses that prevent you from
making catastrophic mistakes are suppressed in super-user mode.

.in -5
.bd
SEE ALSO
.br
.in +5
passwd (1)
                                                                                                                                                                                   ne
E - exit
J - jump 
M - match
N - new file
R - return
S - save
T - type
U - unix
W - wait
.fi
.in -20
.sp 2
.bd
.ce
Instruction Descriptions

.ti -5
.bd
A - accept - a: [variable]
.br
One line of input is accepted from the standard input.
If a variable name is given,
a copy of the accepted data will be stored in the variable.
.sp
Examples
.in +10
.nf
a:
a: $save
.sp 2
.fi
.in -10
.ti -5
.bd
C - call - c: *label
.br
Jump to the given label, but remember where you were.
If a return instruction (r:)
is encou.in 15
.rm 79
.he "          pilot (1)                      4/6/83                       pilot (1)
.fo "                                           -#-"
.bd
.ti -5
.bd
NAME
.br
.bd
pilot
- an author language
.sp 2
.ti -5
.bd
DESCRIPTION
.br
This program gets its name from and is loosely based upon
that set of programs written for the CP/M system under the generic name
PILOT, itself based upon some complex IBM software.

The present incarnation has adopted many of the ideas,
but is not totally faithful to thntered in the program flow after
the label, pilot will jump
back
to the instruction following
the call.
.sp
Example
.in +10
.nf
c: *output
e:
*output
t: Hello world!
r:

1) Call instruction jump down to "*output".

2) Type instruction - type "Hello world!"
.bp
3) Return - go back to just after the last call

4) exit - all done!
.fi
.in -10
.sp 2
.ti -5
.bd
D - define - d: $move data
.br
The string "data"
is evaluated if necessary and then
a copy of the resulting string
of characters is stored in the 
stringe original PILOT standard.

Pilot is an author language in the sense that it should
be possible for "authors," i.e. non-programmers, to
successfully and fairly rapidly get something working in the pilot 
language.

Pilot is a non-structured language,
but structured language enthusiasts may be assured that
"rp" (a rational pilot) is available as a preprocessor.
(See rp (1)).

In order to run something in pilot, one issues the command:
.sp
.bd
.ti +10
pilot filename
.sp
where the given filename refers to a "p variable "name".
Note that "$" denotes string variables.
.sp
Example
.in +10
.nf
d: $x The cheese
t: $x

1) Definition $x is set to "The cheese"

2) Type - "The cheese" will be typed.
.sp 2
.fi
.in -10
.ti -5
.bd
E - exit - e:
.br
This is a simple instruction.
Pilot quits when it encounters
an exit instruction.
Anything to the right of the colon is ignored.
.sp
Example
.nf
.in +10
e:

Stop the whole works right now.
.in -10
.fi
.sp 2
.ti -5
.bd
J - jump - j: *label
.br
Go to some other part of the current
ilot script".
Pilot will simply read the script and do whatever is requested.

To write a "pilot script" one needs only a way to get text
into a file.
Most text editors will suffice.


.bd
.ce
Pilot Operation

In general, pilot reads its input file, one line at a time,
performing the described actions before proceeding.
The general layout of a pilot command is:

.ti +5
.bd
*label command conditional : word1 word2 word3 ...

.bd
*label 
is a tag by which one may refer to this line elsewhere in the script.
Itpilot
script file and
continue executing instructions
from that point on.
If no label name is given,
pilot prints "Missing label"
and stops.
If there is no such label to be found
in the current
pilot script file,
"name: Label not found" is printed and pilot stops.
.sp
Example
.in +10
.nf
*top
t:Hello
j:*top
.sp
.fi
.in -10
This would print "Hello"
over and over again forever.

A more useful example:
.sp
.in +10
.nf
a:
m:yes
jn: *default
t: you typed yes
e:
* default
t: you didn't type yes
e:

1) Accept a li is optional, and in practice, most commands will not have labels.
A label may appear on a line by itself.

.bd
command
is a single letter command, discussed in detail
below.
.bp
.bd
conditional
is either the letter Y or N.
A conditional specifier is optional.
If one appears, the command will only do something
if the Y or N matches the current state of pilot's condition flag.

.bd
words 
are optional and specific to individual commands.


.bd
.ce
Instruction Summary

.nf
.in +20
A - accept
C - call
D - defi}~ЂЃ‚ѓ„†‡€‰Љ‹ЊЌ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ne from the controlling terminal

2) Match it against "Yes"

3) Jump to *default if the previous match failed.

4) type - "you typed yes" otherwise
.sp 2
.fi
.in -10
.ti -5
.bd
M - match - m: pattern,pattern,pattern, ...
.br
Compare the most recent input against the given list of patterns
and set pilot's condition flag based on the outcome.
The following instructions may base their behavior on the outcome
of these pattern comparisons.
Two results are possible:

1) The input matched one of the patterns (succve are typed.


.ti -5
.bd
U - unix - u: command
.br
The command to the right of the colon
is executed just as if it had been
typed as a command to the shell.
This command gives you access to the rest of the system.
This instruction can take much longer than any of the others
just to get set up.
If the sub-process created by a U instruction is interrupted
or otherwise abnormally terminated, pilot will stop.
.bp
Example
.nf
.in +10
u: ls
u: cat $file | form | lpr &
u: pilot zzz
.in -10
.fi

Each command is eess).
.sp
2) The input matched none of them (failure).
.sp
Comparison of each pattern is by a marching window scan.
.sp
Case is ignored, that is, a capital Q is considered to be the same
as a lower case q.
.sp 
Example
.in +10
.nf
m:a
m:one,two,three
.fi
.in -10

The first will succeed whenever the most recent terminal input
contained the letter "a" anywhere.

The second will succeed if the most recent input contained
any of the three given character sequences which form the words
one, two, three.
.sp 2
.tixecuted.
Note that it is possible for pilot
to continue before the command
finishes (ex. 2) or for there to
coexist several layers of pilot programs (ex. 3).


.ti -5
.bd
W - wait - w: [$variable] [number]
.br
Wait is just like "accept" above only it "times out"
after a certain period.
The default period is six seconds.
One can select a different period by placing a numeric value to
the right of the colon as one of the arguments.
If the specified time interval expires before
the RETURN key has been pressed, -5
.bd
N - new file - n: filename
.br
Fairly straightforward:
Pilot has been marching along executing instructions
in its pilot script file.
When it encounters the line
.sp
.nf
.bd
	n: newfile
.sp
.fi
pilot will have done with the current file and start executing instructions
with the first line in the file
named "newfile".
(There must, of course exist such a file, and it must be readable.)
Pilot stops if it can't read the given file.
.sp 2
.ti -5
.bd
R - return - r:
.br
Discussed in C - call (above).
A re then the data returned
is the single word "TIMEOUT"
which can later be tested.

Example
.in +10
.nf
w:
w: $data
w: 9
w: $fast 2

1) Accept data for a six second period.

2) Accept data; wait for six seconds; store it in "data"

3) Accept data; wait for nine seconds.

4) Accept data; wait for two seconds; store it in "fast"
.sp 2
.fi
.in 
.in 10
.ti -5
SEE ALSO
.br
rp - rational pilot
turn instruction causes a jump to the line following the 
most recently executed call
instruction.
If there are no calls for which there have been no returns,
pilot stops.
It returns out of pilot to the calling program, as it were.
Anything to the right of the colon is ignored.
.sp
Example
.in +10
.nf
r:
.fi
.in -10
.sp 2
.ti -5
.bd
S - save - s: $variable
.br
The current value of the input
terminal input register
is saved in the string variable whose name is given.
If no name is given,
no action is taken.
.in 10
.rm 79
.he "          rp (1)                         4/6/83                          rp (1)
.fo "                                           -#-"
.bd
NAME
.in +5
.br
.bd
rp
- rational pilot to pilot translator


.in -5
.bd
SYNTAX         
.br
.in +5
.bd
rp
<rational_pilot_file >pilot_file
.sp 2
.in -5
.bd
DESCRIPTION   
.in +5
.br
.fi
The 
.bd
rp 
preprocessor for pilot enables you to write programs in
the free-form structured language "rational pilot", then
automatically translate them into standard.sp
Example
.in +10
.nf
s: $phial
.sp
.in -10
.fi
The most recently accepted input
is saved in "phial".
.sp 2
.ti -5
.bd
T - type - t: text
.br
A simple command, really.
That which follows the colon is simply sent verbatim
to the standard output, (usually the terminal).
If the last character of the line is a left slant (\),
then no "newline" character is sent at the end of the line.

Example
.nf
.in +10
t: A) First selection
t: B) Second selection
t:
t: Your choice ==>\
a:
.sp
.fi
.in -10
The four lines abo pilot
for interpretation by the "pilot" command.
This implementation incorporates
.bd
include
and
.bd
macro
capabilities.
.bd
Rp
reads from the standard input and writes to the standard
output.
.sp
Lines of the form:
.sp
.in +8
.bd
include file
.sp
.in -8
are replaced by the contents of the named file.
.bd
Includes 
may be nested.
.sp
Macro definitions such as:
.sp
.in +8
.bd
define(token, string)
.sp
.in +3
or
.sp
.in -3
.bd
define(token, ...$1...$2...$3...)
.br
.sp
.in -8
may appear.
The left parenthesis must follow the word define immediately.
In the first case, 
.bd
string 
is merely substituted for 
.bd
token
everywhere it appears.
In the second, occurrences of the form:
.sp
.ti +8
.bd
token(arga, argb, argc)
.sp
are replaced by the defining string, but with the values substituted for
the arguments.
The construction $n, where n is a decimal digit, signifies
the nth argument.  A given macro
may have at most nine arguments.
Macro definitions may be recursive.
.br
.sp
Any valid pilot statement is a valid 
ng mechanism of the innermost
.bd
while, 
.bd
for, 
or 
.bd
repeat, 
in which it occurs.
.sp 2
.in -5
.bd
ALSO READ
.br
.in +5
.fi
Kernighan, B.W. and P.J. Plauger,
.ul
Software Tools,
(Addison-Wesley, 1976).
                                                                                                                                                                                                                                                                .bd
rp 
statement.
A statement or group of statements may be enclosed in
curly brackets "{" and "}".
The result is treated as a single statement.
In addition to standard pilot, 
the following are understood:
.bp
.bd
if (condition) statement;
.sp
.in +5
The statement is executed if the condition is true.
The condition may be either a match query or a
define query (see pilot (I)).
.sp
.in  -5
.bd
if (condition) statement; else statement;
.sp
.in +5
If the condition is true, the first statement is executed,
otN cal.1         M boot.1        L touch.1       K msgs.1        J chsh.1        I kill.1        H last.1        њ create.1                                                                                                                                                                                                                                                                                                                                                                                                      herwise the second statement is executed.
For example

.nf
	t: Give me your answer true.
	a:
	if (m: y)
		{
		t: Oh, Joy!
		t: ...
		}
	else if (m: n)
		t: Oh, Woe!
	else
		t: Eh?

.fi
An 
.bd
else 
goes with the last un-elsed 
.bd
if.
.sp
.in -5
.bd
while (condition) statement;
.sp
.in +5
The statement is executed repeatedly as long as the condition remains
true (possibly zero times as the condition is always tested before
the statement is executed.)
The condition may not be left out.
For an infinite loop,.in 15
.rm 79
.he "          cal (1)                        4/6/83                         cal (1)
.fo "                                           -#-"
.ti -5
.bd
NAME
.br
.bd
cal
- print a calendar

.ti -5
.bd
SYNTAX
.br
.bd
cal [month] [year]

.ti  -5
.bd
DESCRIPTION
.br
The
.bd
cal
program is capable of printing full-year calendars
or single-month calendars for any year or any month
after year 0 (A.D).

.bd
Cal
with no arguments prints a full-year calendar for the current year.

.bd
Cal
with one numeric see
.bd
repeat
below.
.br
.sp
.in -5
.bd
for (statement; condition; statement) statement;
.sp
.in +5
First, the first statement is executed.
Then repeatedly the condition is tested, and if true,
the last statement is executed, then the second.
If the condition is false, the loop is broken and
control proceeds to the next statement following the 
.bd
for.
More clearly: the first statement is the initializer of the loop,
the second is the incrementation, and the last is the body of the loop.
.br
.sp
.in -5
.al argument prints a calendar for that year.

Month names may be given a english names, abbreviations, or as numbers.
If a month name is given, a single-month calendar is printed.

If both arguments are numeric, the first is taken to be the month.

.ti -5
.bd
EXAMPLES
.br

.ti +5
.bd
cal 1932

Would print a full year calendar for the year 1932.

.ti +5
.bd
cal august 1955

To print a single month calendar for August, 1955.

.ti +5
.bd
cal

Would print this year's calendar.

.ti +5
.bd
cal november

For a sibd
repeat
statement;
.sp
.in +5
The statement is executed repeatedly.
.br
.sp
.in -5
.bd
repeat
statement;
.bd
until
(condition);
.sp
.in +5
The statement is executed repeatedly until the condition is true.
The condition is always tested after the statement is executed, which
is to say, the statement will always be executed at least once.
.sp
.in -5
.bd
break;
.sp
.in +5
One level of 
.bd
while, 
.bd
for, 
or 
.bd
repeat, 
loop is broken out of.
.sp
.in -5
.bd
next;
.sp
.in +5
Transfers control to the loopingle month calendar for November of this year.
                                                                                                                                                                                                                                                                                                                                                                                                .in 16
.rm 79
.he "          boot (1)                       4/6/83                        boot (1)
.fo "                                          -#-"
.bd
.ti -6
NAME
.br
.bd
boot
- Micronix bootstrap procedures


.ti -6
.bd
SYNTAX
.br
djboot, hdboot, m5boot, m10boot, m16boot


.ti -6
.bd
DESCRIPTION
.br
The CP/M diskette that comes with Micronix includes the following
bootstrap programs:

.in +8
.ti -8
djboot	Boot from the DJDMA controller
with a 5 inch or an 8 inch drive.

.ti -8
hdboot	Boot from the HDCSET
Machine responds		FFFF
Machine types :, you type b	:b
Loader takes over		DJDMA loader ...


To boot Micronix from the m5:

Insert the Micronix CP/M
  diskette in drive A
Hit RESET
Machine responds		FFFF
Machine types :, you type b	:b
CP/M announces itself		Morrow Designs CP/M
Type m5boot			A> m5boot
Loader takes over		HDDMA loader ...


To prepare an auto-boot
  floppy for the m5:

Insert the Micronix CP/M
  diskette in drive A
Hit RESET
Machine responds		FFFF
Machine types :	 you type b	:b
CP/M announcA controller
the 10, 20, or 26 megabyte drive

.ti -8
m5boot	Boot from the HDDMA controller
with the 5 megabyte drive

.ti -8
m10boot	Boot from the HDDMA controller
with the 10 megabyte drive

.ti -8
m16boot	Boot from the HDDMA controller
with the 16 megabyte drive
.in -8

These are CP/M programs, ie, they are stored on the CP/M
diskette as djboot.com, hdboot.com, etc, and are invoked
from CP/M by typing the name without the .com extension.

In each case, they assume that the target disk contains
a Micronixes itself		Morrow Designs CP/M
Type formatdj. Follow the	A> formatdj
  instructions to format a
  new diskette. 512 byte
  sectors are recommended.
Type sysgen m5load		A> sysgen m5load
Type an A			Destination drive? A
Insert the formatted		Insert a write
  diskette in drive A		 enabled diskette
  and hit RETURN.		 in drive A
The diskette is ready to use	Function complete...


To use the m5 auto-boot:

Insert the auto-boot
  diskette in drive A
Hit RESET
Machine responds		FFFF
Machine types :, you type b	:b
 file system, and they search its root
directory for files that could be Micronix kernels.
If exactly one such file is found, it is loaded and
executed. If more than one kernel
is found, the names are listed and the operator is asked
choose one. This allows backup copies or alternate
versions to be kept.

CP/M's only role in this process is the invocation of
the bootstrap program. Once the bootstrap begins
executing, it is independent of CP/M, and CP/M itself
is overwritten as Micronix is loaded.

CP/M can Loader takes over		HDDMA loader ...


.ti -6
.bd
BUGS

.fi
The bootstrap programs only search the first block
of the root directory, so you should limit your
root directory to 32 entries (which is a good idea
anyway, to speed up rooted file-name searches),
or else you should make sure that the Micronix
kernel occurs as one of the first 32 entries.
                                                                                                                                be eliminated entirely by placing the desired
bootstrap program on the "system tracks" of a floppy disk.
Then as long as that diskette is in drive A, Micronix will
boot automatically from the appropriate hard disk
every time the Decision's RESET button is hit. This
should save the operator about 5 seconds per day.
(CAUTION: if Micronix is already running, make
sure you type sync before hitting RESET.)

The loaders that can be placed on a floppy's system tracks
are stored as files on the Micronix CP/M disket.in 15
.rm 79
.he "          touch (1)                      4/6/83                       touch (1)
.fo "                                           -#-"
.bd
.ti -5
NAME
.br
touch - updtate the modification time for a file

.ti -5
.bd
SYNTAX
.br
touch file ...

.ti -5
.bd
DESCRIPTION
.br
Each of the named files has it's modification time
set to the current time.
This is done by reading a character from a file and
then writing it back.
No file's data is changed.

.ti -5
.bd
EXAMPLE
.br
touch file
te,
and are called hdload, m5load, m10load, and m16load,
corresponding to the similarly-named bootstrap programs.
See below for an installation example.
The djboot program has already been placed on the
system tracks of the Micronix stand-alone floppy,
so if you put this in drive A and hit RESET, it
will boot automatically.


.ti -6
.bd
EXAMPLES

.nf
				SCREEN
COMMENTS			DISPLAY


To boot the Micronix
  stand-alone floppy:

Make sure the diskette is
  write-enabled
Insert the diskette into
  drive A
Hit RE.in 15
.rm 79
.he "          msgs (1)                       4/6/83                        msgs (1)
.fo "                                           -#-"
.bd
.ti -5
NAME
.br
.bd
msgs
- bulletin board and junk mail service


.ti -5
.bd
SYNTAX
.br
msgs -fhq [ [-] number ]


.ti -5
.bd
DESCRIPTION
.br
The msgs program provides a system wide bulletin board.
Any user may post messages on the board
and all users may view the messages on the board.
Using the msgs program is much like reading the classifed
section of a newspaper.

The last message read by each user is automatically remembered.
That is to say each user sees each message once
and the system holds your place.

When the command "msgs" is given
an interactive mode is entered.

You are shown the heading of the first message you haven't read yet.

You are advised of the number of lines remaining in the file.

You are asked if you'd like to see more.

This looks like:

	Message 23:
	From harold Mon 23 Aug 11:30:22
	New database program installed!!
	(17 more l.in 15
.rm 79
.he "          chsh (1)                       4/6/83                        chsh (1)
.fo "                                           -#-"
.ta 5
.ti -5
NAME
.br
.bd
chsh
- change shell

.ti -5
SYNTAX
.br
chsh

.ti -5
DESCRIPTION
.br
chsh is a menu-driven program that allows the user to select which
shell (command interpreter) he will be given when
he logs in. This can be one of the standard shells (such as the
Full Shell or the CP/M shell),
or it can be a dedicated application such as Wines) More? (Y/N/Q)


Possible responses:

.in +6
.ti -6
y	Yes, I'd like to see the rest of this message.

.ti -6
n	No, I'm not interested in this message, skip me
to the next message.

.ti -6
q	Quit.  Get out of the program right now.

.ti -6
(number) 
.br
Jump to the message whose number is given, or the next
highest numbered message.
	
.ti -6
-	Back up one message for a replay.



.ti -6
s filename
.br
Append this message to the end of the named file.
Create the file if it doesn't already exist.
If a minordStar.
Any interactive program can be used.

In effect, chsh is an easy way of editing the /etc/passwd file.  Whichever
shell is specified through chsh will be entered onto the user's line in this
file.  The new shell takes effect the next time the user logs in.

Chsh first asks for a
login name.  The superuser may enter any user's name, but everyone else must
enter his own login name.
Next, chsh presents this menu:

	1)  Full shell
	2)  CP/M shell
	3)  Menu shell
	4)  Other

                -us (-) follows the 's', the previous
message will be saved.

.in -6

If you press the <RUB-OUT> or <DELETE> key
in the middle of the printing of a long message,
the remaining portion of the message will be skipped.


Command line flags:

.in +6
.ti -6
-f	Causes msgs not to say "No new messages".

.ti -6
-h	Headings only.
The heading of a message is arbitrarily the first two
non blank lines.

.ti -6
-q	Queries whether there are messages.
Prints "There are new messages" if there are.
This option is useful in ->

"Full shell" is the standard Micronix shell (see sh in section 1).

"CP/M shell" is the Micronix CP/M emulator "upm".
By default, this gives the user a CP/M drive A corresponding
to his home directory. This can be changed in the
".upm" file in the user's home directory. See upm in section 1.

"Menu shell" is reserved for future use.

"Other" gives you the opportunity to be creative.  When
you select this option, the system prompts "Command to use as shell:".
You can respond with the pathname of startup files.

.in -6

To post a message, just mail it to "msgs".
Messages are automatically removed after 2 weeks, unless
they are set to file mode 444, in which case they
will be permanent.
See chmod (1).


.bd
.ti -5
EXAMPLES
.br
To catch up on local events:

	msgs


To post a message:

	mail msgs

	There wil be a company party at 4 p.m. on April 6th.
	All are invited to attend.
	Guest speakers will include Horton Hornblower.

	.


To post a message from a file:

	mail msgs < file &


To view the compleany program in the system,
and you may follow the program name with arguments.
The program will be executed upon login; when the program terminates,
the user is automatically logged out.  So, for example, if you enter
"/bin/man" as the shell, you have given the user access
to the Micronix online documentation, and nothing else.  See below for 
a more practical example.

.ti -5
EXAMPLE
.br
To set up a user (say, a typist) so that he logs in directly to
WordStar:

.nf
Command to use as shell:  /bin/upte list of message headings:

	msgs -h 1


To notify you if there are new messages,
add this line to your ".login" file in your home directory:

	msgs -fq

.bd
.ti -5
FILES
.br
/usr/spool/msgs
~/.msgs
                                                                                                                                                                                                                                                                m  a:/cpm  b:./  b:  a:ws
.fi

This will log the user directly into WordStar.
Drive A will be the /cpm directory (containing the
system-wide CP/M programs), drive B will be the user's
home directory (which is the current directory when this
command string is executed), and drive B will also be the
"currently logged drive" (containing the user's own documents
and data files).


.ti -5
SEE ALSO
.br
sh (1), upm (1), passwd (5)
.he "kill (1)                     3/18/82                     kill (1)"  
.fo "                               -#-"
.in 5
.rm 65
.bd
PROGRAM
.br
.in +5
.bd
kill
- send a signal to a process


.in -5
.bd
C          
.br
.in +5
.bd
kill [-sig] processid ...


.in -5
.bd
FUNCTION   
.br
.in +5
.bd
Kill 
sends the specified signal to each of the processes, given
by number (where
.bd
-sig
is the decimal signal number).
If no signal is specified, 
.bd
SIGKILL (signal number 9) ird keeping and discard records:

	era /usr/adm/wtmp

Save old records and then start over:

	cd /usr/adm
	mv wtmp save
	create wtmp

.ti -5
.bd
FILES
.br
/usr/adm/wtmp - the file containing the historical record.
                                                                                                                                                                                                                                                                                                           s sent.


.in -5
.bd
ALSO READ
.br
.in +5
/include/signal.h
                                                                                                                                                                                                                                                                                                                                                                                                G .              ..            F chdir.2       E chmod.2       D chown.2       C close.2       B creat.2       A csw.2         ` dup.2         _ exit.2        ^ fork.2        ] fstat.2       \ getpid.2      [ gtty.2        Z indir.2       Y mknod.2       X mount.2       W sync.2        V time.2        U access.2      T break.2       S exec.2        R getuid.2      Q alarm.2       p kill.2        o link.2        n open.2        m pipe.2        l read.2        k seek.2        j setuid.2      i signal.2      .in 10
.rm 79
.he "          last (1)                       5/18/83                        last (1)
.fo "                                           -#-"
.bd 
NAME
.br
.in +5
.bd
last
- login accounting


.ti -5
.sp 
.bd
SYNTAX       
.br
.bd
last [-s] [user ... ] [tty ... ]


.ti -5
.bd
DESCRIPTION   
.br

Last interprets the user login accounting file.

It can be used to gain a perspective of the login
history of the system.

Last attempts to display the starting and ending times
of each user session as we.he "chdir (2)		          3/19/82               chdir (2)"
.fo "				    -#-"
.rm 65
.in 5
.bd
NAME
.in +5
.br
.bd
chdir
- change working directory

.in -5
.bd
C
.in +5
.br
chdir(dirname)
.br
char *dirname;
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
The working directory of the current process is changed
to the given directory.
The user must have search (execute) permission on the directory.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
A 0 is returned on success, a -1 on failure.
.sp 2
.in -5
.bd
ASSEMBLER
.in +5
.br
.bll as the duration of that session.

The display is given in reverse chronological order,
most recent first.

If the -s option is given, only a summary is given.

If a user name or list of user names is given,
then the display is restricted to only those users specified.

If a tty name or list of tty names is given,
then only login sessions on the specified ttys will be displayed.

If a mixed list is given then the display will include
sessions matching any of the criteria.

Its possible to enable or disabld
(chdir = 12)
.br
.bd
sys; chdir; dirname
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
                                                                                                                                                                                                                                                                                                                                                                                        e the historical record keeping
feature.
Record keeping is turned on or off based on the presence or
absence of the wtmp file (/usr/adm/wtmp).


.ti -5
.bd
EXAMPLES
.br

Print login history:

	last

Print usage summary:

	last -s

Find out who has been using your tty:

	last ttyB

Find out how much time oscar has logged:

	last -s oscar

Probe the behaviour of a few selected users:

	last bill jean harold

Start record keeping afresh discarding old records:

	cd /usr/adm
	era wtmp
	create wtmp

Disable reco.he "chmod (2)		          3/18/82               chmod (2)"
.fo "				    -#-"
.rm 65
.in 5
.bd
NAME
.in +5
.bd
chmod
- change mode of file
.sp 2
.in -5
.bd
C
.in +5
.br
chmod(name, mode)
.br
char *name;
.sp 2
.in -5
.bd
FUNCTION    
.in +5
.br
The mode of the file is set as indicated.
Only the owner of a file, or the super-user, may change the mode.
Modes are constructed by ORing together some combination
of the following (octal) values:

.in +8
.nf
.bd 8
4000  Set user id on execution
2000  Set group id on execution
1000  Currently ignored
0400  Read by owner
0200  Write by owner
0100  Execute (or search directory) by owner
0070  Read, write, execute (search) by group
0007  Read, write, execute (search) by others
.in -8

.fi
When a file with the set-user-id flag is executed,
the effective user ID of the process is set to the owner
of the file. 
(In this way, for instance, a spelling program could use
a secret dictionary.)

For security reasons, whenever a file is opened
for writing, its set-id flags are clearles.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.
.sp 2
.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(close = 6)
.br
.bd
(file descriptor in hl)
.br
.bd
sys; close
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
                                                                                                                                                                                                                                  ed.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.
.sp 2
.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(chmod = 15)
.br
.bd
sys; chmod; name; mode
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
                                                                                                                                                                                                                                                      .he "creat (2)		          3/18/82               creat (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
creat
- create a new file (or truncate an old one)
.sp 2
.in -5
.bd
C
.in +5
.br
creat(name, mode)
.br
char *name;
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
If the file does not exist,
and if the parent directory is writable,
it is created with the given mode.
If the file does exist and is writable,
it is truncated to 0 length,
and its mode and owner remain unchanged.
In either case, the file is
o.he "chown (2)		          3/18/82               chown (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
chown
- change owner and group of a file
.sp 2
.in -5
.bd
C
.in +5
.br
chown(name, owner)
.br
char *name;
.sp 2
.in -5
.bd
FUNCTION         
.in +5
.br
The owner of the file is changed to the low byte of "owner",
and the group is changed to the high byte.
Only the super-user may execute this call.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.
.sp 2
.in -5
.bdpened for writing only, and a file descriptor is returned.

See 
.bd
chmod 
(2) for the construction of modes. Note that the
file is opened for writing, even if the given mode does not
allow writing.
This can be used as a locking mechanism, in that another
program will not be able to create the same file.

.bd
Creat
is subject to the limit of 16 open files per process.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
.bd
Creat()
returns a file descriptor (a small, positive number)
on success, or a -1 on failure.
.sp 2
.
ASSEMBLER
.in +5
.br
.bd
(chown = 16)
.br
.bd
sys; chown; name; owner
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
                                                                                                                                                                                                                                                                                                                                                            in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(creat = 8)
.br
.bd
sys; creat; name; mode
.br
.bd
(file descriptor in hl)
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
If successful, a file descriptor is returned in hl.
                                                                                                                                                                                                                                                                 .he "close (2)		          3/18/82               close (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
close 
- close a file
.sp 2
.in -5
.bd
C
.in +5
.br
close(descriptor)
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
Given a file descriptor previously returned by
.bd
open, creat,
or
.bd
pipe, close
closes the associated file.
A close of all files is automatic on
.bd
exit,
but since processes are limited to 16 simultaneously open files,
.bd
close ()
may be necessary for programs that deal with many fi.he "csw (2)		          3/19/82                 csw (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
csw
- read the console switches
.sp 2
.in -5
.bd
C
.in +5
.br
getcsw()
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
The setting of the console switches is returned.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
The setting of the console switches is returned.
.sp 2
.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(csw = 38)
.br
.bd
sys; csw
.br
.bd
(switch setting in hl)
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
The switch setting is returned in hl.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .in +5
.br
.bd
(exit = 1)
.br
.bd
(status in hl)
.br
.bd
sys; exit


.in -5
.bd
RETURNS
.in +5
.fi
None.
                                                                                                                                                                                                                                                                                                                                                                                                                       .he "dup (2)                      3/19/82                      dup (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
dup
- duplicate a file descriptor
.sp 2
.in -5
.bd
C
.in +5
.br
dup(descriptor)
.sp 2
.in -5
.bd
FUNCTION       
.in +5
.br
.bd
Dup 
takes a file descriptor previously returned by
.bd
open, creat,
or
.bd
pipe
and allocates a new descriptor
synonymous with the original.  Subsequent reads or writes
with the new descriptor will have exactly the same
effect as the same call with the old.he "fork (2)                     3/19/82                     fork (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
fork
- create a new process


.in -5
.bd
C
.in +5
.br
fork()


.in -5
.bd
FUNCTION      
.in +5
.br
.bd
Fork
is the only way to create a new process.
The calling process splits into a "parent"
and a "child". The child's core image is a
copy of the parent's, open files are shared,
and signals remain unchanged.
.bd
Fork()
returns a zero to the child process,
while it returns a non-zer descriptor.

Since the algorithm that allocates file descriptors
returns the lowest available value, combinations of
.bd
dup
and
.bd
close
can be used to move file descriptors
in a general way. This is used mostly for manipulating
the standard input (file descriptor 0) and the
standard output (file descriptor 1).

.bd
Dup
is subject to the limit of 16 active file descriptors
per process.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
.bd
Dup()
returns a file descriptor (positive) if successful,
or a -1 if not.
.sp 2
o number to the parent.
This is the process ID of the child,
and is used by
.bd
wait
(2) and
.bd
kill
(2).


.in -5
.bd
RETURNS
.in +5
.br
.bd
Fork()
returns a zero to the child, and the non-zero
process ID of the child to the parent. 
A return of -1 (not just negative) indicates a
temporary lack of process space.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(fork = 2)
.br
.bd
sys; fork
.br
.bd
(child return)
.br
.bd
(+ 3 bytes)
.br
.bd
(parent return) (child id in hl)


.in -5
.bd
RETURNS
.in +5
.br
The child pro.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(dup = 41)
.br
(old descriptor in hl)
.br
.bd
sys; dup
.br
(new descriptor in hl)
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
On success, the carry flag is cleared and the new descriptor
is returned in register hl.  On failure, the carry flag is set.
                                                                                                                                                                                                                                         cess returns to the location
immediately following the fork.
The parent skips three bytes before returning,
and receives the child ID in hl.
If a new process cannot be created,
the carry flag is set on return to the
parent (and the child return
never happens).
                                                                                                                                                                                                                                                           .he "exit (2)                     3/19/82                     exit (2)"     
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
exit
- terminate this process


.in -5
.bd
C
.in +5
.br
exit(status)


.in -5
.bd
FUNCTION    
.in +5
.fi
.bd
Exit
closes all open files,
terminates the calling process,
and notifies the parent process
(if it is executing a wait).
The low byte of status is available
to the parent (via wait).
.nf


.in -5
.bd
RETURNS
.in +5
.fi
This call can never return.


.in -5
.bd
ASSEMBLER
.he "fstat (2)                    3/19/82                    fstat (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
fstat
- get the status of an open file


.in -5
.bd
C
.in +5
.br
fstat(descriptor, buf)
.br
struct stat *buf;


.in -5
.bd
FUNCTION       
.in +5
.fi
.bd
Fstat 
is identical to
.bd
stat,
except that it operates on open files
(via the file descriptor)
rather than on files given by name.
This is often used to examine
the status of the standard input and output,
whose names are usually unknown.
Buf is the address of a 36 byte buffer,
into which the following information is
placed:

.nf
.bd 15
struct stat
	{
char	minor,		/* minor device */
	major;		/* major device */
int	inumber,	/* inode number */
	flags;		/* see below */
char	nlinks,		/* number of links */
	uid,		/* user id of owner */
	gid,		/* group id of owner */
	size0;		/* high byte of size */
int	size1,		/* low word of size */
	sddr[8];	/* block numbers */
long	actime,		/* time of last access */
	modtime;	/* " last modification */.he "gtty (2)                     3/19/82                     gtty (2)"  
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
gtty
- get typewriter status


.in -5
.bd
C
.in +5
.br
.nf
gtty(descriptor, vec)
struct
	{
	char	ispeed,		/* input speed */
		ospeed,		/* output speed */
		erase,		/* erase character */
		kill;		/* kill character */
	int	mode;		/* see below */
	}
	*vec;



.fi
.in -5
.bd
FUNCTION   
.in +5
.br
.bd
Gtty
gets the status of the terminal
associated with the file descriptor,
and writes
	};

The flags are as follows (values in octal):

.nf
.bd 15
 100000		inode is allocated
 060000		2-bit file type
	 000000		plain file
	 040000		directory
	 020000		character-special file
	 060000		block-special file
 010000		large file
 004000		set user-id on execution
 002000		set group-id on execution
 001000		currently ignored
 000400		read (owner)
 000200		write (owner)
 000100		execute or search directory (owner)
 000070		read, write, execute (group)
 000007		read, write, execute (others)
.bp
.in -5
 the status into the 6-byte
structure pointed at by vec.
(This structure is the same as that passed by 
.bd
stty.
) Actually, this call may be made to any character device,
but devices that do not like it may
return an error.

.bd
Ispeed and ospeed are one of:

.nf
.in +4
.bd 16
0     1200 baud
1       50 baud
2       75 baud
3      110 baud
4      134.5 baud
5      150 baud
6      200 baud
7      300 baud
8      600 baud
9     1200 baud
10    1800 baud
11    2400 baud
12    4800 baud
13    9600 baud
14   1.bd
RETURNS
.in +5
.fi
A 0 indicates success, a -1 indicates failure
(bad file descriptor).


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(fstat = 28)
.br
.bd
(file descriptor in hl)
.br
.bd
sys; fstat; buf


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
On success, the status is placed in the 36-byte area
pointed at by buf.
                                                                                                                                                        9200 baud
15    1200 baud
.in -4
.fi

The next two characters specify the
erase and kill characters, respectively.
(The defaults are ^H and ^X).
.bp
The mode specifies what services are performed
by the system on input and output.
Currently, these are:
.nf

.in +4
.bd 5
0200  Use the RS-232 clear-to-send line
0040  Raw input
0020  Cr -> lf mapping
0010  Echo input
0002  Expand tabs
.in -4

.fi
In raw mode, all characters are passed immediately
to the program without waiting for a full line to be typed,
ther.he "getpid (2)                   3/19/82                   getpid (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
getpid
- get process ID


.in -5
.bd
C
.in +5
.br
getpid()


.in -5
.bd
FUNCTION         
.in +5
.br
.bd
Getpid
returns the process ID of the current process.
This is the same ID that is used by the
.bd
fork, kill,
and
.bd
wait
system calls.


.in -5
.bd
RETURNS
.in +5
.br
.bd
Getpid
returns the process ID.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(getpid = 20)
.br
.bd
sys; getpid
.br
e is no erase or kill processing,
and there is no recognition
of any special control characters.
In cooked mode, the following control characters
are recognized:
.in +4

.nf
.bd 6
^D  end-of-file (when typed alone on a line)
^\  send a quit signal to this tty's processes
DEL send an interrupt signal to same
^B  send a background signal to same
ESC freeze the output from this tty
^S  same as ESC
.in -4

.fi
Note that even while the tty is in raw mode,
the other modes still have an effect.

In cr->lf mode, in.bd
(id in hl)


.in -5
.bd
RETURNS
.in +5
.br
.bd
Getpid
returns the process ID in hl.
                                                                                                                                                                                                                                                                                                                                                                                                                                        put crs are turned into lfs,
and output crs or lfs are turned into cr-lfs.

In echo mode, input is echoed immediately.
If the mode is also raw, it is echoed exactly
as typed; otherwise, the special control characters
are not echoed, the kill character is echoed as
itself plus a newline, and the erase character
is echoed as backspace-space-backspace.

In expand-tabs mode, tabs are output as the
number of spaces needed to bring the cursor
to the next 0-mod-8 column.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.
On success, the status is placed in the 6-byte structure
pointed at by vec.
.bp
.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(gtty = 32)
.br
.bd
(file descriptor in hl)
.br
.bd
sys; gtty; vec


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
On success, the status is placed in the 6-byte area pointed
at by vec.
                                                                                                                                     .he "mount (2)                    3/19/82                    mount (2)" 
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
mount 
- mount a file system


.in -5
.bd
C
.in +5
.br
.bd
mount(device, on, ronly)
.bd
.br
char *device, *on;


.in -5
.bd
FUNCTION       
.in +5
.br
.bd
Mount
informs the system that the given
block device contains a file system.
Subsequent references to the file "on"
will refer to the root directory of the
new file system. The old contents of "on"
are inaccessible until the devi.he "indir (2)                    3/19/82                    indir (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
indir
- indirect system call


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(indir = 0)
.br
.bd
sys; indir; syscall


.in -5
.bd
FUNCTION    
.in +5
.br
The system call at the location syscall is executed.
Execution resumes after the
.bd
indir
call.

The main purpose of
.bd
indir
is to allow programs to
construct system calls in their data segments,
avoiding modifications to their code.

Thece is
unmounted.

If ronly is non-zero, the system will not
allow writing on the device. If the device
is physically write protected, it should
still be mounted read-only to prevent
the system from trying to update access times.

This call is restricted to the super-user.
There is a limit to the number of devices
that can be mounted concurrently.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(mount = 21)
.br
.bd
sys; mount; device; on; r system call at syscall must begin with the
"sys" byte. An
.bd
indir
executed indirectly is a no-op.


.in -5
.bd
RETURNS
.in +5
.br
The returns depend on the indirectly executed call.
                                                                                                                                                                                                                                                                                                                                       only


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
                                                                                                                                                                                                                                                                                                                                                                                                                                  .he "mknod (2)                    3/19/82                    mknod (2)" 
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
mknod
- make a directory or special file
.sp 2
.in -5
.bd
C
.in +5
mknod(name, mode, addr)
char *name;


.in -5
.bd
FUNCTION         
.in +5
.fi
.bd
Mknod
creates a new file.  Unlike
.bd
creat,
it may be used
to create directories and special files;              
it does not truncate or open files.

The mode of the new file (including the file type bits)
is taken from the mode argu.he "sync (2)                     3/19/82                     sync (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
sync 
- update the disks


.in -5
.bd
C
.in +5
.br
sync()


.in -5
.bd
FUNCTION   
.in +5
.br
.bd
Sync 
causes all information in core memory that should
be on disk to be written out.
This includes modified super-blocks, modified inodes,
and delayed block I/O.


.in -5
.bd
RETURNS
.in +5
.br
No information is returned.  
.bd
Sync
always succeeds.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bment, and the first address is
taken from addr. For directories, this address should be
0, while for special files it should be the device number.

This call is restricted to the super-user.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(mknod = 14)
.br
.bd
sys; mknod; name; mode; addr


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
                                                                 d
(sync = 36)
.br
.bd
sys; sync


.in -5
.bd
RETURNS
.in +5
.br
No error indication is returned.
                                                                                                                                                                                                                                                                                                                                                                                                                               .he "time (2)                     3/19/82                     time (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
time 
- get date and time


.in -5 
.bd
C
.in +5
.br
time(tp)
.br
long *tp;


.in -5 
.bd
FUNCTION   
.in +5
.br
.bd
Time 
fills the long value pointed to by the argument
with the number of seconds since 0:00 GMT January 1 1970.


.in -5 
.bd
RETURNS
.in +5
.br
The user-supplied long integer is filled in.
There are no error conditions.


.in -5 
.bd
ASSEMBLER
.in +5
.br
.bd
(time = and less than the stack pointer are not in
the address space of the program.
These locations may be overwritten by the system,
and may cause memory faults if accessed.
The system will refuse to set the break above the stack pointer,
but a program is free to move its stack pointer below the
break.

.bd
Sbrk
adds incr more bytes to the program's data space
and returns a pointer to the start of the new area.

When a program begins execution via
.bd
exec
(2), its break is set to the top of its program and data 13)
.br
.bd
sys; time
.br
.bd
(time in hl-de)


.in -5 
.bd
RETURNS
.in +5
.br
The time is returned with the high order word in hl
and the low order word in de.
There are no error conditions.
                                                                                                                                                                                                                                                                                                                                storage
areas.  Thus, only programs that must dynamically allocate
data space need to use these calls.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
The old break is returned on success.
A -1 is returned if the request would require more memory
than the system limit, or if it would move the break across
the stack pointer.
.sp 2
.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(break = 17)
.br
.bd
sys; break; addr
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
Only success or failure is returned,
by clearing or setting the carry flag, respec.he "access (2)		          3/18/81              access (2)"
.fo "			           -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
access
- test file access permissions
.sp 2
.in -5
.bd
C
.in +5
.br
access(name, mode)
.br
char *name;
.br
int mode;
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
Permission to access the named file, in the specified mode,
is tested. The test is based on the real user and group IDs,
rather than the effective IDs, so that a set-user-id program
may test the permissions of its invoker.
Mode is thetively.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
.ul
sum 
of any of the following:

.nf
.in +8
.bd 3
4  read
2  write
1  execute
.in -8

.in -5
.bd
RETURNS
.in +5
.fi
.br
.bd
Access
returns a 0 if permission is granted, -1 if not.
.sp 2
.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(access = 33)
.br
.bd
sys; access; name; mode
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
.bd
Access 
returns with the error bit clear if the permissions
are granted, or with the error bit set if they are not.
                                                                                    .he "exec (2)                     3/19/82                exec (2)"
.fo "                               -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
exec
- execute a program
.sp 2
.in -5
.bd
C
.in +5
.br
execv(name, argv)
.br
char *name;
.br
char *argv[];

execl(name, arg0, arg1, ..., argn, 0)
.br
char *name, *arg0, *arg1, ..., *argn;
.sp 2
.in -5
.bd
FUNCTION
.in +5
.br
.bd
Exec
overlays the calling core image with the named file,
then transfers to the beginning of the new core image.
There can be no return fr.he "break (2)			  3/18/82               break (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
break, brk, sbrk
- change core allocation
.sp 2
.in -5
.bd
C
.in +5
.br
char * brk(addr)
.br
char * sbrk(addr)
.sp 2
.in -5
.bd
FUNCTION    
.in +5
.fi
.br
.bd
Brk
sets the system's idea of the lowest memory location
not used by the program (called the "break")
to addr (which may be rounded up to suit
memory management hardware).
The old break is returned.

Locations greater than or equal to the break
om a successful
.bd
exec:
the calling core image is lost.

Exec does not create a new process -
the same process continues with the new core image.
Previously opened files remain open
(so standard input and output are preserved),
and ignored signals remain ignored.
Caught signals, however, are reset to their default behavior.

Each process has "real" user and group IDs and "effective"
user and group IDs. The real IDs identify the user;
the effective IDs determine the access privileges.
If a file does not have "set-user-id" or "set-group-id"
mode [see
.bd
chmod,
(2)], then
.bd
exec
sets all IDs,
real and effective, to the individual executing the file.
If the file does have either mode,
.bd
exec
sets the corresponding
effective ID to the owner of the executed file. The real IDs
remain unchanged. This allows a user to write a
program that takes advantage of his own access privileges
(rather than its invoker's privileges).

In order to be executed, a file must have one of the
execute permission bits set, even fo is limited
to 512.

It is conventional to repeat the name
of the file being executed as the first argument,
so that programs can use the name with which they are invoked.
.bp
When a C program is executed, it begins as follows:

.bd
main(argc, argv)
.in +8
.br
.bd
int argc;
.br
.bd
char **argv;
.in -8

where
.bd
argc
is the argument count, and
.bd
argv
is a list of pointers to the argument strings themselves.  Conventionally,
.bd
argc
is at least 1 and
.bd
argv[0]
is the program name.
As delivered by the syr the super-user.
The system expects one of two file formats.
If the first byte is hex 99, then the first 16
bytes are taken to be a header with the following structure
.nf
.bp
struct header
        {
        char     ident,         /* hex 99 */
                 conf;          /* not used by exec */
        unsigned tablsize,      /* not used by exec */
                 textsize,      /* bytes in text segment */
                 datasize,      /* bytes in data segment */
                 bss_size,      /* bийклмнопст                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ytes in bss segment */
                 heapsize,      /* minimum stack + heap */
                 textoff,       /* text segment offset */
                 dataoff;       /* data segment offset */
        };
.sp
.fi
(This header structure is produced by Whitesmith's compilers.)
The rest of the file is assumed to contain textsize bytes of
text, followed by datasize bytes of data. Text is loaded at
address textoff, data is loaded at address dataoff, and bss
space is allocated following the data. The break isstem, argv[argc] == -1, so that
.bd
argv
cannot be used directly in another
.bd
execv
until
.bd
argv[argc]
is set to 0.
.sp 2
.in -5
.bd
RETURNS
.in +5
.br
Any return is an error return.
In that case, the calling image is not lost and can continue.
Possible errors include: the file cannot be found,
is not an ordinary file,
is not executable, is too big, or the argument list
is too long.
.sp 2
.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(exec = 11)
.br
.bd
sys; exec; name; argv


.bp
.bd
Argv
is the address of a lis set at the
highest location in the text or data + bss segments.

If the first byte of the file is not hex 99, then the file is
taken to be pure object code origined at address 256 (100
hex). The brake is set to the file size.

In any case, the program must meet the maximum-size
restriction (currently 65024 bytes), and it must keep a "halt"
instruction (the system-call trap) at address 8. (This is
supplied by the system, unless the text offset is <= 8.)

C offers two different interfaces to
.bd
exec.  Execlt of string pointers.
The last pointer must be 0. When the file starts
execution, core is set up as follows:


.nf
.bd 9
(top of user core)
argn:   string\0
        ...
arg0:   string\0
        -1
        argn
        ...
        arg0
sp ->   argc
.sp 2
.fi
.in -5
.bd
RETURNS
.in +5
.br
If
.bd
exec
returns at all, the carry flag is set to
indicate an error.
                                                                                                                                                        
is useful when a known file is being executed
with known arguments.
The arguments are all string pointers.
Any number of arguments may be given, but the last
must be a 0.

When the number of arguments
is not known in advance,
.bd
execv
is handy. Pointers
to the argument strings are collected into a list,
a null pointer is appended to mark the end of the
list, and
.bd
execv
is called with the address of the list.

Currently, the total number of bytes in the argument
strings (including the terminating nulls).he "getuid (2)                   3/25/82                   getuid (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
getuid
- get user IDs


.in -5
.bd
C
.in +5
.br
getuid()


.in -5
.bd
FUNCTION   
.in +5
.br
.bd
Getuid
returns the real user IDs of the current process.
The real group ID is in the high byte of the returned word.
The real user ID is in the low byte.
(The real IDs identify the individual,
while the effective IDs determine his
current access privileges. See the
.bd
exec
and
.bd
chmod
system calls for a discussion.)


.in -5
.bd
RETURNS
.in +5
.br
.bd
Getuid
returns the real user IDs:
.br
high byte = group ID, low byte = user ID.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(getuid = 24)
.br
.bd
sys; getuid
.br
.bd
(IDs in hl)


.in -5
.bd
RETURNS
.in +5
.br
.bd
Getuid
returns the real process IDs:
.br
.bd
high byte = group ID, low byte = user ID.
                                                                                                                                                    .he "link (2)                     3/19/82                     link (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
link
- link to a file


.in -5
.bd
C
.in +5
.br
link(old, new)
.br
char *old, *new;


.in -5
.bd
FUNCTION        
.in +5
.fi
A link to "old" is created, with the name "new".
Either name may be an arbitrary pathname.

"New" must not already exist,
its directory must be writable,
and it must be on the same device as "old".
"Old" must not be a directory
(unless the user is the super-us.he "alarm (2)                    3/19/82                    alarm (2)"  
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
alarm 
- set the alarm clock


.in -5
.bd
C
.in +5
.br
alarm(seconds)


.in -5
.bd
FUNCTION   
.in +5
.br
This call sets the "alarm clock", which will send an
.bd
alarm
signal to the calling process after the given number of seconds
( see
.bd
signal (2)
). Meanwhile, the process continues to run.

An argument of 0 turns the alarm clock off.

See also
.bd
pause (2) and sleep(2).

.er),
and must not have more than 254 links.
.nf


.in -5
.bd
RETURNS
.in +5
.fi
A 0 indicates success, a -1 indicates failure.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(link = 9)
.br
.bd
sys; link; old; new


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
                                                                                                                                                                                                                           in -5
.bd
RETURNS
.in +5
.br
If an alarm was previously set but not yet triggered,
.bd
alarm
returns the number of seconds remaining until the old alarm.
Otherwise it returns 0.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
alarm = 27)
.br
.bd
(seconds in hl)
.br
.bd
sys; alarm


.in -5
.bd
RETURNS
.in +5
.br
The time remaining on any old alarm is returned in hl.
There is no error return.
                                                                                                                                .he "open (2)                     3/19/82                     open (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
open
- open a file for reading or writing


.in -5
.bd
C
.in +5
.br
.bd
open(name, mode)
.br
.bd
char *name;


.in -5
.bd
FUNCTION       
.in +5
.br
The named file is opened for
.nf

.in +4
.bd 3
reading	(mode 0),
writing	(mode 1), or
both	(mode 2).
.in -4

.fi
The returned file descriptor should be saved
for subsequent calls to 
.bd
read, 
.bd
write, 
and 
.bd
close.

There is a li.he "kill (2)                     3/19/82                     kill (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
kill
- signal a process


.in -5
.bd
C
.in +5
.br
kill(pid, sig)


.in -5
.bd
FUNCTION   
.in +5
.br
.bd
Kill
sends the signal, sig, to the process with the given ID.
The usual effect is to kill the process - see
.bd
signal
(2) for a discussion and a list of signals.

The sending and receiving processes must have the same effective
user IDs, or the sender must be the super-user.

Ifmit of 16 open files per process.
.nf


.in -5
.bd
RETURNS
.in +5
.fi
A non-negative return indicates success, a -1 indicates failure.
On success, a file descriptor (small non-negative number)
is returned.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(open = 5)
.br
.bd
sys; open; name; mode
.br
.bd
(file descriptor in hl)


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
On success, a file descriptor is returned in hl.
                                                          the given process ID is 0, then the signal is sent
to all other processes with the same controlling tty.

A process can never kill itself.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(kill = 37)
.br
.bd
(process ID in hl)
.br
.bd
sys; kill; sig


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
                                                                                                        .he "pipe (2)                     3/19/82                     pipe (2)" 
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
pipe
- create an inter-process channel


.in -5
.bd
C
.in +5
.br
.bd
pipe(descriptor)
.br
.bd
int descriptor[2];
.br
.bd
(read descriptor = descriptor[0])
.br
.bd
(write descriptor = descriptor[1])


.in -5
.bd
FUNCTION         
.in +5
.br
.bd
Pipe
returns two file descriptors that can
be used to communicate between processes
created by subsequent 
.bd
fork 
calls.
When the pipe is written using descriptor[1],
up to 4096 bytes of data will be buffered
before the writing process is suspended.
A read using descriptor[0] will pick up the data.

Read calls on an empty pipe with no writers
will return an end-of-file (i.e., 0 bytes read).
Write calls under similar conditions will
generate a signal.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(pipe = 42)
.br
.bd
sys; pipe
.br
.bd
(read descriptor in hl)
.br
.bd
(write .he "seek (2)                     3/19/82                     seek (2)"
.fo "				   -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
seek 
- move read/write pointer


.in -5
.bd
C
.in +5
.br
seek(descriptor, offset, from)


.in -5
.bd
FUNCTION           
.in +5
.br
Each open file has an associated read/write pointer.
.bd
Seek 
moves this pointer as follows:

.in +2
.ti -2
- If 
.bd
from 
is 0, the pointer is set to offset.
.sp
.ti -2
- If 
.bd
from 
is 1, the pointer is set to its current location plus offset.
.spdescriptor in de)


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
                                                                                                                                                                                                                                                                                                                                                                                                                      
.ti -2
- If 
.bd
from 
is 2, the pointer is set to the size of the file         
plus offset.                                                              
.sp
.ti -2
- If 
.bd
from 
is 3, 4, or 5, the meaning is the same as for 0, 1, or 2,
except that offset is multiplied by 512.
.sp
.ti -2
- If 
.bd
from 
is 0 or 3, offset is treated as signed.
Otherwise it is unsigned.
.sp
.in -2
.nf
.ce
.bd
IN SUMMARY:

.ta 8
.bd 6
Byte	Block
seeks	seeks	Motion is relative to

0	3	Beginning of file (unsigned)
1	4	Curr.he "read (2)                     3/19/82                     read (2)"
.fo "				   -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
read
- read a file


.in -5
.bd
C
.in +5
.br
.bd
read(descriptor, buffer, nbytes)
.br
.bd
char buffer[];


.in -5
.bd
FUNCTION       
.in +5
.br
A file descriptor is a word returned from a successful
.bd
open, creat, dup,
or
.bd
pipe
call.
Buffer is a memory location where at most
nbytes of data will be placed.
The number of bytes actually read is returned.
This may well be less thanent location (signed)
2	5	End of file (signed)

.fi
.bd
Seeks 
are not allowed on pipes, but are allowed on character devices,
although most such devices ignore them.
Seeking far past the end of a file and writing
will create a "hole" in the file that occupies no space.
Reading the hole will allocate zero-filled space.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.
.bp
.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(seek = 19)
.br
.bd
(descriptor in hl)
.br
.bd
sys; seek; offset; from

 nbytes;
a read on a terminal, for example, will return at most one line.
If the value 0 is returned, then the file has been exhausted.


.in -5
.bd
RETURNS
.in +5
.br
A - 1 indicates an error.  A return of 0 indicates end-of-file.
Any other value indicates a successful read of that many bytes.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(read = 3)
.br
.bd
(file descriptor in hl)
.br
.bd
sys; read; buffer; nbytes
.br
.bd
(number of bytes read in hl)


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on suc
.in -5
.bd
RETURNS
.in +5
.br 
The carry flag is cleared on success, or set on failure.
                                                                                                                                                                                                                                                                                                                                                                                                                                       cess, or set on failure.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .he "setuid (2)                   3/19/82                   setuid (2)"  
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
setuid 
- set process user IDs


.in -5
.bd
C
.in +5
.br
setuid(uid)


.in -5
.bd
FUNCTION          
.in +5
.br
This call sets the real group and user IDs
and the effective group and user IDs.
The group IDs are set to the high byte of the argument,
and the user IDs are set to the low byte.
This call can be used to set the effective IDs to the real IDs.
Only the super-user is permitted to change the real IDs.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(setuid = 23)
.br
.bd
(uid in hl)
.br
.bd
sys; setuid;


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
                                                                                                                                                                                                                               is reset to 0 after being
caught. So in general, the catching routine must
issue another signal call if it wants to continue
catching the signal.

If a signal is caught during a slow system call
(read or write to a terminal,
.bd
sleep
, or
.bd
wait
), the call will terminate prematurely and return
an error (number EINTR - see the Introduction).

After a fork, the child inherits all signal dispositions.
.bd
Exec
passes on all default and ignore dispositions,
but resets all caught signals to default action.
.he "signal (2)                   3/19/82                   signal (2)" 
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
signal
- set disposition of signals


.in -5
.bd
C
.in +5
.br
signal(sig, func)
.br
int (*func)();


.in -5
.bd
FUNCTION   
.in +5
.br
A signal is a means of notifying a process
of some external event.
A signal can be sent from the system
(in response to an attempt to execute an
illegal instruction, for example),
from a terminal (to abort a process),
or at the request of another pr

.in -5
.bd
RETURNS
.in +5
.br
The return value is the old signal disposition.
A 0 indicates success, a -1 indicates failure
(signal number out of range).


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(signal = 48)
.br
.bd
sys; signal; sig; func;
.br
.bd
(old value in hl)


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
                                                                                                                                                             ocess
(via the 
.bd
kill 
system call).
Normally, a signal causes termination
of the receiving process, but this call
allows the process either to ignore it
or to "catch" it via an interrupt to
a specified location.
There are 15 signals:

.nf
.in +4
.bd 15
1    -- (hangup)
2    interrupt (caused by typing DEL)
3    quit (caused by typing control \) *
4    illegal instruction *
5    -- (trace trap)
6    background (caused by typing control b)
7    record available at terminal **
8    -- (floating point exceph sleep.2       g stat.2        f stime.2       e stty.2        d umount.2      c unlink.2      b wait.2        a write.2       Ђ Intro.2        nice.2        ~ pause.2       } intro.2                                                                                                                                                                                                                                                                                                                                       tion)
9    kill (cannot be caught or ignored)
10   -- (bus error)
11   memory fault
12   bad argument to a system call *
13   write to a pipe with no one to read it
14   alarm clock
15   terminate (catchable kill)
.sp
.fi
.bd
* 
causes a core dump unless caught or ignored
.sp
.bd
** 
not reset when caught
.in -4

.fi
Signals marked "--" are not currently sent by the system.
(The Unix V6 descriptions are given).

A "func" of 0 tells the system to institute the default
action for the given signal. For all sig.he "sleep (2)                    3/19/82                    sleep (2)"  
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
sleep 
- stop execution for an interval


.in -5
.bd
C
.in +5
.br
sleep(seconds)


.in -5
.bd
FUNCTION   
.in +5
.br
The calling process is suspended for at least
the given number of seconds.


.in -5
.bd
RETURNS
.in +5
.br
The call returns after the given number of seconds.
A 0 indicates success, a -1 indicates failure.
The only cause of failure is an early return
caused by a caunals but 6 and 7,
this means process termination on receipt of the signal.
For signal 6, the default action is to put the process
into the "background" (all further signals, except 9, will be
ignored, and reads on a terminal will return eof).
For signal 7, the default action is to ignore the signal.
.bp
If "func" is 1, the signal will be ignored.
If "func" is any value greater than 1, then it is
taken as an address, and receipt of the signal will
cause an interrupt to that address.
Except as noted, a signalght signal.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
sleep = 35)
.br
.bd
(seconds in hl)
.br
.bd
sys; sleep


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
The only cause of failure is an early return
caused by a caught signal.
                                                                                                                                                                                                                                                      .he "stat (2)                     3/19/82                     stat (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
stat 
- get the status of a named file


.in -5
.bd
C
.in +5
.nf
.br
stat(name, buf)
char *name;
struct stat *buf;
.fi


.in -5
.bd
FUNCTION       
.in +5
.br
.bd
Stat
is identical to
.bd
fstat,
except that it operates on named files
rather than open-file descriptors.
Buf is the address of a 36 byte buffer,
into which the following information is
placed:

.nf
.bd 15
struct stat
	{
cn -5
.bd
ASSEMBLER
.in +5
.br
.bd
(stime = 25)
.br
.bd
(time in hl-de: hl = high word, de = low word)
.br
.bd
sys; stime


.in -5
.bd
RETURNS
.in +5
.fi
The carry flag is cleared on success, or set on failure.
                                                                                                                                                                                                                                                                                                              har	minor,		/* minor device */
	major;		/* major device */
int	inumber,	/* inode number */
	flags;		/* see below */
char	nlinks,		/* number of links */
	uid,		/* user id of owner */
	gid,		/* group id of owner */
	size0;		/* high byte of size */
int	size1,		/* low word of size */
	addr[8];	/* block numbers */
long	actime,		/* time of last access */
	modtime;	/* " last modification */
	};

The flags are as follows (values in octal):

.bd 15
 100000		inode is allocated
 	 060000		2-bit file type
	 000000		pla.he "stty (2)                     3/19/82                     stty (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
stty 
- set typewriter status


.in -5
.bd
C
.in +5
.bd 10
stty(descriptor, vec)
.br
struct
.nf
	{
	char	ispeed,		/* input speed */
		ospeed,		/* output speed */
		erase,		/* erase character */
		kill;		/* kill character */
	int	mode;		/* see below */
	}
	*vec;


.in -5
.bd
FUNCTION   
.in +5
.fi
.bd
Stty 
sets the status of the terminal
associated with the file descriptor.
The statin file
	 040000		directory
	 020000		character-special file
 060000		block-special file
 010000		large file
 004000		set user-id on execution
 002000		set group-id on execution
 001000		currently ignored
 000400		read (owner)
 000200		write (owner)
 000100		execute or search directory (owner)
 000070		read, write, execute (group)
 000007		read, write, execute (others)


.fi
It is not necessary to have read permission on the file,
but all directories leading to the file must be searchable.


.in -5
.bd
RETUus is taken from a 6-byte
structure pointed at by vec.
This structure is the same as that obtained by 
.bd
gtty.
Actually, this call may be made to any character device,
but devices that do not like it may
return an error.

.bd
Ispeed 
and 
.bd
ospeed 
are one of:
.nf
.in +4
.sp
.bd 16
0     1200 baud
1       50 baud
2       75 baud
3      110 baud
4    134.5 baud
5      150 baud
6      200 baud
7      300 baud
8      600 baud
9     1200 baud
10    1800 baud
11    2400 baud
12    4800 baud
13    9600 baud
1RNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(stat = 18)
.br
.bd
stat; name; buf


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
On success, the status is placed in the 36-byte area
pointed at by buf.
                                                                                                                                                                                                                       4   19200 baud
15    1200 baud
.in -4

.fi
The next two characters specify the
erase and kill characters, respectively.

The mode specifies what services are performed
by the system on input and output.
Currently, these are:
.nf
.bp
.in +4
.bd 5
0200  Use the RS-232 clear-to-send line
0040  Raw input
0020  Cr -> lf mapping
0010  Echo input
0002  Expand tabs
.in -4

.fi
In raw mode, all characters are passed immediately
to the program without waiting for a full line to be typed,
there is no erase or kill pro.he "stime (2)                    3/19/82                    stime (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
stime 
- set date and time


.in -5
.bd
C
.in +5
.br
stime(time)
.br
long * time;


.in -5
.bd
FUNCTION   
.in +5
.br
.bd
Stime 
sets the system's idea of the date and time.
The argument is the number of seconds since
0:00 GMT, January 1, 1970.
Only the super-user may make this call.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure
(not super-user).


.icessing,
and there is no recognition
of any special control characters.
In cooked mode, the following control characters
are recognized:
.in +4

.nf
.bd 6
^D  end-of-file (when typed alone on a line)
^\  send a quit signal to this tty's processes
DEL send an interrupt signal to same
^B  send a background signal to same
ESC freeze the output from this tty
^S  same as ESC
.in -4

.fi
Note that even while the tty is in raw mode,
the other modes still have an effect.

In cr->lf mode, input crs are turned into lfs,
and output crs or lfs are turned into cr-lfs.

In echo mode, input is echoed immediately.
If the mode is also raw, it is echoed exactly
as typed; otherwise, the special control characters
are not echoed, the kill character is echoed as
itself plus a newline, and the erase character
is echoed as backspace-space-backspace.

In expand-tabs mode, tabs are output as the
number of spaces needed to bring the cursor
to the next 0-mod-8 column.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates last directory entry
has disappeared.

In order to unlink a file, a user must have write
permission on its directory. Write permission is not
required on the file itself. Only the super-user
can unlink a directory.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(unlink = 10)
.br
.bd
sys; unlink; name


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
                                                 s failure
(file descriptor does not refer to a character device).


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(stty = 31)
.br
.bd
(file descriptor in hl)
.br
.bd
sys; stty; vec


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
                                                                                                                                                                                                                                                            .he "wait (2)                     3/19/82                     wait (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
wait 
- wait for a process to terminate


.in -5
.bd
C
.in +5
.br
wait(pstat)
.br
int *pstat;


.in -5
.bd
FUNCTION    
.in +5
.br
This call waits for the termination of any of the caller's children.
If any child has died since the last wait, return is immediate.
If there are no children, an error is returned.
If there are several children, several wait calls are necessary
to learn .he "umount (2)                   3/19/82                   umount (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
umount 
- dismount a file system


.in -5
.bd
C
.in +5
.br
umount(device)
.br
char *device;


.in -5
.bd
FUNCTION        
.in +5
.br
.bd
Umount 
tells the system that the given special file
should no longer be treated as a file system.
The file on which the device was mounted reverts
to its ordinary interpretation.

.bd
Umount 
will return an error if there are still any
active file                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                s on the mounted system.

This call is restricted to the super-user.


.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(umount = 22)
.br
.bd
sys; umount; device


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
                                                                                                                                                                                                   process
(process id = 1) inherits the children.


.in -5
.bd
RETURNS
.in +5
.br
A positive number indicates success, a -1 indicates failure
(no children).  On success, the pointed-to status
is filled in with the child's termination status,
and the child's process ID is returned.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(wait = 7)
.br
.bd
sys; wait
.br
.bd
(process id in hl)
.br
.bd
(status in de)


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure
(no children). On success, .he "unlink (2)                   3/19/82                   unlink (2)"      
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
unlink 
- remove a directory entry


.in -5
.bd
C
.in +5
.br
unlink(name)
.br
char *name;


.in -5
.bd
FUNCTION            
.in +5
.br
.bd
Unlink 
removes the indicated entry from its directory.
If this was the last link to the file, the file is
removed and its space is freed. If the file was open
in any process, this removal is delayed until the file
is closed, even though itthe child's process ID
is returned in hl, and its termination status is
returned in de.
                                                                                                                                                                                                                                                                                                                                                                                                                                        .he "write (2)                    3/19/82                    write (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
write 
- write to a file


.in -5
.bd
C
.in +5
.br
write(descriptor, buf, nbytes)
.br
char *buf;


.in -5
.bd
FUNCTION   
.in +5
.br
This call writes nbytes from the indicated buffer to the
given open file. The number of bytes actually written
is returned. Unlike the 
.bd
read 
call, this number should be the
same as requested; otherwise, an error is indicated.


.in -5
.bd
RETURNS
d on successful calls,
so that it remains available across message writes, etc.


.ce
.bd
Assembly Language System Calls

Syntax is given for A-Natural (Whitesmith's)
assembly language.
Translation to Intel or Zilog mneumonics is straightforward.
For example, the 
.bd
chmod 
system call in A-Natural is
.ti +8
.sp
.bd
sys; chmod; name; mode
.bp
In Intel assembly language, this looks like
.in +8
.sp
.bd 
db sys
.br
.bd
db chmod
.br
.bd
dw name
.br
.bd
dw mode
.in -8
.sp 2
.fi
The "sys" byte that begins each s.in +5
.br
A -1 indicates an error (bad descriptor or physical
IO error). Otherwise, the value nbytes is returned.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(write = 4)
.br
.bd
(descriptor in hl)
.br
.bd
sys; write; buf; nbytes


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
The number of characters actually written is returned in hl.
                                                                                                                                          ystem call
is a synonym for "restart 1".
The names of the calls themselves are
synonyms for 1-byte quantities that can be found
in the individual sections, or by
inspecting or including the files
/include/an.h and /include/intel.h.
Succeeding in-line arguments, if any, are always 2-byte quantities.
A "name" argument is always a pointer to a null-terminated string.

Registers are preserved across system calls,
except for the error flag and error number (see below),
and for any return values (see the individu.fo "		               -#-"
.rm 65
.in 5
.bd
		INTRODUCTION TO SYSTEM CALLS


This section of the manual lists all Micronix system calls.
The syntax for these calls is in most cases identical
with that for Unix Version 6 system calls, differing
only in the assembly language register names.
For most purposes, Section II of the Unix V6 Programmer's Manual
can be used as a reference in place of this one.

Call syntax for both C and assembly language is given.
Familiarity with one of these languages is necessaryal sections).
For the sake of portability, however, it is unwise to
depend on this.

From assembly language, an error is always indicated by
turning on the carry bit of the condition flags. Thus a
system call can be followed by a
jc
(jump on carry) to handle an error return, or a
jnc
(jump on no carry) to handle an error-free return.
The error number is returned in register hl.


.ce
.bd
Error Numbers

Following is a list of error numbers, their names in the
system source code, the standard error message av to
understand this section.

Many system calls take a file name.
This can be an arbitrary path name,
of unlimited length,
but it must be terminated by a 0-byte,
and the calling process must have search permission on
all directories in the path.

An error during a system call never causes an automatic
error message,
but an error number is always available (see below),
and the program can request a standard error message
if it wants [see
.bd
perror 
(3)].


.ce
.bd
C System Calls

The type of declarations giailable
thru
.bd
perror,
and a short explanation.

.bd
0	(not used)
.sp
.bd
1	EPERM	Not super user
.sp
The current user was attempting something reserved
for the super-user.
.sp
.ta 5
.in +5
.ti -5
.nf
.bd
2	ENOENT	No such file or directory
.fi
The last component of a path name does not exist.

.ti -5
.nf
.bd
3	ESRCH	No such process
.fi
The process whose number was given to
.bd
signal
does not exist, or is already dead.

.ti -5
.nf
.bd
4	EINTR	Interrupted system call
.fi
A slow system call (such as read orven for system call arguments
are not meant to be copied literally;
they are simply indications of how the system
will treat the arguments.
A string, for example,
is always acceptable in place of a 
.bd
(char *)
argument.  When no declaration is given, an 
.bd
int 
is expected.

From C, an error is indicated by an otherwise impossible
return value. This is usually -1; the individual sections
specify the details.
The error number is always left in
the external variable,
.bd
errno.
This variable is not cleare write on a tty,
but never on a disk) was interrupted by a caught signal.
.bp
.ti -5
.nf
.bd
5	EIO	I/O error
.fi
A physical I/O error occurred during a read or write.

.ti -5
.nf
.bd
6	ENXIO	No such device or address
.fi
An I/O call was made to a non-existent device, or beyond the
limits of the device.

.ti -5
.nf
.bd
7	E2BIG	Arg list too long
.fi
A call to 
.bd
exec 
was made with an argument list longer than 512 bytes.

.ti -5
.nf
.bd
8	ENOEXEC	Exec format error
.fi
An attempt was made to execute an inapp()*+,-./1234567                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   argument
.fi
An invalid argument was given to a system call:
currently, unmounting a non-mounted device, mentioning
an unknown signal in
.bd
signal,
or invoking a non-existing system call.
Ordinarily, the latter case generates a fatal signal;
the error is returned only if the signal is caught or ignored.

.ti -5
.nf
.bd
23	ENFILE	File table overflow
.fi
The system's table of open files is temporarily full.

.ti -5
.nf
.bd
24	EMFILE	Too many open files
.fi
Only 16 files can be open per process

.ti -5
.nf
.ropriate file
(such as a directory or special file), even though
the user had execute permission on the file.

.ti -5
.nf
.bd
9	EBADF	Bad file number
.fi
A file descriptor refers to no open file,
or a read or write request is made to a file
not opened for that activity.

.ti -5
.nf
.bd
10	ECHILD	No children
.fi
There were no child processes to
.bd
wait
for.

.ti -5
.nf
.bd
11	EAGAIN	No more processes
.fi
.bd
Fork
found the system process table temporarily full.

.ti -5
.nf
.bd
12	ENOMEM	Not enough core
.fi
bd
25	ENOTTY	Not a typewriter
.fi
The file mentioned to
.bd
stty
or
.bd
gtty
is not a typewriter or other character-device.

.ti -5
.nf
.bd
26	ETXTBSY	Text file busy
.fi
Not currently used.

.ti -5
.nf
.bd
27	EFBIG	File too big
.fi
The user attempted to extend a file beyond the
maximum size of 2^24 bytes.

.ti -5
.nf
.bd
28	ENOSPC	No space left on device
.fi
The disk's free space has been exhausted.

.ti -5
.nf
.bd
29	ESPIPE	Illegal seek
.fi
A seek was issued to a pipe.

.ti -5
.nf
.bd
30	EROFS	Read-only fiDuring an
.bd
exec
or
.bd
break,
the program asked for more core than the system could supply.
This is not a temporary condition: the maximum program size is
a system parameter.

.ti -5
.nf
.bd
13	EACCES	Permission denied
.fi
The user attempted a file access forbidden by the file's
permission bits.

.ti -5
.nf
.bd
14	ESYS	System error
.fi
The system has detected an "impossible" error, caused
by corrupted disk, memory, or a system bug,
but not yet severe enough to warrant a panic stop.
This should be reportele system
.fi
An attempt was made to write to a device mounted read-only.
.bp
.ti -5
.nf
.bd
31	EMLINK	Too many links
.fi
The program attempted to make a 256th link to a file.

.ti -5
.nf
.bd
32	EPIPE	Broken pipe
.fi
The program wrote on a pipe that had no reader.
Ordinarily this generates a fatal signal; the error is
returned if the signal is caught or ignored.
                                                                                                                                                   d.

.ti -5
.nf
.bd
15	ENOTBLK	Block device required
.fi
A plain file or a directory was given where a block device
was required, (in
.bd
mount,
for example).

.ti -5
.nf
.bd
16	EBUSY	Device busy
.fi
An attempt was made to mount a device that was already mounted,
to unmount a device on which there was an open file or
a current directory,
or to open a one-user-only device that is already busy.
.bp
.ti -5
.nf
.bd
17	EEXIST	File exists
.fi
The new file name passed to
.bd
link
or
.bd
mknod
is already taken.

.ti.he "nice (2)                     7/19/82                     nice (2)"
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
nice
- set process priority


.in -5
.bd
C
.in +5
.br
nice(arg)


.in -5
.bd
FUNCTION   
.in +5
.br
The "nice" of a process is the opposite of its intuitive
"priority" -- the "nicer" it is, the less cpu time it hogs.
This systen entry sets the nice of the calling process to
the given argument. Nice values range from -128 to 127;
the normal value is 0.
Only the super-user can set a n -5
.nf
.bd
18	EXDEV	Cross-device link
.fi
A link to a file on another device was attempted.

.ti -5
.nf
.bd
19	ENODEV	No such device
.fi
An attempt was made to open a non-existent device.

.ti -5
.nf
.bd
20	ENOTDIR	Not a directory
.fi
A non-directory was specified where a directory was required,
as an intermediate component in a path name, for example, or
as an argument to
.bd
chdir
.

.ti -5
.nf
.bd
21	EISDIR	Is a directory
.fi
An attempt was made to write on a directory.

.ti -5
.nf
.bd
22	EINVAL	Invalidegative nice (== high
priority). Long running background programs should be
run at a positive nice as a favor to other users.

A process' nice is passed to its children via the
.bd
fork
system call.

.in -5
.bd
RETURNS
.in +5
.br
A 0 indicates success, a -1 indicates failure.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
(nice = 34)
.br
.bd
(nice value in hl)
.br
.bd
sys; nice;


.in -5
.bd
RETURNS
.in +5
.br
The carry flag is cleared on success, or set on failure.
                                                  .he "pause (2)                    3/19/82                    pause (2)"  
.fo "				    -#-"
.in 5
.rm 65
.bd
NAME
.in +5
.br
.bd
pause 
- wait for a signal


.in -5
.bd
C
.in +5
.br
pause()


.in -5
.bd
FUNCTION   
.in +5
.br
This call suspends the calling process until the receipt of a signal.
If the signal is caught,
( see
.bd
signal (2)
), then the pause() returns (with an "interrupted system call" error).
Otherwise, the signal kills the process.

See also
.bd
alarm (2) and sleep(2).

.in -5
.bd
RETURNS
xternal variable,
.bd
errno.
This variable is not cleared on successful calls,
so that it remains available across message writes, etc.


.ce
.bd
Assembly Language System Calls

Syntax is given for A-Natural (Whitesmith's)
assembly language.
Translation to Intel or Zilog mneumonics is straightforward.
For example, the 
.bd
chmod 
system call in A-Natural is
.ti +8
.sp
.bd
sys; chmod; name; mode
.bp
In Intel assembly language, this looks like
.in +8
.sp
.bd 
db sys
.br
.bd
db ch.in +5
.br
.bd
Pause
returns only after a signal has been caught, and always with
an EINTR error (see Intro(2)). If the signal is received but
not caught, then the process is killed and the pause() never
returns.


.in -5
.bd
ASSEMBLER
.in +5
.br
.bd
pause = 29)
.br
.bd
sys; pause
                                                                                                                                                                                                                                      mod
.br
.bd
dw name
.br
.bd
dw mode
.in -8
.sp 2
.fi
The "sys" byte that begins each system call
is a synonym for "restart 1".
The names of the calls themselves are
synonyms for 1-byte quantities that can be found
in the individual sections, or by
inspecting or including the files
/include/an.h and /include/intel.h.
Succeeding in-line arguments, if any, are always 2-byte quantities.
A "name" argument is always a pointer to a null-terminated string.

Registers are preserved across system .fo "		               -#-"
.rm 65
.in 5
.bd
		INTRODUCTION TO SYSTEM CALLS


This section of the manual lists all Micronix system calls.
The syntax for these calls is in most cases identical
with that for Unix Version 6 system calls, differing
only in the assembly language register names.
For most purposes, Section II of the Unix V6 Programmer's Manual
can be used as a reference in place of this one.

Call syntax for both C and assembly language is given.
Familiarity with one of these languagcalls,
except for the error flag and error number (see below),
and for any return values (see the individual sections).
For the sake of portability, however, it is unwise to
depend on this.

From assembly language, an error is always indicated by
turning on the carry bit of the condition flags. Thus a
system call can be followed by a
jc
(jump on carry) to handle an error return, or a
jnc
(jump on no carry) to handle an error-free return.
The error number is returned in register hl.


.ce
.bes is necessary to
understand this section.

Many system calls take a file name.
This can be an arbitrary path name,
of unlimited length,
but it must be terminated by a 0-byte,
and the calling process must have search permission on
all directories in the path.

An error during a system call never causes an automatic
error message,
but an error number is always available (see below),
and the program can request a standard error message
if it wants [see
.bd
perror 
(3)].


.ce
.bd
C Systd
Error Numbers

Following is a list of error numbers, their names in the
system source code, the standard error message available
thru
.bd
perror,
and a short explanation.

.ti -5
.bd
0	(not used)
.sp
.ti -5
.bd
1	EPERM	Not super user
.sp
The current user was attempting something reserved
for the super-user.
.sp
.ta 5
.in +5
.ti -5
.nf
.bd
2	ENOENT	No such file or directory
.fi
The last component of a path name does not exist.

.ti -5
.nf
.bd
3	ESRCH	No such process
.fi
em Calls

The type of declarations given for system call arguments
are not meant to be copied literally;
they are simply indications of how the system
will treat the arguments.
A string, for example,
is always acceptable in place of a 
.bd
(char *)
argument.  When no declaration is given, an 
.bd
int 
is expected.

From C, an error is indicated by an otherwise impossible
return value. This is usually -1; the individual sections
specify the details.
The error number is always left in
the eThe process whose number was given to
.bd
signal
does not exist, or is already dead.

.ti -5
.nf
.bd
4	EINTR	Interrupted system call
.fi
A slow system call (such as read or write on a tty,
but never on a disk) was interrupted by a caught signal.
.bp
.ti -5
.nf
.bd
5	EIO	I/O error
.fi
A physical I/O error occurred during a read or write.

.ti -5
.nf
.bd
6	ENXIO	No such device or address
.fi
An I/O call was made to a non-existent device, or beyond the
limits of the device.

.ti -5<=>?@ABCEFGHIJKL                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                e.

.ti -5
.nf
.bd
20	ENOTDIR	Not a directory
.fi
A non-directory was specified where a directory was required,
as an intermediate component in a path name, for example, or
as an argument to
.bd
chdir
.

.ti -5
.nf
.bd
21	EISDIR	Is a directory
.fi
An attempt was made to write on a directory.

.ti -5
.nf
.bd
22	EINVAL	Invalid argument
.fi
An invalid argument was given to a system call:
currently, unmounting a non-mounted device, mentioning
an unknown signal in
.bd
signal,
or in
.nf
.bd
7	E2BIG	Arg list too long
.fi
A call to 
.bd
exec 
was made with an argument list longer than 512 bytes.

.ti -5
.nf
.bd
8	ENOEXEC	Exec format error
.fi
An attempt was made to execute an inappropriate file
(such as a directory or special file), even though
the user had execute permission on the file.

.ti -5
.nf
.bd
9	EBADF	Bad file number
.fi
A file descriptor refers to no open file,
or a read or write request is made to a file
not opened for that activity.

.ti -5
.nfvoking a non-existing system call.
Ordinarily, the latter case generates a fatal signal;
the error is returned only if the signal is caught or ignored.

.ti -5
.nf
.bd
23	ENFILE	File table overflow
.fi
The system's table of open files is temporarily full.

.ti -5
.nf
.bd
24	EMFILE	Too many open files
.fi
Only 16 files can be open per process

.ti -5
.nf
.bd
25	ENOTTY	Not a typewriter
.fi
The file mentioned to
.bd
stty
or
.bd
gtty
is not a typewriter or other character-device.

.bd
10	ECHILD	No children
.fi
There were no child processes to
.bd
wait
for.

.ti -5
.nf
.bd
11	EAGAIN	No more processes
.fi
.bd
Fork
found the system process table temporarily full.

.ti -5
.nf
.bd
12	ENOMEM	Not enough core
.fi
During an
.bd
exec
or
.bd
break,
the program asked for more core than the system could supply.
This is not a temporary condition: the maximum program size is
a system parameter.

.ti -5
.nf
.bd
13	EACCES	Permission denied
.fi
The user attempted 
.ti -5
.nf
.bd
26	ETXTBSY	Text file busy
.fi
Not currently used.

.ti -5
.nf
.bd
27	EFBIG	File too big
.fi
The user attempted to extend a file beyond the
maximum size of 2^24 bytes.

.ti -5
.nf
.bd
28	ENOSPC	No space left on device
.fi
The disk's free space has been exhausted.

.ti -5
.nf
.bd
29	ESPIPE	Illegal seek
.fi
A seek was issued to a pipe.

.ti -5
.nf
.bd
30	EROFS	Read-only file system
.fi
An attempt was made to write to a device mounted read-only.
.bp
.ti -5
.na file access forbidden by the file's
permission bits.

.ti -5
.nf
.bd
14	ESYS	System error
.fi
The system has detected an "impossible" error, caused
by corrupted disk, memory, or a system bug,
but not yet severe enough to warrant a panic stop.
This should be reported.

.ti -5
.nf
.bd
15	ENOTBLK	Block device required
.fi
A plain file or a directory was given where a block device
was required, (in
.bd
mount,
for example).

.ti -5
.nf
.bd
16	EBUSY	Device busy
.fi
An attempt was maf
.bd
31	EMLINK	Too many links
.fi
The program attempted to make a 256th link to a file.

.ti -5
.nf
.bd
32	EPIPE	Broken pipe
.fi
The program wrote on a pipe that had no reader.
Ordinarily this generates a fatal signal; the error is
returned if the signal is caught or ignored.
                                                                                                                                de to mount a device that was already mounted,
to unmount a device on which there was an open file or
a current directory,
or to open a one-user-only device that is already busy.
.bp
.ti -5
.nf
.bd
17	EEXIST	File exists
.fi
The new file name passed to
.bd
link
or
.bd
mknod
is already taken.

.ti -5
.nf
.bd
18	EXDEV	Cross-device link
.fi
A link to a file on another device was attempted.

.ti -5
.nf
.bd
19	ENODEV	No such device
.fi
An attempt was made to open a non-existent devic| .              ..            { alloc.3       z ctime.3       y fclose.3      x ferror.3      w fopen.3       v fread.3       u fseek.3       t getpwent.3    s gets.3        r putc.3        q puts.3        ђ scanf.3       Џ setbuf.3      Ћ stdio.3       Ќ system.3      Њ ttyname.3     ‹ floor.3       Љ perror.3      ‰ popen.3       € printf.3                                                                                                                                                                      .he "alloc (3)                    3/22/82                    alloc (3)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
alloc, free, realloc, calloc
- main memory allocator
.sp 2
.in -5
.bd
C
.in +5
.br
.bd 2
char *alloc(size)
.br
unsigned size;
.sp
.bd 2
free(ptr)
.br
char *ptr;
.sp
.bd 3
char *realloc(ptr, size)
.br
char *ptr;
.br
unsigned size;
.sp
.bd 2
char *calloc(nelem, elsize)
.br
unsigned nelem, elsize;
.sp 2
.in -5
.bd
FUNCTIONS
.in +5
.br
The routines
.bd
al0.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              loc
and
.bd
free
provide an easy-to-use memory allocation package.  The
.bd
alloc
routine returns a pointer to a block of at least
.bd
size
bytes long, which begins on a word boundary.

The argument to
.bd
free
is a pointer to a block allocated previously by
.bd
alloc.
This block is available for further allocation; its contents are
left undisturbed.

.bd
Alloc 
allocates the first large reach of free space it finds in its
circular search from the last allocated or freed block,
uniting neighboring free bloc.he "ctime (3)                    3/22/82                    ctime (3)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
ctime, localtime, gmtime, asctime, timezone
- convert time and date to ASCII
.sp 2
.in -5
.bd
C        
.in +5
.br
.bd 2
char *ctime(clock)
.br
long *clock
.sp
.bd
#include <time.h>
.sp
.bd 2         
struct tm *localtime(clock)
.br
long *clock;
.sp
.bd 2
struct tm *gmtime(clock)
.br
long *clock;
.sp
.bd 2
char *asctime(tm)
.br
struct tm *tm;
.sp
.bd
ks as it searches.  If no additional space
is free, 
.bd
alloc
calls
.bd
sbrk
(see section 2) for more system memory.

Block sizes pointed to by
.bd
ptr
are changed by
.bd
realloc
to 
.bd
size
bytes.  It may also return a pointer to a block, if the block
iу removed®  Thе valuеs oж thе neч anд olд blocл 
sizes determine the changes in block contentу; the contents remain
unchanged up to the lesser value of the old and new sizes.
 
.bd
Alloc
contains a valuable search function which may be used to do storage
cchar *timezone(zone,dst)
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
.bd
Ctime
converts a time pointed to by 
.bd
clock
[as returned by 
.bd
time
(2)] 
into ASCII.  It returns a pointer to a 26-character string in the
following form:
.sp 2
.ce
.bd
Wed Mar 10 12:12:59 1982\n\0
.sp
All fields have constant width.
.sp 2
.bd
Localtime
and
.bd
gmtime
return pointers to structures containing the broken-down time.

.bd
Localtime
corrects for the time zone and daylight savings time, if necessary.

.bd
Gmtime 
converts ompaction.
.bd
Realloc works if
.bd
ptr
points to a block that has been freed since the last call of
.bd
alloc, realloc
or
calloc.
Compounding sequences of
.bd
free, alloc
and
realloc 
thereby augments
.bd
alloc's
search strategy for storage compaction.

Allocation of space for an array of
.bd
nelem
elements of
.bd
elsize
size is done by
.bd
calloc.  Each of these routines returns a pointer to a space
aligned for any type of storage.
.sp 2
.in -5
.bd
ERRORS
.in +5
.br
Note that chaos results if space assignto Greenwich Mean Time - the time that Micronix uses.

.bd
Asctime 
converts broken-down time to ASCII and returns a 26-character string.
.sp
The 
.bd
include
file structure declaration follows:
.bp
.nf
.in +8
.bd 11
struct tm { /* see ctime(3) */
	int	tm_sec;
	int	tm_min;
	int	tm_hour
	int	tm_mday;
	int	tm_mon;
	int	tm_year;
	int	tm_wday;
	int	tm_yday;
	int	tm_isdst;
};
.in -8
.sp 2
.fi
The time is given using the following elements:
.sp
.in +8
- 24 hour clock
.br
- day of month, 1-31 days per month
.br
- ed by 
.bd
alloc
is overrun, or if a random number is given to
.bd
free.

A NULL pointer (0) is returned by
.bd
alloc, realloc
and
.bd
calloc
if no memory is available, or if a corrupt arena is detected that was
caused by storage outside the bounds of a block.  If user wishes to
recompile the
.bd
alloc
routine to rigidly check the arena during every transaction, he/she
is referred to the source code.
.sp 2
.in -5
.bd
NOTES
.in +5
.br
The block pointed to by
.bd
ptr
may be destroyed if
.bd
realloc
returns a month of year, numbered 0-11
.br
- day of the week, numbered 0-6
.br
- date of the year, beginning 1900 - 
.br
- day of the year, 0-365
.br
- non-zero flag indicates daylight savings 
.sp 2
.in -8
The program checks the system to determine if time zone and/or
daylight savings time adjustments are appropriate whenever the 
local time is called for.  (Adjustments for changes in these conversions
in 1974 and 1975 are included.)

.bd
Timezone 
returns the time zone, measured in minutes westward from
Greenwich, associated with its first argument.  If the second argument
is 0, the standard name is used.  A non-zero flag indicates daylight
savings time.

A table is built into the routine.  If the required name does not
appear on this table, the difference from GMT is produced.  
In Afghanistan, for example:
.sp
.ce
.bd
timezone(-60*4+30), 0)
.sp
would be appropriate because it is eastward of GMT +4:30.  The string
.bd
GMT+4:30
is produced.
.sp 2
.in -5
.bd
ERRORS
.in +5
.br
The return values point to static data whoe implemented as macros and cannot
be redeclared:

.bd
Feof
returns a non-zero when an end of file is read on the named input
stream; otherwise a zero is returned.

.bd
Ferror
returns a non-zero when an error occurs while reading or writing
the named 
.bd
stream.  Error must be cleared by
.bd
clearerr
or the error indication lasts until the stream is closed.  A zero
is returned if no error occurs.

.bd
Fileno
returns an integer file descriptor associated with 
.bd
stream
[see
.bd
open
(2)].
.sp 2
.in -5
.bdse content is overwritten by 
each call.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
time (2)                                                                                                                                                                                                                                                                                                                                                                                                                                         
ALSO READ
.in +5
.br
fopen (3), open (2)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .he "fclose (3s)                  3/22/82                  fclose (3s)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
fclose, fflush
- close or flush a stream
.sp 2
.in -5
.bd
C           
.in +5
.br
.bd
#include <stdio.h>
.sp
.bd 2
fclose(stream)
.br
FILE *stream;
.sp
.bd 2
fflush(stream)
.br
FILE *stream;
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
.bd
Fclose
causes any buffers for the named
.bd
stream
to be emptied and the file to be closed.  Buffers
allocated by the .he "fopen (3s)                   3/22/82                   fopen (3s)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
fopen, freopen, fdopen
- open a stream
.sp 2
.in -5
.bd
C
.in +5
.br
.bd
#include <stdio.h>
.sp
.bd 2
FILE *fopen(filename, type)
.br
char *filename, *type;
.sp
.bd 3
FILE freopen(filename, type, stream)
.br
char *filename, *type;
.br
FILE *stream;
.sp
.bd 2
FILE *fdopen(fildes, type)
.br
char *type;
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
.bd
Fopen
ostandard I/O system are freed.  This function is
performed automatically by calling
.bd
exit
(2).

.bd
Fflush 
causes any buffered data for the named output
.bd
stream
to be written to that file.  The stream file remains open.
.sp 2
.in -5
.bd
ERRORS        
.in +5
.br
These routines return an
.bd
EOF
if
.bd
stream 
is not associated with an output file, or if
buffered data cannot be transferred to that file.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
close (2), fopen (3), setbuf (3)
                            pens the file specified by "filename" and associates it with a stream. 
It returns a pointer to be used to identify the stream in subsequent
operations.
.sp
.bd
Type
is a character containing one of the following values:
.sp
.in +8
.bd
a
- append; begin new writing, or begin at end 
.nf
    of current writing.
.sp
.fi
.bd
r
- open for reading
.sp
.bd
w
- create for writing
.sp 2
.in -8
.bd
Freopen
substitutes the named file in place of an open stream; it returns the
original value of
.bd
stream.  
The origi.he "ferror (3s)                  3/22/82                  ferror (3s)
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
feof, ferror, clearerr, fileno
- stream status inquiries
.sp 2
.in -5
.bd
C         
.in +5
.br
.bd
#include <stdio.h>
.sp
.bd 2
feof(stream)
.br
FILE *stream;
.sp
.bd 2
ferror(stream)
.br
FILE *stream
.sp
.bd 2
clearerr(stream)
.br
FILE *stream
.sp
.bd 2
fileno(stream)
.br
FILE *stream
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
The following functions arnal value of 
.bd
stream
is closed.  This routine may also be used to attach preopened constant
names -
.bd
stdin, stdout, stderr,
- to specified files.

.bd
Fdopen
associates a stream with a file descriptor obtained from
.bd
creat, dup, open
or
.bd
pipe 
(see section 2). The 
.bd
type
of the stream must agree with the mode of the open file.
.bp
.in -5
.bd
NOTES
.in +5
.br
If
.bd
filename
cannot be accessed,
.bd
fopen
and
.bd
freopen
return the NULL pointer.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
open (2), fclose (3)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ion on 
.bd
stream.
This new position is at the signed distance, which is
.bd
offset
byteу froн thе beginninз oж thе file¬ thе currenф position¬ oт aф 
thе enд oж thе file, determined by whether 
.bd
ptrname
has a value of 0, 1 or 2.  This routine also undoes any effects
of the 
.bd
unget
routine.

.bd
Ftell
returns the current value of the offset relative to the beginning
of the file associated with the named
.bd
stream.
This routine provides the only foolproof way to obtain an 
.bd
offset
for
.bd
fseek.

.he "fread (3s)                   3/22/82                   fread (3s)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.bd
fread, fwrite
- buffered binary I/O
.sp 2
.in -5
.bd
C
.in +5
.br
.bd
#include <stdio.h>
.sp
.bd 2
fread(ptr, sizeof(*ptr), nitems, stream)
.br
FILE *stream;
.sp
.bd 2
fwrite(ptr, sizeof(*ptr), nitems, stream)
.br
FILE *stream;
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
.bd
Fread
reads 
.bd
nitems
of 
.bd
*ptr
data from the named input stream into a block beRewind(stream) = fseek(stream, 0l, 0).
.sp 2
.in -5
.bd
ERRORS     
.in +5
.br
A -1 is returned by
.bd
fseek
for improper seeks.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
lseek (2), fopen (3)

                                                                                                                                                                                                                                                                                                                                   ginning at
.bd
ptr.
The return is the number of items actually read.

The standard output is line buffered if
.bd
stream
is
.bd
stdin;
any partial output line is flushed before any call to
.bd
read
(see section 2) to satisfy the
.bd
fread
call.

.bd
Fwrite 
appends
.bd
nitems
(maximum) of data to the named output stream.  Data is of the type 
.bd
*ptr
beginning at
.bd
ptr.
It returns the actual number of items written.
.sp 2
.in -5
.bd
DIAGNOSTICS
.in +5
.br
A 0 is returned by 
.bd
fread
and
.bd
fwrite
upon.he "getpwent (3)                  3/22/82                getpwent (3)"
.fo "                                -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
getpwent, getpwuid, getpwnam, setpwent, endpwent
- get password file entry
.sp 2
.in -5
.bd
C
.in +5
.br
.bd
#include <pwd.h>
.sp
.bd
struct passwd *getpwent()
.sp
.bd 2
struct passwd *getpwuid(uid)
.br
int uid;
.sp
.bd 2
struct passwd *getpwnam(name)
.br
char *name;
.sp
.bd
int setpwent()
.sp
.bd
int endpwent()
.sp 2
.in -5
.bd
DESCRIPTIONS
.in +5
. error or at end of file.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
reaд (2)¬ writе (2)¬ fopeо (3)¬ getг (3)¬ putг (3)¬ putу (3)¬ 
printж (3) and scanf (3).
                                                                                                                                                                                                                                                                                                                                                                       br
Each of the "get" routines - 
.bd
getpwent, getpwuid
and
.bd
getpwnam
- each return a pointer to an object with the following structure:
.sp
.in +8
.nf
.bd 7 
    struct passwd                         
        {
	char	*name               
	        *passwd,  
	unsigned char uid, gid;
	char    *person, *dir, *shell;
        }
.sp 
.fi
.in -8
Eacи pointeт containу thе broken-ouф fieldу oж б linе iо thе 
passworд file®				

Two fields, 
.bd
pw_quota
and
.bd
pw_comment,
are unused.  All the other fields have .he "fseek (3s)                   3/22/82                   fseek (3s)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
fseek, ftell, rewind
- reposition a stream
.sp 2
.in -5
.bd
C         
.in +5
.br
.bd
#include <stdio.h>
.sp
.bd 3
fseek(stream, offset, ptrname)
.br
FILE *stream;
.br
long offset;
.sp
.bd 2
long ftell(stream)
.br
FILE *stream;
.sp
.bd
rewind(stream)
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
.bd
Fseek
sets the position of the next input or output operatmeanings which are described
in
.bd
passwd
(5).

Routine Functions:
.sp
.in +5
.bd
getpwent
- reads the next line in the file; it will open the file, if necessary.
.sp
.bd
setpwent
- rewinds the file
.sp
.bd
endpwent
- closes the file
.sp
.bd
getpwuid
- searches from the beginning of the file until a matching user ID is
found, or until an end of file is encountered.
.sp
.bd
getpwnam
- searches from the beginning of the file until a matching name is
found, or until an end of file is encountered.
.sp 2
.in 0
.in 5
.bd
ERRORS
.in +5
.br
A zero (NULL pointer) is returned upon an error or at end of file.
.sp 2
.in -5
.bd
NOTES
.in +5
.br
All information to be saved should be copied since it is contained only
in a temporary area.
.sp 2
.in -5
.bd
FILES
.in +5
.br
/etc/passwd
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
getlogin (3), passwd (5)


                                                                                                                                                                                    to
.bd
stream,
the named output; it returns the character written.

.bd
Putchar(c)
is the same as
.bd
putc(c, stdout).

.bd
Fputc
acts the same as
.bd
putc
but is a function rather than a macro.  It can be used to save
object text.

.bd
Putw
appends 
.bd
w
(word) to output 
.bd
stream 
and returns the word written.  It does not assume or cause
special alignment in the file.

.bd
Stdout
(standard stream) is only buffered if the output refers to something
other than a terminal (default).
.bd
Setbuf
(3) chang.he "gets (3s)                    3/22/82                    gets (3s)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
gets, fgets
- get a string from a stream
.sp 2
.in -5
.bd
C
.in +5
.br
.bd
#include <stdio.h>
.sp
.bd 2
char *gets(s)
.br
char *s;
.sp
.bd 3
char *fgets(s, n, stream)
.br
FILE *stream;
.sp 2
.in -5
.bd
FUNCTION
.in +5
.br
.bd
Gets
reads a string into 
.bd
s
from the standard input stream, 
.bd
stdin.
A newline character terminates the string.  This ches the default.

.bd
Stderr
(also a standard stream) is unbuffered unconditionally (default).
.bd
Freopen
[see
.bd
fopen 
(3)] causes it to become buffered; again,
.bd
setbuf
changes the default.

Unbuffered output streams appear on the destination file or terminal
as soon as they are written.  Buffered output streams save up characters
and write them as a block.  Blocks may be forced out prematurely with
.bd
fflush
[see
.bd
fclose
(3)].
.sp 2
.in -5
.bd
ERRORS
.in +5
.br
These functions return the end of faracter is replaced
in
.bd
s
by a NULL character;
.bd
gets
returns its argument.

.bd
Fgets
reads 
.bd
n-1
characters (or up to a newline character) from the
.bd
stream
into the
.bd
s
string®  Б NULL characteт followу thе lasф characteт reaд into
.bd
s; fgets 
returns its first argument.
.sp 2
.in -5
.bd
ERRORS
.in +5
.br
Both
.bd
gets
and
.bd
fgets
return the constant pointer (NULL) upon an error or at end of file.
.sp 2
.in -5
.bd
NOTES
.in +5
.br
To maintain backward compatibility,
.bd
fgets
maintains a ile constant upon error. 

.bd
Ferror
(3) should be used to detect
.bd
putw
errors.

Errors may occur some time after the initial call to
.bd
putc.
.sp 2
.in -5
.bd
NOTES
.in +5
.br
Since 
.bd
putc
is implemented as a macro, it treats a
.bd
stream
argument improperly.  Specifically,

.ce
.bd
putc(c, *f++);

does not work sensibly.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
fopen (3), fclose (3), getc (3), puts (3), printf (3), fread (3)                                                                             newline,
.bd
gets
deletes a newline.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
puts (3), getc (3), scanf (3), fread (3), ferror (3)                                                                                                                                                                                                                                                                                                                                                                                                 .he "puts (3s)                    3/24/82                    puts (3s)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
puts, fputs
- put a string on a stream
.sp 2
.in -5
.bd
C
.in +5
.br
.bd
#include <stdio.h>
.sp
.bd 2
puts(s)
.br
char *s;
.sp
.bd 3
fputs(s, stream)
.br
char *s;
.br
FILE *stream;
.sp 2
.in -5
.bd
FUNCTION
.in +5
.br
.bd
Puts
copies 
.bd
s
(null-terminated string) to
.bd
stdout,
the standard output stream.  It also appends a newline character.

.bd
F.he "putc (3s)                    3/23/82                    putc (3s)"
.fo "                               -#-"
.in 5
.rm 65
.bd
PROGRAM(S)
.in +5
.br
.bd
puts, putchar, fputc, putw
- put character or word on a stream
.sp 2
.in -5
.bd
C
.in +5
.br
.bd
#include <stdio.h>
.sp
.bd 3
int putc(c, stream)
.br
char c;
.br
FILE *stream;
.sp
.bd
putchar(c)
.sp
.bd 2
fputc(c, stream)
.br
FILE *stream;
.sp
.bd 2
putw(w stream)
.br
FILE *stream;
.sp 2
.in -5
.bd
FUNCTIONS
.in +5
.br
.bd
Putc
appends 
.bd
c
(character)puts
copies
.bd
s
to the named output,
.bd
stream.

Neither of these routines copies the terminal NULL character.
.sp 2
.in -5
.bd
NOTES
.in +5
.br
To maintain backward compatibility, 
.bd
puts
appends a newline,
.bd
fputs
does not.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
fopeо (3)¬ getу (3)¬ putг (3)¬ printж (3)¬ ferroт (3)¬ fwritе iо 
freaд (3)                                                                                                                                                                      .he "scanf (3s)                   3/24/82                   scanf (3s)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
scanf, fscanf, sscanf
- formatted input conversion
.sp 2
.in -5
.bd
C
.in +5
.br
.bd
#include <stdio.h>
.sp
.bd 2
scanf(format [, pointer]...)
.br
char *format;
.sp
.bd 3
fscanf(stream, format [, pointer]...)
.br
FILE *stream;
.br
char *format;
.sp
.bd 2
sscanf(s, format [, pointer]...)
.br
char *s, *format;
.sp 2
.in -5
.bd
FUNCTION
.in +5
.br
.bd
Scer that will be added.  A
space character or newline terminates the input field.
.sp
.ti -1
.bd
c
.br
Character expected.  Corresponding argument should be a character pointer. 
The normal skip-over-space characters are suppressed.  Use "%ls" to
read the next non-space character.  

Corresponding argument should refer
to a character array and indicate number of characters read if a field
width is given.
.sp
.ti -1
.bd
e, f
.br
Floating point number is expected.  Next field is converted and stored
through thanf
reads from 
.bd
stdin,
the standard input stream.

.bd
Fscanf
reads from the named input,
.bd
stream.

.bd
Sscanf
reads from the
.bd
s
character string.

Each of these functions read and interpret characters
according to a format, then store the results in its argument.
A control string
.bd
format
and a set of 
.bd
pointer
arguments indicating where the converted input is stored are
arguments expected by these routines.  These are described below.
.sp 2
.in +4
Blanks, tabs or newlines, which match optioe corresponding argument which should be a pointer to a 
.bd
float.

The format for floating point numbers is an optionally signed string
of digits that may contain a decimal point followed by an optional
exponent field consisting of E (or e), followed by an optionally signed
integer.
.bp
.ti -1
.bd
[
.br
Left bracket indicates a string not to be delimited by space
characters. The string is defined by characters followed by a right bracket.
A
.bd
^
as the first character after the left bracket defines the inal white space in the input.

Any ordinary character besides % that must match the next character
of the input stream.

Optional conversion specifications, which consist of an assignment
suppressing character (*), maximum field width number, a conversion
character and the % character.

.in -4
The control string usually contains conversion specifications that
direct interpretation of the next input field.  Unless assignment
suppression was indicated (using the * character), the result is placed
in the varianput field
as all characters in the set of characters following the 
.bd
^ 
sign®  Absencе oж thiу sign meanу thе inpuф fielд iу alм thе 
characterу withiо the brackets.  Corresponding argument must point to
a character array.
.sp 2
.in -4
The conversion characters
.bd
d, o
and
.bd
x
may be either capitalized or preceded by an
.bd
l
to indicate that a pointer to
.bd
long
rather than
.bd
int
is in the argument list. If these are preceded by
.bd
h,
indicates a pointer to 
.bd
short
rather than
.bd
int.

The
.ble pointed to by the corresponding argument.

An input field is a string of non-space characters.  The field extends
to the next inappropriate character, or until the field width (if
specified) is exhausted.

The interpretation of the input field is indicated by the conversion
character.  Corresponding pointer arguments are usually of a restricted
type.  A list and description of legal conversion characters follows:
.sp 2
.in +4
.ti -1
.bd
%
.br
A single percent sign (%) is expected.  No assignment is donevwxyz{|}ЂЃ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
.sp
.ti -1
.bd
d
.br
Decimal integer is expected.  Corresponding argument should be integer
pointer.
.sp
.ti -1
.bd
o
.br
Octal integer expected.  Corresponding argument should be integer pointer.
.sp
.ti -1
.bd
x
.br
Hexadecimaм integeт expected® Correspondinз argumenф shoulд bе 
integeт pointer.
.sp
.ti -1
.bd
s
.br
Character string expected.  Corresponding argument should be a character
pointer pointing to an array of characters.  Array must be large enough
to accept string and terminating "\0" charactbd
e
and
.bd
f
conversion characters may also be capitalized or preceded by
.bd
l
to indicate a pointer to
.bd
double
rather than
.bd
float.

.bd
Scanf
returns the number of input items successfully matched and assigned.
This may also be used to decide how many items were actually found.
The constant end of file is returned upon end of input.  This is different
froн 0¬ whicи maщ bе interpreteд tп meaо nп conversioо waу done®  
Iж conversion was intended, it was frustrated by an inappropriate 
character in the input.  As an example:
.sp
.in +8
.bd 2
int i; float x; char name[50];
.br
scanf("%d%f%s", &i, &x, name);
.sp
.in -8
with the input
.sp
.in +8
.bd
25 54.32E-1 McCleary
.sp
.in -8
assigns to
.bd
i
the value 25, 
.bd
x
the value 5.432.  Name contains "mccleary\0". Another example:
.sp
.in +8
.bd 2
int i; float x; char name[50];
.br
scanf("%2d%f%*d%[1234567890]", &i, &x, name
.sp
.in -8
with the input
.sp
.in +8
.bd
56789 0123 56a72
.sp
.in -8
assigns 56 to
.bd
i,
789.0 to
.bd
x,
skips "0123" and places the.he "stdio (3s)                    3/22/82                  stdio (3s)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINES
.in +5
.br
.bd
stdio
- standard buffered I/O package
.sp 2
.in -5
.bd
C           
.in +5
.br
.bd
#include <stdio.h>
.sp
.bd
FILE *stdin;
.br
.bd
FILE *stdout;
.bd
.br
FILE *stderr;
.sp 2
.in -5
.bd
FUNCTION   
.in +5
.br
This section describes two levels of buffered input/output utilities:
1) in-line macros designated by (3), and 2) higher level standard I/O
utilitie string "56\0" in 
.bd
name.
The next call to
.bd
getchar
will return "a".
.bp
.in -5
.bd
ERRORS
.in +5
.br
The success of matches and suppressed assignments can be determined
only indirectly.
.sp 2
.in -5
.bd
NOTES
.in +5
.br
In cases of missing or illegal data,
.bd
scanf
returns an end of file on end of input.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
atof (3), getc (3), printf (3)


                                                                                                                               s designated by (3s) or (3m).

The in-line macros,
.bd
getc
and
.bd
putc
handle characters quickly.

Routines such as
.bd
gets, fgets, printf, fprintf, fwrite, fread, puts
and
.bd
scanf
and
.bd
fscanf
use the in-line macros; both levels may be freely intermixed.

Files with this type of associated buffering are called
.bd
streams
and are declared to be a pointer to a defined type
.bd
FILE.  Fopen
(3) has the ability to create descriptive data for streams.  It
returns a pointer to designate the stream in all.he "setbuf (3s)                  3/24/82                  setbuf (3s)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
setbuf
- assign buffering to a stream
.sp 2
.in -5
.bd
C
.in +5
.br
.bd
#include <stdio.h>
.sp
.bd 3
setbuf(stream, buf)
.br
FILE *stream;
.br
char *buf;
.sp 2
.in -5
FUNCTION
.in +5
.br
.bd
Setbuf
is used after a stream is opened, but before it is read or written to
cause the
.bd
buf
character array to be used instead of an automatically allocated bu further transactions.
Normally, there are three open streams with constant pointers declared 
in the 
.bd
include 
file associated with a standard open file:
.sp
.in +4
.bd 
stdin
- standard input file
.br
.bd
stdout
- standard output file
.br
.bd
stderr
- standard error file
.sp 2
.in -4	
A constant "pointer" (NULL 0) designates no stream.
.sp
Aо integeт constanф (end of file, or EOЖ -1© iу returneд upoо erroт bщ anщ 
integeт functionу that deal with streams or upon end of file.

Routines that use the I/Offer.

If
.bd
buf
is NULL (constant pointer), I/O is completely unbuffered.

Size of array is determined by a the constant, BUFSIZ.  An example:
.sp
.ce
.bd
char buf[BUFSIZ];
.sp
A buffer is obtained from
.bd
alloc
(3) upon the first 
.bd
getc
or
.bd
putc
on the file.  One exception is when the standard output is directed
to a terminal, in which case it is line buffered.  Normally, output
streams directed to terminals and
.bd
stderr
(standard error stream) are not buffered. 

When standard output is line bu package must have the header file 
with the pertinent macro definitions (<stdio.h>).  The 
.bd
include
file declares all functions and constants described in the sections
designated by (3s); they need no further declaration.
.bp
The following constants and functions are used as macros:
.sp
.in +8
.bd
feof  ferror  fileno  getc  getchar  putc
.in -8
.sp
It is dangerous to redeclare these names.
.sp 2
.in -5
.bd
ERRORS         
.in +5
.br
The
.bd
EOF
value is consistently returned, indicating that a 
.bd
FILffered, it is flushed by
.bd
read
(2) each time data is read from the standard input.
.sp 2
.in -5
.bd
ERRORS
.in +5
.br
By default, the standard error stream should be line buffered.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
fopen (3), getc (3), putc (3), alloc (3)
                                                                                                                                                                                                                                                         E 
pointer has not been initialized with 
.bd
fopen.
Thiу meanу thaф inpuф oт outpuф haу beeо attempteд oо aо outpuф 
oт inpuф stream, or that a 
.bd
FILE
pointer designates corrupt
.bd
FILE
data.

This use of the standard library has been changed to line buffer output
to a terminal by default.  It attempts to flush the output whenever a
.bd
read
(seе Sectioо 2© froн thе standarд inpuф iу necessary®  Iо mosф 
cases¬ thiу makeу thе utilitщ morе efficient.  Thе actionу 
themselveу shoulд bе transparenф unlesу it
is used with programs which use standard I/O routines 
.ul
and
.bd
read
(2) to read from the standard input. 

When large amounts of computation are done after outputting part of a line
to a terminal, it is necessary to
.bd
fflush
(3) the standard output before continuing on so that the output appears.
.sp 2
.in -5 
.bd
ALSO READ
.in +5
.br
close (2), open (2), read (2), write (2)                                                                                                                             br
Return values point to static data whose content is overwritten
by each call.
.sp 2
.in -5
.bd
FILES
.in +5
.br
/dev/*
.br
/etc/ttys
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
??ioctl (2), ttys (5)                                                                                                                                                                                                                                                                                                                             .he "system (3)                   3/24/82                   system (3)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
system
- issue a shell command
.sp 2
.in -5
.bd
C
.in +5
.br
.bd 2
system(string)
.br
char *string;
.sp 2
.in -5
.bd
FUNCTION
.in +5
.br
.bd
System
causes
.bd
string
to be given to
.bd
sh
(see shell - Section 1) as input just as if the string had been typed as
a command at a terminal.  Current process waits until the shell
has completed then returns t.he "floor (3m)                   3/22/82                   floor (3m)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
fabs, floor, ceil
- absolute value and floor and ceiling functions
.sp 2
.in -5
.bd
C          
.in +5
.br
.bd 2
double floor(x)
.br
double x;
.sp
.bd 2
double ceil(x)
.br
double x;
.sp
.bd 2
double fabs(x)
.br
double x;
.sp 2
.in -5
.bd
FUNCTION    
.in +5
.br
.bd
Fabs
returns the absolute value 
.bd
|x|.

.bd
Floor
returns the largest integer not grhe exit status of the shell.
.sp 2
.in -5
.bd
ERRORS
.in +5
.br
An exit status of 127 means the shell could not be executed.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
popen (3), exec (2), wait (2)                                                                                                                                                                                                                                                                                                                                eater than
.bd
x.

.bd
Ceil
returns the smallest integer not less than 
.bd
x.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
abs (3)                                                                                                                                                                                                                                                                                                                                                                                                    .he "ttyname (3)                  3/24/82                  ttyname (3)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
ttyname, isatty, ttyslot
- find name of a terminal
.sp 2
.in -5
.bd
C
.in +5
.br
.bd
char *ttyname(fildes)
.sp
.bd
isatty(fildes)
.sp
.bd
ttyslot()
.sp 2
.in -5
.bd
FUNCTION
.in +5
.br
.bd
Ttyname 
returns a pointer to the null-terminated path name of
the terminal associated with
.bd
fildes,
the file descriptor.

.bd
Isatty
returns a 1 if the file des.he "perror (3)                   3/23/82                   perror (3)"
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
perror                        
- system error messages
.sp 2
.in -5
.bd
C
.in +5
.br
.bd 2
perror(s)
.br
char *s;
.sp 2
.in -5
.bd
FUNCTION
.in +5
.br
.bd
Perror
displays error messages on the error file.  These messages describe the
last error encountered during a C program system call.  The
.bd
s
argument string is printed, followed by a colon, the criptor is associated with a terminal; 
a 0 is returned if it isn't.

.bd
Ttyslot
returns the number of the entry in the
.bd
ttys
file (see Section 5) for the control terminal of the current process.
.sp 2
.in -5
.bd
ERRORS
.in +5
.br
.bd
Ttyname
returns a 0 (NULL pointer) if the file descriptor does not describe
a terminal that exists in the "/dev" directory.

.bd
Ttyslot
returns a 0 if the "/etc/ttys" directory is inaccessible, or if
it can't determine the control terminal.
.sp 2
.in -5
.bd
NOTES
.in +5
.message and a
newline.  The argument string defines the name of the program in
which the error occurred.  The message is taken from
.bd
errno
(see Introduction to Section 2), which is set when errors have occurred
but have not been cleared.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
Intro (2)
                                                                                                                                                                                                                               .he "popen (3)                    3/23/82                    popen (3)"
.fo "                               -#-"  
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
popen, pclose
- initiates I/O to/from a process


.in -5
.bd
C       
.in +5
.sp
.bd
# include <stdio.h>
.sp
.bd 2
FILE *popen(command, type)
.br
char *command, *type;
.sp
.bd 2
pclose(stream)
.br
FILE *stream;


.in -5
.bd
FUNCTION   
.in +5
.br
The arguments to 
.bd
popen 
are pointers to null-terminated strings.  These strings contain: 
1) a shelPrintf
places output on
.bd
stdout
- the standard output stream.

.bd
Fprintf
places output on
.bd
stream
- the named output.

.bd
Sprintf
places output in the
.bd
s
string.  This string is followed by a "\0" character.

These functions convert, format and print their arguments under the
control of the first argument.  This first argument will be a character
string containing 1) plain characters that are copied to the output
stream, and 2) conversion specifications which enable conversion
and printing of thl command line
and 2) an I/O mode, either "r" for reading or "w" for writing.
A pipe is created 
between the calling process and the command to be executed.
The value returned is a stream
pointeт thaф may bе useд tп writе tп thе 
standarд inpuф oж thе commanд oт to reaд froн itу standarд output.

Streaнs openeд bщ 
.bd
popeо 
are closeд bщ 
.bd
pclosе.  Pclose 
waitу foт thе associateд procesу tп terminatе, then returnу thе exiф 
statuу oж thе command.

Since opeо fileу arе shared¬ the typе "rў commanд can e next
.bd
printf
argument.

The conversion specifications are introduced by the
.bd
%
character.  The options listed below may follow this character:
.sp 2
.in +4
A minus sign (-) specifying 
.ul
left adjustment
of the converted value in the indicated field.

A string of digits specifying
.ul
field width.
Converted values with fewer characters than the indicated field
width may be blank-padded to make up the difference, unless the
field width begins with a 0, in which case it will be zero-padded.

A periodbе useд aу 
aо inpuф filter,
the type "w" as an output filter.


.in -5
.bd
ERRORS     
.in +5
.br
.bd
Popen
returnу б ° (NULМ pointer© iж thе shelм cannoф bе accessed¬ oт iж 
fileу oт processeу cannoф bе created. 

.bd
Pclose 
returns -1 if 
.bd
stream 
is not associated with a command opened by 
.bd
popen.


.in -5
.bd
NOTES
.in +5
.br
Filter input may be badly positioned if user attempts
buffereд readinз beforе openinз aо inpuф filter® 

Similaт problemу 
witи aо outpuф filteт maщ bе prevented bщ flushin (.) may separate the field width from the next string of digits.

An additional digit string may be added specifying a
.ul
precision,
or the number of digits that will appear after the decimal point.  This
is used for
.bd
-e
and 
.bd
-f
conversions, or to specify the maximum number of characters
to be printed from a string. [An asterisk (*) may indicate
field width or precision, in which case an integer argument
indicates the field width or precision.]

A
.bd
1
may be specified with
.bd
d, o, x,    
or
.bdg the buffeт, i.e., using
.bd
fflush. 
[Seе 
.bd
fclose
(3).]


.in -5
.bd
READ ALSO
.in +5
.br
pipe (2), fopen(3), fclose (3), system (3), wait (2)                                                                                                                                                                                                                                                                                                                                                                            
u
to indicate correspondence with a long integer argument.  The
same thing may be accomplished with a capitalized conversion code.

Anщ characteт maщ bе giveо thaф specifieу thе typе oж conversioо 
tп bе executed.
.in -4
.sp 2
The conversion characters are listed and described below:
.sp 2
.in +4
.ti -1
.bd
dox
.br
Integer
.bd
arg
is converted to decimal, octal or hexadecimal notation.
.sp 2
.ti -1
.bd
f
.br
Float or double
.bd
arg
is converted to decimal notation in the following format:

.ce
.bd
[-]ddd.d.he "printf (3s)                  3/22/82                  printf (3s)" 
.fo "                               -#-"
.in 5
.rm 65
.bd
SUBROUTINE(S)
.in +5
.br
.bd
printf, fprintf, sprintf
- formatted output conversion

.in -5
.bd
C        
.in +5
.br
.bd
# include <stdio.h>
.sp
.bd 2
printf(format [, arg]...)
.br
char *format;
.sp
.bd 3
fprintf(stream, format [, arg] ...)
.br
FILE *stream;
.br
char *format;
.sp
.bd 2
sprintf(s, format [, arg ] ...)
.br
char *s, format;
.sp 2
.in -5
.bd
FUNCTION
.in +5
.br
.bd
dd

Thе precisioо specificatioо determineу thе amounф oж "d"s®  Б 
precisioо oж 0 results in no digits; defaulф is
six digits.
.sp 2
.ti -1
.bd
e
.br
Float or double
.bd
arg
is converted in the following format:

.ce
.bd
[-]d.ddde+dd

One digit before and one number after the decimal point equal the
precision specification. By default, six digits are produced.
.sp 2
.ti -1
.bd
g
.br
Float or double
.bd
arg
is printed in one of the formats listed above, depending upon which one
specifies full precision in the least amount of space.
.bp
.ti -1
.bd
c
.br
Character
.bd
arg
printed; NULL characters are ignored.
.sp
.ti -1
.bd
s
.br
Character
.bd
arg
is defined as a character pointer; string characters are printed up
to a NULL character, or if specified, up to point indicated by
the precision specification.
.sp 2
.ti -1
.bd
%
.br
Only the
.bd
% 
is printed; arguments are not converted.
.sp 2
.in 0
.in 5
.bd
NOTES
.in +5
.br
Small or non-existent fields do not cause truncation.  Fields are
padded when the specified yte sectors, single-sided,  975 blocks
    8",   256 byte sectors, double-sided, 1950 blocks
    8",   512 byte sectors, single-sided, 1125 blocks
    8",   512 byte sectors, double-sided, 2250 blocks
    8",  1024 byte sectors, single-sided, 1200 blocks
    8",  1024 byte sectors, double-sided, 2400 blocks

    5 1/4",  256 byte sectors, single-sided, 35 track,  160 blocks
    5 1/4",  512 byte sectors, single-sided, 35 track,  330 blocks
    5 1/4",  512 byte sectors, double-sided, 35 track,  660 blocks

field exceeds the actual width.

Fields larger than 128 characters will fail.

.bd
Putc
(3) prints the characters generated by
.bd
printf.
.sp 2
.in -5
.bd
ALSO READ
.in +5
.br
putc (3), scanf (3), ecvt (3)

                                                                                                                                                                                                                                                                                                                    5 1/4",  512 byte sectors, single-sided, 40 track,  380 blocks
    5 1/4",  512 byte sectors, double-sided, 40 track,  760 blocks

    5 1/4",  512 byte sectors, single-sided, 80 track,  780 blocks
    5 1/4",  512 byte sectors, double-sided, 80 track, 1560 blocks


.fi
Note that because of reserved tracks (usually the 
first two), the available space is reduced slightly.

All 8 inch formats are standard 77 track.

While you gain approximately 7% in additional
capacity with 1024 byte sectors on an 8 inc‡ .              ..            † djdma.4       … multio.4      „ null.4        ѓ io.4          ‚ hdca.4        Ѓ hddma.4         mem.4         џ cables.4      ћ ports.4       ќ printers.4      network.4                                                                                                                                                                                                                                                                                                                     h floppy diskette, 
the loss in transfer speed is considerable.

The optimum choice for Micronix floppy diskettes
is 512-bytes, single or double sided, unless
space considerations dictate otherwise.

The other formats are included for backward compatibility.

Alternate sectoring is optional and available by selecting
the appropriate minor device number from the table below.

Bit 4 of the minor device number selects
alternate sectoring.


(Alternate sectoring is recommended because
it doubles the reading spe.he "djdma (4)                   9/27/82                     djdma (4)"
.fo "                             -#-"
.in 5
.rm 65
.bd
NAME
.br
.in +5
.bd
djdma 
- Morrow Designs Disk Jockey Direct 
.nf
        Memory Access floppy disk controller
.fi


.ti -5
.bd
DESCRIPTION 
.br
The Morrow Designs DJDMA is an S-100 floppy disk drive 
controller.
This document describes the Micronix driver for the DJDMA.
All access to the DJDMA is handled by the driver.

The DJDMA provides
access to up to eight 8 inch and/or 5 1/ed, but does not make much
difference in writing speed.)

Note that alternate and non-alternate sectored media
are incompatible (i.e., the sectors appear scrambled).
The 
.bd
far 
utility (see Section 1) can read a CP/M formatted
diskette under either alternate or straight sectoring, however.


The sector arrangement schemes fall into classes
for even and odd sector per track values.

The sectors are numbered

0, 2, 4, 6, 8, 10, 12, 14, 1, 3, 5, 7, 9, 11, 13, 15

for a 15 sector per track disk (for instance4 inch floppy disk drives
(limited to four of each type).
At present, there may be only one controller board per system.

Currently, only IBM format 8" floppies and
10 hole, hard sectored 5 1/4" floppies are supported.

Diskettes used with Micronix must be formatted.

The following formats are supported.  They are
listed with the number of blocks per disk 
(a block is 512 bytes).
.nf


    8",   128 byte sectors, single-sided,  487 blocks
    8",   128 byte sectors, double-sided,  975 blocks
    8",   256 b).

and

0, 2, 4, 6, 1, 3, 5, 7

for an 8 sector per track disk.

The major and minor device numbers listed below are
used in conjunction with the mknod program.

See mknod in section 1 of the Micronix reference manual.


The major device number corresponding to the DJDMA is
currently 2.

The minor device numbers have the following meanings:
.nf

	minor	meaning

	 0	8" - drive 0
	 1	8" - drive 1
	 2	8" - drive 2
	 3	8" - drive 3

	 4	5 1/4" - drive 0
	 5	5 1/4" - drive 1
	 6	5 1/4" - drive 2
	 7	5 1/4" - drive 3

	 8	8" - drive 0 with alternate sectoring
	 9	8" - drive 1 with alternate sectoring
	10	8" - drive 2 with alternate sectoring
	11	8" - drive 3 with alternate sectoring

	12	5 1/4" - drive 0 with alternate sectoring
	13	5 1/4" - drive 1 with alternate sectoring
	14	5 1/4" - drive 2 with alternate sectoring
	15	5 1/4" - drive 3 with alternate sectoring


.fi
Note that there are 96-track 5 1/4" drives and 48-track 5 1/4" drives.
For example, if you have only 48 track drives, you cannot 
read 96-track diisk Controller Technical Manual
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ЎўЈ¤Ґ¦§ЁЄ«¬­                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .he "multio (4)                   12/2/82                   multio (4)"
.fo "                               -#-"
.in 10
.rm 65
.bd  
.ti -5
NAME
.br
.bd
multio 
- Morrow Designs MULT/IO board interface


.ti -5
.bd
DESCRIPTION
.br
The Micronix  
.bd
MULT/IO
interface supports all features of the
MULT/IO and Wunderbuss I/O boards.
It will run unchanged in rack mount or table top models of the Decision I.

Serial ports and both Diablo and Centronics style parallel
parallel protocols are supported.
A cable adaskettes.

There are five different
sets of delay constants available
for stepping delay and head settle delay.
The delay numbers for step time and head settle time
were taken from real-world drive descriptions
and are intended to be appropriate for the drive
types listed below.

If you are using a drive not listed below,
you should select the ones most closely suited to the 
types of drives you are using.


Refer to the following table:


	seek	settle	minor	type
	
	 8	 8	 0	SA 800		(8" drives)
	 3	15	16	SA pter (available from Morrow Designs)
is required to use the MULT/IO with a 
Centronics style parallel interface.

The MULT/IO board has three ACEs (Asyncronous Communication
Elements) and 1 parallel port for I/O device connection. 
The ACEs communicate via standard RS232 serial interface.
The parallel port is a standard Diablo (50-pin daisy-wheel) interface.

Each MULT/IO board must have its I/O port addresses set by means of
switches on the circuit board.  For proper operation, the base I/O 
address must b850


	 5	15	 0	Tandon
	20	20	16	SA 200		(5 1/4" drives)
	40	10	32	SA 400



The column entitled "seek" gives the seek time in milliseconds per track.
"settle" is the disk drive head settle time in milliseconds.
"minor" is the minor device addend, and "type" gives
manufacturers drive types.
"SA" stands for Shugart Associates.

To select a particular drive type, add in the value listed in
the "minor" column of this table.

If you are familiar with binary notation, the drive type
is encoded in bits 4 and 5 ofe 48 (hex) for the first MULT/IO board.

In a Micronix system in which there are possibly many MULT/IO boards,
the boards form a series.  In the Decision I Table Top model, the
Wunderbuss I/O motherboard functions as the first of the series.
Micronix expects to find the Mult/IO boards (or Wunderbuss) as
I/O (hex) locations 48, 58, 68, 78.
The current incarnation of the Micronix Mult I/O drivers
supports at most 4 Mult I/O boards (or 1 Wunderbus I/O and 3 Mult I/O boards).

In the following we talk about "m the minor device number.


.ti -5
EXAMPLES
.br

For a SA800 drive "A" with alternating sectoring
the minor device number would be 8.

For a SA850 drive "A" with alternating sectoring
the minor device number would be 24.

For a SA200 drive "A" with alternating sectoring
the minor device number would be 28.


To create an appropriate special file for an SA200 (5 1/4" drive),
the command would be:

	mknod /dev/mfa b 2 28


.ti -5
.bd
SEE ALSO
.br
mknod (1), far (1)

Disk Jockey / Direct Memory Access Floppy Dinor device numbers".

Use "mknod" to create a new special file with a particular
minor device number.

Use "ls -l" to view the minor device numbers of existing
files.

Minor device numbers 0-3 
refer to the Mult/IO board addresses at I/O location 48 hex.

Minor device numbers 4-7 refer to the Mult/IO board addresses at 
location 58 hex, and so on with 68, 78.

The first minor device number of each group of four refers to 
the parallel printer on that board.
Minor device numbers 0, 4, 8, etc. refer to parallel printers.

If the 16's bit is set in the minor device number, then
the port will be treated as a Centronics rather than 
Diablo parallel interface.
Minor device numbers 16, 20, 24, and 28 refer to Centronics
parallel ports on the four MULT/IO boards.

You may mix Diablo and Centronics style
parallel interfaces in the same system.
It is possible to run Centronics interface printer(s)
and Diablo interface printer(s) concurrently.

Sending data to the Mult I/O is fairly straightforward
except for thsion.

tty (4) - Description the tty interface.

mknod (1) - Make a new special file.

ls (1) - List files (including major/minor device numbers).
                                                                                                                                                                                                                                                                e case of the Diablo parallel interface.

Here the parallel data path is wider than one byte.
In order to pass data to the driver through a byte
stream, a special format was developed.

A conversion filter
is provided which is capable of encoding an ordinary
text file into a form suitable for the driver.

Bytes sent to the parallel printer device have the following format:

.in +3
Each byte is stand-alone and has a meaning all by itself.

Bit-0 is the least significant bit and bit-7 is the most significant
.in 5
.rm 65
.he "null (4)                    6/25/82                      null (4)"
.fo "                              -#-"
.bd
NAME
.in +5
.br
.bd
null 
- the null device
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
The null device has the curious property that
everything written to it is completely ignored and thrown away.
Reading from this device yields
an end of file every time.

The minor device number is ignored.
The major device number is zero in the current
implementation.

This device may seem to be ofbit in this discussion.

There are two types of information one can send to the 
printer, motion commands and print commands.

If bit-7 is clear, the the byte is taken to mean a character to be
printed.
Otherwise,
if bit-7 is set, the byte indicates a motion command.

If bit-6 is set, the byte indicates vertical motion.

If bit-5 is set, the byte indicates backwards motion
(up or left).

Bits 0 - 4 (the low order 5 bits) are taken to be the magnitude of motion
desired.
.in -3

The unit of motion is 1/120"  limited usefulness,
but don't get rid of it, the shell uses it
to set up the standard input of background processes.
.sp 2
.in -5
.bd
EXAMPLE
.in +5
.ti +5
.br
cat file > /dev/null

To read a file but discard the results.
                                                                                                                                                                                                                                                                                                 for horizontal motion and
1/48" for vertical motion.

If you want to move farther than 31 increments,
you must send a series of motion bytes.

These are accumulated and optimized, then sent all at once.

Note that this scheme allows elaborate high-level interface.
Even several different interfaces, each
with its own set of escape sequences or what have you, all translate
to common Mult/IO parallel printer motion and print byte formats.


.ti -5
.bd
SEE ALSO
.br
diablo (1) - Diablo parallel high level conver.in 5
.rm 65
.he "io (1)                       7/19/82                       io (1)"      
.fo "                               -#-"
.bd
NAME
.in +5
.bd
io 
- Z80 I/O space device
.sp 2
.in -5
.bd
DESCRIPTION
.br
.in +5
Under a multi-user operating system, it is not acceptable
to allow user programs to execute certain instructions
in an unregulated way.  
The Z80 instructions "in" and "out" fall into this category.
It is, however, desirable to be able to perform these operations
in special circumstances.

Th®Ї°±Ііґµ·                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              e "io" device allows users to access the Z80 I/O ports
through the file system.
Reading from the device causes the results of "in" instructions
to be transferred to the user's memory space.

Writing to the device causes "out" instructions to be executed
using the data in the user's memory space.

Seeking on the device sets the I/O address for subsequent
reading/inputting or writing/outputting.

There are two classes of I/O device.
One allows access to all of I/O space.
The other allows access only to a single port.

Note that it would be extremely easy to crash the system
through this avenue, and it is therefore
recommended that the "/dev/io" file be heavily protected,
perhaps mode 0 and owned by root.

Examples are in order:
.sp
.in +5
To input a value from port 10:
.sp
.nf
.bd
	f = open ("/dev/io", 0);

	seek (f, 10, 0);

	read (f, &data, 1);
.sp
.in -5
.fi
The operation of the I/O device is dependent on the minor
device number of the special file associated with it.

All 256 possible minor device numbers ( drive B is called "hdb", etc.
The major/minor device numbers are:

.ti +5
.nf
1/0  hda      1/1  hdb      1/2  hdc      1/3  hdd
.fi

Unlike the HDDMA drives, Micronix can automatically detect
the size of the HDCA drives, so there is no need to indicate
the drive size in the device name or number.

Micronix does not support a disk formatting program, so
each drive must be formatted under CP/M.
A sector skew of 6 is recommended, but is not critical.
Since these drives are soft-sectored, there is no
compatib0 - 255) have meaning.

When accessed through minor device zero, it is possible to
select which I/O ports you access.
This is the meaning of a seek on the io device file.
For example, seeking to location 87 will cause subsequent
reads and writes to the file to be interpreted as references
to io port 87.

Unlike other devices, the file offset does not progress
with reads and writes.
It may only be changed by seeking.
It was thought that this arrangement was more in the spirit
of I/O space accesses than the mility problem with different skews.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ore Micronix-like alternative.

Non-zero minor device numbers limit access to that one I/O port
whose address is the same as the minor device number.
It is therefore possible to have I/O space
selectively protected, while giving any user access
to some certain port.

For example, if you wanted to allow free access to ports
77 and 78 by any user on the system, you would issue the following
commands:

	mknod /dev/io77 c 3 77

	mknod /dev/io78 c 3 77

	chmod a=rwx /dev/io77 /dev/io78


If the minor device numb.he "hddma (4)			 8/6/82			     hddma (4)"
.fo "                             -#-"
.in 5
.rm 65
.bd
DEVICE
.br
.in +5
.bd
HDDMA
- Morrow Designs' dma hard disk controller


.in -5
.bd
FUNCTION
.in +5
.br
The HDDMA controls up to four 5 1/4 inch Winchester disk drives.
Micronix currently supports 3 drive sizes:

.in +5
.nf
m5      5 megabytes
m10     10 megabytes
m16     16 megabytes
.in -5
.fi

The device names (in the /dev directory) for these disks
depend on their position on the HDDMA daisy-chain.
An m5 aer is not zero, seeks are simply ignored.


.in -5
.bd
FILES
.in +5
.br
/dev/io - the device file
                                                                                                                                                                                                                                                                                                                                                                                                                              ttached as drive A is called "m5a", an m16 attached
as drive D is called "m16d", etc.
The major/minor device numbers are as follows:

.in +5
.nf
3/0  m5a        3/4  m10a       3/8  m16a
3/1  m5b        3/5  m10b       3/9  m16b
3/2  m5c        3/6  m10c       3/10 m16c
3/3  m5d        3/7  m10d       3/11 m16d
.in -5
.fi

Micronix does not support a disk formatting program, so each
drive must be formatted under CP/M. A sector skew of 6 is
recommended, but is not critical. Since these drives are
soft-sector.he "hdca (4)			 8/6/82			      hdca (4)"
.fo "                             -#-"
.in 5
.rm 65
.bd
DEVICE
.br
.in +5
.bd
HDCA
- Morrow Designs' Winchester disk controller


.in -5
.bd
FUNCTION
.in +5
.br
The HDCA controls up to four 8 inch Winchester disk drives.
Micronix currently supports 3 drive sizes:

.in +5
.nf
m10	10 megabytes
m20	20 megabytes
m26	26 megabytes
.in -5
.fi

The device names (in the /dev directory) for these disks
depend on their position on the HDCA daisy-chain.
Drive A is called "hda",ed, there is no compatibility problem with
different skews.

If you ever have to explore the surface of one
of these drives without the intervention of Micronix,
you should know that Micronix logically "rolls" the tracks
by (number of tracks) / 2. Thus on an m5, which has 153
tracks, logical track 0 is physical track 76.
The reason for this is that most Micronix systems have
only one hard disk, which must serve as both the root
device and the swap device. When Micronix sees that
rootdev == swapdev, it uses the space above the file
system as swap space. Thus, the logical disk looks like:

.in +5
.nf
 ilist           file space             swap space
|-------|-----------------------------|------------|

.ti -5
while the physical disk looks like:

 file space   swap space   ilist     file space
------------|------------|-------|-----------------
.in -5
.fi

In a busy system, the disk heads spend most of their time
over the swap space and the ilist, so this gives a
performance advantage.
                          length of 25 feet (although much longer
cables have been known to work). The parallel cables can be made
with 50 conductor flat cable. They both have a 50 pin female
flat cable connector (Ansley 609-5000M) on the computer end. Cable 6
has the same connector on the the printer end, while cable 5 uses
a 36 pin female ribbon connector (Amphenol 57-40360).


.bp
.ti -5
DECISION TO SERIAL PRINTER OR TERMINAL
.br
The  cable required to comunicate with a terminal or printer  can
be  constructed so that it will wo.in 5
.rm 65
.he "mem (4)                    6/25/82                        mem (4)"
.fo "                              -#-"
.bd
DEVICE
.in +5
.br
.bd
mem
- core memory device
.sp 2
.in -5
.bd
DESCRIPTION
.in +5
.br
This device reads and writes kernel memory (addresses 0 to FFFF).
One must be exceedingly careful in protecting this device,
since there are several hardware registers in this address range
that will crash the system upon being read.
                                                              rk with both the Decision and
the MULTIO board. This  assumes  that  the   hardware
handshaking  on the printer is via pin 20. (Most printers  support
this. One exception is the NEC Spinwriter, which uses pin 19 instead.)

The Decision's serial ports cannot be jumpered.
On the MULTIO, the appropriate serial port
should be jumpered as follows:

.nf
         --------------------
        |                    |
        |  A  B  C  D  E  G  |
        |  |  |  |  |  |  |  |
        |  H  I  J  K  L  N  |
        .in 10
.rm 79
.he "          cables (1)                     4/6/83                      cables (1)
.fo "                                          -#-"
.ta 5
.ti -5
NAME
.br
.bd
cables
- cables for modems, terminals, printers, and the network

.ti -5
DESCRIPTION
.br
This document tells you how to build cables
to connect the Decision to various devices.
The presentation is rather technical.
If you don't want to build one of these cables yourself,
you may purchase it from your dealer or from Morrow,
or your de|                    |
         --------------------
.fi

The cable requires 22 guage shielded 8 conductor wire.
The pinout for both the MULTIO and the Decision is the same:

.nf
         ---------------------------
        |         DECISION          |
        |     DB-25P connector      |
        |                           |
        |  1  2  3  7  5 6 8   20   |
        |  |  |  |  |   \|/    |    |
        |  |  |  |  |    |    /|\   |
        |  1  2  3  7    20  5 6 8  |
        |                     aler may be able to build it for you from these specifications.

The first three serial ports on the Decision
use the Wunderbus I/O motherboard, which
(unlike the MULTIO expansion board) has  no  provisions   for
configuring the RS-232 connections via jumpers.
Thus the cables must do this configuration internally.
Also, the Wunderbus has an artwork error which
assigns pin 5 as Carrier-Detect (RLSD) and pin 8 as Clear-To-Send
(CTS).  The cables detailed below take this into account.

Four serial cables and t      |
        |     DB-25P connector      |
        |    PRINTER or TERMINAL    |
         ---------------------------
.fi

Note: For most terminals, only pins 2, 3, and 7 need
be connected.
The cable described here has the advantages of working
interchangablly with printers and terminals, and of
higher reliability at high baud rates.


.bp
.ti -5
NETWORK
.br
The Micronix network uses the serial ports on the Decision
or the MULTIO. Since the first priority in
designing this network was low cost, a simple wo parallel cables are discussed:

        1. Decision to serial printer or terminal
        2. Decision to Decision (network)
        3. Decision to modem
        4. MULTIO to modem

        5. Decision to Centronics-compatible parallel printer
        6. Decision to Diablo-compatible parallel printer

In general, the serial cables require two DB-25P male connectors
(ITT Cannon or AMP) with shielded shells on both ends, and should
be made with 22 guage shielded wire. The RS-232 standard
specifies a maximumunshielded
3 conductor cable is specified.
(The network does extensive error checking, so noise on the
cable will only slow it down.)
The MULTIO should be jumpered as for #1 above.
The cable should be constructed as follows:

.nf
         ----------------------
        |  Decision or MULTIO  |
        |                      |
        |   DB-25P connector   |
        |       2  3  7        |
        |       |  |  |        |
        |       3  2  7        |
        |   DB-25P connector   |
        |          ИЙКЛМНОПСТУФХЦЧШЩ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  DECISION                        |
|              50 pin flat cable connector             |
|                                                      |
|  2  3  12 13 21 24 26 27 28 33 36 37 39 40 42 43 45  |
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   |
|  16 12 32 31 1  36 10 11 13 5  3  2  4  6  7  8  9   |
|                                                      |
|            36 pin female ribbon connector            |
|            CENTRONICS-COMPATIBLE PRINTER             |
 -            |
        |  Decision or MULTIO  |
         ----------------------
.fi


.ti -5
DECISION TO MODEM
.br
This requires 22 guage shielded 8 conductor wire:

.nf
         ---------------------------
        |          DECISION         |
        |      DB-25P connector     |
        |                           |
        |  1  2  3  5  6  7  8  20  |
        |  |  |  |  |  |  |  |  |   |
        |  1  3  2  8  6  7  5  20  |
        |                           |
        |      DB-25P connector     |
  -----------------------------------------------------

or, sorted the other way:

 ------------------------------------------------------
|                      DECISION                        |
|              50 pin flat cable connector             |
|                                                      |
|  21 37 36 39 33 40 42 43 45 26 27 3  28 2  13 12 24  |
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   |
|  1  2  3  4  5  6  7  8  9  10 11 12 13 16 31 32 36  |
|                                     |           MODEM           |
         ---------------------------
.fi

.bp
.ti -5
MULTIO TO MODEM
.br
(Note: this discussion assumes that the serial ports on the MULTIO
have been brought out to female D connectors on the back of the
computer with special cables installed at the factory. If this has
not been done, you can order these "MULTIO serial cables" from Morrow.)

Jumper  the appropriate MULTIO serial port for modem communications
as follows:

.nf
         -----------------------
        |                            |
|            36 pin female ribbon connector            |
|            CENTRONICS-COMPATIBLE PRINTER             |
 ------------------------------------------------------
.fi


.ti -5
DECISION TO PARALLEL DIABLO
.br
This cable also works with the MULTIO expansion board,
since its parallel port is identical with the Decision's.
All you need is
a simple straight-through 50 conductor cable with 50-pin
flat cable female connectors on both ends.
It is the same cable that Morrow uses for i                  |
        |  A  C  D  E  F  G  H  |
        |  |  |  |  |  |  |  |  |
        |  B  J  K  L  M  N  I  |
        |                       |
         -----------------------
.fi

The cable from the computer to the modem
requires 22 guage shielded 8 conductor wire:

.nf
         ---------------------------
        |         to MULTIO         |
        |      DB-25P connector     |
        |                           |
        |  1  2  3  5  6  7  8  20  |
        |  |  |  |  |  |  |  |  |   |
ts disk drives.
If you need to build the cable, only 17 conductors are
actually needed:

.nf
 ------------------------------------------------------
|                      DECISION                        |
|              50 pin flat cable connector             |
|                                                      |
|  2  3  12 13 21 24 26 27 28 33 36 37 39 40 42 43 45  |
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   |
|  2  3  12 13 21 24 26 27 28 33 36 37 39 40 42 43 45  |
|                            |  1  2  3  5  6  7  8  20  |
        |                           |
        |      DB-25P connector     |
        |           MODEM           |
         ---------------------------
.fi


.bp
.ti -5
DECISION TO PARALLEL CENTRONICS
.br
This cable also works with the MULTIO expansion board,
since its parallel port is identical with the Decision's.
This is the most complex cable. It is available by
special order from Morrow. Its pinout is:

.nf
 ------------------------------------------------------
|                                    |
|             50 pin flat cable connector              |
|              DIABLO-COMPATIBLE PRINTER               |
 ------------------------------------------------------
.fi
                                                                                                                                                                                                                                                                                                              .he "ports (4)                    3/23/83                    ports (4)"
.fo "                               -#-"
.in 10
.rm 65
.ti -5
NAME
.br
.bd
ports
- how to identify the IO ports on the Decision I

.ti -5
DESCRIPTION
.br
The back of the Decision I has at least three "serial" ports
and at least one "parallel" port. The serial ports look like thin
sideways D's. They are called 25 pin female D connectors.
(There is a smaller 15 pin female D connector that is not used.)

The parallel ports are 50 pin "flatl jack should be labeled
.bd
ttyE,
and the D connector attached to the
.bd
left-most
(as seen from the back)
serial jack should be labeled
.bd
ttyF.

If you have a third or fourth MULTIO, then its serial ports
should be labeled correspondingly as
ttyG, ttyH, ttyI, and ttyJ, ttyK, ttyL.

The parallel ports attached to the second, third, and fourth MULTIOs
should be labeled ppr1, ppr2, and ppr3. (Remember that
the first one was called ppr0.)

.ti -5
.bd
NAMES
.br
Under Micronix,
the twelve possible serial por cable" male connectors.
The same kind of connector may also be used for disk drives, so you must
look inside the computer to tell which is which.
The connector is a parallel port if its cable goes to the
"bus board" (on the tabletop model)
or to a MULTIO board. It is a disk-drive port if
its cable goes to a disk controller.
(If you're not sure how to recognize a bus board, MULTIO board,
or disk controller, you should ask your dealer for assistance.)

Once you have identified the serial ports and parallel pts are consistently refered to as
ttyA through ttyL. (Some of the documentation that comes with the
Decision I hardware refers to ttyA as the "console" or as "serial
port 1", ttyB as "serial port 2", etc.)
Names for the parallel ports are a little more involved.
If ppr0 is connected to a parallel daisy-wheel printer, it is
called "diab0". If it is connected via a special cable
(available from Morrow)
to a Centronics type printer, it is called "cent0".

.nf
            references to       references to
IO boorts,
you should make sure that they are labeled.
Here is a stylized picture of the back of a basic tabletop
Decision I with the ports labeled:

.nf
 ---------------------------
| ************************* |
| ************************* |
 ---------------------------
            ppr0

-----------------   -----------------   -----------------
\ ************* /   \ ************* /   \ ************* /
 \ *********** /     \ *********** /     \ *********** /
   -----------         -----------         -----------ard    serial ports        parallel port
--------    --------------      --------------
first       ttyA ttyB ttyC      diab0 or cent0

second      ttyD ttyE ttyF      diab1 or cent1

third       ttyG ttyH ttyI      diab2 or cent2

fourth      ttyJ ttyK ttyL      diab3 or cent3

.fi
These names are arbitrary, by the way: they are not built
into any program. But they are built into three other places:

.in +5
1. They appear in the /dev directory as names for device files;

2. They appear in the /etc/ttys fil
      ttyC                ttyB                ttyA

.fi
The back of a rack-mount Decision looks slightly different,
but the important thing is that on both models,
.bd
the first serial port, called ttyA, is the right-most one
(when looking at the computer from the back).

If you add a MULTIO board, its serial ports
should be labeled as follows. Make sure that the board is
plugged into the bus (with the component side of the board
facing the the front of the computer), and that three flat
cables are connectЪЫЬЭЮЯабг                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ing the board to three D connectors at the
back of the computer. (If you don't know how to do this,
or if you aren't sure which MULTIO is the second one,
you should ask your dealer for help.)
Stand in back of the computer and look at the MULTIO.
The three small connectors along the top of the MULTIO
are the serial "jacks"; the large one is the parallel jack.
The D connector attached
to the
.bd
right-most
(as seen from the back)
serial jack should be labeled
.bd
ttyD.
The one attached to the
.bd
middle
seriae in reference to these devices;

3. Finally, the curious program /bin/diablo (q.v.) may be linked to
a name that matches a device name in /dev. If so, it will write
to a parallel diablo printer attached to that device.
.in -5

If you want to change any of these names, make sure to change all
three occurrances.

.ti -5
.bd
SEE ALSO
.br
lpr (1), diablo (1), multio (4),
cables (4), printers (4), terminals (4),
ttys (5)
                                                                                           .he "printers (4)                4/4/83                   printers (4)"
.fo "                             -#-"
.in 10
.ta 5
.rm 65
.ti -5
NAME
.br
.bd
printers
- interfacing printers to Micronix


.ti -5
INTRODUCTION

This document explains what kinds of printers are supported by Micronix,
how to plug them in, and how to test them.
This is not a stand-alone document, however. You will have to refer
to several others as you read. This will be easiest to do with the
printed version of the Micronix Reference M IN  THE PRINTER.   If you don't have one of  these  two
types, or are unsure of which type you are using, read on.

Serial  printers  use  either   software
handshaking or hardware handshaking.   Software handshaking means
that  when  the printer's buffer is full it sends a "byte"   to
the   computer  to temporarily stop  the  flow of
characters.  The  printer sends a different byte when it  is
ready  to receive again.   The byte that Micronix recognizes
for stopping transmission is X-OFF.   Other aliases anual. If you are reading
this at your terminal, you can switch to another document by hitting
DELETE or RUBOUT to get out of this one, and then typing the command
"help" followed by the new document name. The related documents are:

.ti -5
.bd
ttys (5)
.br
The document "configuration" in Section 5
(type the command "help configuration")
explains how to configure Micronix for additional printers,
automatic access from upm (the
Micronix CP/M emulator),
different baud rates, and hardware handshaking.

.ti -5
for X-OFF are
control-S, DC3 and 13 hex.  The byte that restarts output is
X-ON,  also known as control-Q,  DC1 and 11 hex.
If your printer uses X-ON and X-OFF, then you can skip ahead to
the section PLUGGING IN YOUR PRINTER. If you have  a
serial printer that doesn't use X-ON and X-OFF  (for example,  it
uses   ETX  and  ACK  instead),  you'll  have  to  try   hardware
handshaking.

Hardware handshaking makes use of one of the wires in the
printer cable to start and stop output from the computer.  When  th.bd
lpr (1)
.br
The document "lpr" in Section 1
(type the command "help lpr")
explains how to use the Micronix spooling program called lpr.
This allows several users to print files without conflict.

.ti -5
.bd
upm (1)
.br
The document "upm" in Section 1
(type the command "help upm")
explains (amoung many other things) how to use printers from
the Micronix CP/M emulator.

.ti -5
.bd
cables (4)
.br
The document "cables" in Section 4
(type the command "help cables")
explains how to build cables for various dee
printer wants to stop transmission, it lowers the voltage on this
wire.  To continue transmission, the voltage is raised again.
Unfortunately, there is no real standard for which wire
the printer should use.
Hardware handshaking  between  a
printer  and the Decision will probably require a special cable.

If your  printer requires hardware handshaking,
you will have to do two things:
(1) read the document "cables" in Section 4, and then make or
purchase a suitable cable, and (2) read the document "configuvices, including printers.

.ti -5
.bd
ports (4)
.br
The document "ports" in Section 4
(type the command "help ports")
explains how to identify the various I/O connectors on the Decision.


.ti -5
PRINTER INTERFACES

Micronix  and  the Decision come equipped to  handle  four
types  of  printer  interfaces.   The  interface  refers  to  the
physical  connection,  the  cable,  between the printer  and  the
Decision.  The interface also refers to the type of "handshaking"
used by your printer. This is the methдежзийклнопрсту                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  od it uses
to stop the flow of characters from the computer when
it  gets  behind.
The four types of interfaces are:

.in +5
1. Serial (or "RS-232") printers with hardware handshaking,

2. Serial printers with software ("XON XOFF") handshaking,

3. Parallel printers with Centronics-standard interfaces, and

4. Parallel printers with Diablo-standard interfaces.
.in -5

If you have either the first or second type of printer, you're in
luck.   You  can skip the rest of this section and start  reading
PLUGGING ration" in
Section 4, and then tell Micronix that your printer needs
hardware handshaking.

Parallel printers also require special cables (which you can
either make or purchase from Morrow).
Please read the "cables"
document,  then return  to  the  next
section  and  follow  instructions for  parallel  printers.


.ti -5
PLUGGING IN YOUR PRINTER

In the discussion that follows, we will assume that you are
going to plug a serial printer into the port called "ttyC", and/or
a parallel printer into the port called "ppr0". If you don't
know how to find these ports, please read the document called
"ports".
If you want to use other ports, you will have to tell Micronix
which ports you are using. The document "configuration" tells
how to do this.

The serial printer can only be plugged in one way, so you
don't have to worry about which way to orient the connector.
However, the 50 pin parallel connector is not "keyed": that is, it
is quite possible to plug it in upside down.
Read on for some guidance.  On many cables,re  bought  cables
checked  for  flaws.    RS-232  cables,   whether  home-made   or
purchased,  can  be  checked by using them to replace  the  cable
connecting  your  terminal.  Parallel cables can be  checked  for
continuity.
                                                                                                                                                                                                                                                                                            pin 1 is
labeled by having a  red  stripe on that edge.   Or,  if you
constructed  your  own cable,  you should know where pin 1 is.
The 50 pin connector on the back of your Decision has pin 1 on
the left hand side  when looking at the back of the printer. Plug
the parallel cable into the Decision with the red stripe, and
pin 1, toward the left.


.ti -5
TESTING YOUR PRINTER

Plug in your printer, turn it
ON,  and make sure that it is ON-LINE and set to "1200 baud".
(These settings are usually governed by .in 15
.rm 79
.he "          create (1)                     4/6/83                      create (1)
.fo "                                           -#-"
.bd
.ti -5
NAME
.br
.bd
create
- create a new file


.ti -5
.bd
SYNTAX       
.br
.bd
create file ...


.ti -5
.bd
DESCRIPTION 
.br
.bd
Create
simply creates empty files with the given names.
If a file with the same name already exists,
it is left unchanged. (Note that this is different
from the usual UNIX behavior, which is to believe
the user and destroy switches on the printer.
Sometimes the switches are on the inside, especially the baud rate
switches.) If you can't set your printer to 1200 baud, you will
have to change Micronix to transmit at whatever rate is acceptable.
The document called "configuration" explains how to do this.

For serial printers plugged into ttyC, type the command

     echo A > /dev/ttyC

There are two different test commands for parallel printers.
The difference between them is the way the device is named.
For parallel daisy-wheeexisting files when asked to do so.)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           l printers plugged into ppr0, type

     echo A > /dev/diab0

and for Centronic style parallel printers plugged into ppr0, use

     echo A > /dev/cent0

Did you get an "A" on your printer?
If not, remember
that  interfacing  printers  IS non-trivial.   First, rule out the
trivial problems by checking to see if:

.in +5
1. the printer is turned on (and plugged in),

2. the printer is set to ON-LINE,

3. there is paper in it (many printers won't print  unless
they  can  sense  a piece of paper in  them),  anLet's begin by describing the simplest network: two machines with one
cable between them. First, you must choose names for the two machines.
These names are arbitrary; the only requirement is that each machine
on the network must have a unique name. The names should also be short
and easy to type. In this case, let's call them "sales" and "doc".

Next, you must buy or build a cable long enough to connect them.
(See
.bd
cables
in section 4.)
Then you must choose a free serial port on each machine
(see
.bd
pod

4. the  cable is plugged in at both ends at  the  correct
connector.
.in -5

If  you have a parallel cable,  you can also try plugging  it  in
upside  down.   After  trying  all of the  suggestions,  try  the
suggested command again,  please.   If you get a different letter
than  an  "A",  there may be some wires scrambled  in  your
cable, or your serial printer may be set to the wrong baud rate.

If none of these suggestions helps,  your cable is  suspect.
Home  built  cables should be rechecked and storts
in section 4).
Let's say that you have choosen ttyD on doc, and ttyF on sales.
The cable can be plugged in at this point -- either end to either
machine.

Now you must edit three files on each machine. These files are:

        /etc/ttys
        /etc/netmap
        /etc/rc

The /etc/ttys file tells which IO ports on the local machine are
connected to the network. The /etc/netmap file gives the layout
of the network. The /etc/rc file contains commands that are run
every time the system goes multi-user. I