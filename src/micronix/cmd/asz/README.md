#
# assembler modified to become a compiler backend for the whitesmith's C compiler
# producing whitesmith's object files. 
# rather than to dig into the details, I turned it into a 3 pass assembler.  i could
# have done it in two passes if I diverted the binary output into a temp file, which
# i may do anyway.
#
# for size reasons, I may delete the .type operator and all it's related functionality.
# this is a kinda cool feature, but on a Z80, memory is tight.
#
# on another note, the declaration syntax for data is utterly brain dead.
# 

# Assembler
Assembler for the TRASM toolchain. Takes in a source file and assembles it into an object file, including relocations and symbol table. If multiple source files are provided, they will be concatenate together in the order they were passed in.

## Usage
```
as [-vg] source.s ...
```
| Option | Description |
| ------ | ----------- |
| -v     | Verbose output, will display version information, and how many bytes the assembly would consume if it were ran on Z80 hardware |
| -g     | All routine labels will automatically be made global and included the object symbol table |

## Instructions
As mentioned, the assembler is capable of assembling all Z80 instructions, both documented and undocumented. For undocumented instruction syntax, the following website was used as a reference.

https://clrhome.org/table/
## Symbols
Symbol definition follows the syntax used in Version 6 UNIX. Unlike most Z80 assemblers, the `equ` directive is not used. All symbols can also be redefined as many times as needed, thought this isn't recommended for labels as it may make the final product confusing to read. Symbols are limited to 8 characters to save memory. If a symbol is longer than 8 characters, the other characters will be ignored. The following code example will show off some simple symbol definitions:
```
; basic symbol definition, sym_1 is absolute
sym_1 = 0

; label symbol, label_1 is in whatever segment was currently selected
label_1:

; label generated by defl
; similar to a standard label, but label_2 will inherit the defined type
.defl byte label_2 0, 1, 2

; local symbol, consumes less memory than a standard symbol
; only 0-9 are valid
; when addressed, 'b' or 'f' must be specified for the assembler to search forward or backwards for the local symbol
1:
  jp 1b
```

## Directives
A small number of directives are included in the assembler to make configuration and data generation easier

| Directive | Description |
| --------------------------- | ------- |
| `.def (type)[#] exp1, exp2, ...` | Directly defines data, based on the type. Each element of the definition will take the size of the type, zero padding if needed. A set of square brackets after the type can be used to identify a set number of elements to be created |
| `.defl (type)[#] (name) exp, ...` | Same as `def`, but will create a label with the defined type |
| `.text`                           | Sets the current segment to text |
| `.data`                           | Sets the current segment to data |
| `.bss`                            | Sets the current segment to bss |
| `.if exp`                         | If the exp resolves to 0, skip all until next .endif. Exp must be defined and absolute |
| `.endif`                          | Marks the end of a `.if` block |
| `.extern sym1, sym2, ...`         | Defines an external symbol |
| `.globl sym1, sym2, ...`          | Sets a symbol to global, externals cannot be made global |
| `.type name { type_1, ...}`       | Defines a type, will be elaborated on later |
## Types
The TRASM assembler has the ability to define custom types. These types act as primitive structs and make handling custom data
structures a bit easier. The size of a type is equal to the size of its child symbols. Child symbols occupy a different namespace than normal symbols. Below is an example type being defined:
```
.type symbol {
  byte[8] name,
  byte type,
  word value,
  
  word next
}
```
The offsets for child symbols can be indexed by using the symbols name directly. For example, the statement `symbol.value` will return the absolute value `9`, giving the offset of the element in the struct. In addition to offset, the `.defl` directive can be used to define typed labels:
```
.defl symbol exsym {
  "test",
  1,
  0x1234,
  0
}
```
In this case, the statement `exsym.value` will return the address to the value element in memory. This would be the same as `exsym + symbol.value`. The size of a type can be accessed using `$(type)`.

## Expressions
All numberic or symbol inputs during assembly are treated as expressions. These will be fully parsed before they are emitted. When evaluating an expression, the order of operation is observed. The expression will either be absolute if it contains only numbers, or it will inherit the segment that the included symbols exist in. When using segment symbols, special rules apply.

- Absolute symbols can be used as-is, and do not have any special rules
- Segmented symbols (text, data, bss) cannot be intermixed, only one of these symbols allowed per expression
- External symbols can only be added to or subtracted from using absolute values

The following operators can be used in an expression
| Operator | Precedence | Function |
| -------- | ---------- | -------- |
| !        | 1          | A OR (NOT B) |
| +        | 2          | A ADD B |
| -        | 2          | A SUB B |
| *        | 3          | A MUL B |
| /        | 3          | A DIV B |
| %        | 3          | A MOD B |
| >>       | 4          | A RSHIFT B |
| <<       | 4          | A LSHIFT B |
| &        | 5          | A AND B |
| ^        | 6          | A XOR B |
| \|       | 7          | A OR B |

Numeric values can be written in the following formats:

- Decimal (`0`)
- Hexadecimal (`0x00, 0h00, 00x, 00h`)
- Octal (`0o00, 00o`)
- Binary (`0b00, 00b`)
